[
  {
    "!name": "gamesparks",
    require: {
      "!doc": "Imports a module into the current scope",
      "!type": "fn(shortCode: string)",
      "!effects": [
        "custom gs_require"
      ]
    },
    requireOnce: {
      "!doc": "Imports a module into the current scope, will skip the import if the module has already been 'require'd.",
      "!type": "fn(shortCode: string)",
      "!effects": [
        "custom gs_require"
      ]
    },
    gs_load: {
      "!doc": "Imports a module into the current scope",
      "!type": "fn(shortCode: string)",
      "!effects": [
        "custom gs_require"
      ]
    },
    Spark: {
      "!doc": 'The Spark object that is available to all scripts is the entry point into the GameSparks API.<br/>It can be used for getting access to objects and functions within the GameSparks platform.<br/>This interface is available in all scripts using the notation "Spark."<br/>e.g.<br/>To return a JSON representation of the Object being acted upon<br/>var data = Spark.getData();<br/>',
      getPlayer: {
        "!doc": '<b>validity</b> All except Global Message Scripts<br/>Returns a SparkPlayer object that represents the player who either sent, or is going to receive the object that is invoking this script.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var player = Spark.getPlayer();</pre><br/>',
        "!type": "fn() -> SparkPlayer"
      },
      loadPlayer: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a SparkPlayer object that represents the player that has the supplied GameSparks player ID.<br/><b>params</b><br/>playerId - the unique player identifier.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var player = Spark.loadPlayer(myplayerid);</pre><br/>',
        "!type": "fn(playerId: string) -> SparkPlayer"
      },
      loadPlayerByExternalId: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a SparkPlayer object that represents the player that in the supplied external system has the supplied external ID.<br/><b>params</b><br/>externalSystem - the unique external system identifier, supplied as a two letter ID. The options are: {FACEBOOK:FB, AMAZON:AM, GAME_CENTER:GC<br/>GOOGLE_PLAY:GY , GOOGLE_PLUS:GP, KONGREGATE:KO, PSN:PS, QQ:QQ, STEAM:ST, TWITCH:TC, TWITTER:TW, VIBER:VB, WECHAT:WC, XBOX:XB<br/>XBOXONE:X1, NINTENDO:NX}<br/>externalId - the player identifier in the external system.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var player = Spark.loadPlayerByExternalId("FB",myplayerexternalid);</pre><br/>',
        "!type": "fn(externalSystem: string, externalId: string) -> SparkPlayer"
      },
      getChallenge: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a SparkChallenge object by it\'s ID.<br/>This is mainly used on LogChallengeEventRequests where the ID of the SparkChallenge can be retrieved using Spark.data.challengeId.<br/><b>params</b><br/>challengeInstanceId - the unique challenge identifier.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var myChallenge = Spark.getChallenge(Spark.data.challengeId);</pre><br/>',
        "!type": "fn(challengeInstanceId: string) -> SparkChallenge"
      },
      sendMessage: {
        "!doc": '<b>DEPRECATED use Spark.message(extCode)</b><br/><b>validity</b> All Scripts<br/>Sends a ScriptMessage to one or more spark Players.<br/>The \'data\' attribute of the SparkMessage will match the data parameter supplied.<br/><b>params</b><br/>data - the JSON Data to send.<br/>players - the SparkPlayer array to send the message to.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendMessage({"alert" : "You\'ve just won a car!"}, myplayers);</pre><br/>',
        "!type": "fn(data: ?, players: [SparkPlayer])"
      },
      sendMessageExt: {
        "!doc": '<b>DEPRECATED use Spark.message(extCode)</b><br/><b>validity</b> All Scripts<br/>Sends a ScriptMessage to one or more spark Players.<br/>The \'data\' attribute of the SparkMessage will match the data parameter supplied.<br/>The extCode parameter will be used to look up the configuration for the message from ScriptMessage Extensions<br/><b>params</b><br/>data - the JSON Data to send.<br/>extCode - The short code of the ScriptMessage extension, if not found, the default ScriptMessage will be used.<br/>players - the SparkPlayer array to send the message to. If empty or null no message will be sent.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendMessageExt({"alert" : "You\'ve just won a car!"},"CODE1" ,myplayers);</pre><br/>',
        "!type": "fn(data: ?, extCode: string, players: [SparkPlayer])"
      },
      sendMessageWithoutPush: {
        "!doc": '<b>DEPRECATED use Spark.message(extCode)</b><br/><b>validity</b> All Scripts<br/>Sends a ScriptMessage to one or more spark Players. Push notifications will be supressed for this message<br/>The \'data\' attribute of the SparkMessage will match the data parameter supplied.<br/><b>params</b><br/>data - the JSON Data to send.<br/>players - the SparkPlayer array to send the message to.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendMessage({"alert" : "You\'ve just won a car!"}, myplayers);</pre><br/>',
        "!type": "fn(data: ?, players: [SparkPlayer])"
      },
      sendMessageById: {
        "!doc": '<b>DEPRECATED use Spark.message(extCode)</b><br/><b>validity</b> All Scripts<br/>Sends a ScriptMessage to one or more spark Players.<br/>The \'data\' attribute of the SparkMessage will match the data parameter supplied.<br/><b>params</b><br/>data - the JSON Data to send.<br/>playerIds - An array of player id strings to send the message to.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendMessage({"alert" : "You\'ve just won a car!"}, myplayerids);</pre><br/>',
        "!type": "fn(data: ?, playerIds: [string])"
      },
      sendMessageByIdExt: {
        "!doc": '<b>DEPRECATED use Spark.message(extCode)</b><br/><b>validity</b> All Scripts<br/>Sends a ScriptMessage to one or more spark Players.<br/>The \'data\' attribute of the SparkMessage will match the data parameter supplied.<br/>The extCode parameter will be used to look up the configuration for the message from ScriptMessage Extensions<br/><b>params</b><br/>data - the JSON Data to send.<br/>extCode - The short code of the ScriptMessage extension, if not found, the default ScriptMessage will be used.<br/>playerIds - An array of player id strings to send the message to.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendMessage({"alert" : "You\'ve just won a car!"}, myplayerids);</pre><br/>',
        "!type": "fn(data: ?, extCode: string, playerIds: [string])"
      },
      sendMessageByIdWithoutPush: {
        "!doc": '<b>DEPRECATED use Spark.message(extCode)</b><br/><b>validity</b> All Scripts<br/>Sends a ScriptMessage to one or more spark Players.<br/>The \'data\' attribute of the SparkMessage will match the data parameter supplied. Push notifications will be supressed for this message<br/><b>params</b><br/>data - the JSON Data to send.<br/>playerIds - An array of player id strings to send the message to.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendMessage({"alert" : "You\'ve just won a car!"}, myplayerids);</pre><br/>',
        "!type": "fn(data: ?, playerIds: [string])"
      },
      message: {
        "!doc": '<b>validity</b> All Scripts<br/>Creates a SparkMessage object using the default configuration from the portal.<br/>Providing an ext code allows different configurations to be used as th template.<br/><b>params</b><br/>extCode - (Optional) The extCode of a scriptMessageExtension, if null or not found the standard ScriptMessage configuration will be used.<br/><b>returns</b><br/>a SparkMessageobject<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.message("myExtCode"));</pre><br/>',
        "!type": "fn(extCode: string) -> SparkMessage"
      },
      save: {
        "!doc": '<b>validity</b> All Scripts<br/>Saves a document to the named collection.<br/><b>params</b><br/>collectionName - the collection name to save the document to.<br/>document - the document to save. If the document contains and _id field, and the collection already contains a document with the same _id it will be updated.<br/><b>returns</b><br/>true if the save was successful, false if there was an error<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.save("myCollection", {"key":"value"});</pre><br/>',
        "!type": "fn(collectionName: string, document: ?) -> bool"
      },
      remove: {
        "!doc": '<b>validity</b> All Scripts<br/>Removes a document or documents from the named collection based on the query.<br/><b>params</b><br/>collectionName - the collection name to remove the document from.<br/>query - the query that determines what documents to remove<br/><b>returns</b><br/>true if the save was successful, false if there was an error<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.remove("myCollection", {"key":"value"});</pre><br/>',
        "!type": "fn(collectionName: string, query: ?) -> bool"
      },
      find: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a query on the named collection using find (without a projection).<br/>http://docs.mongodb.org/manual/reference/method/db.collection.find<br/><b>params</b><br/>collectionName - the collection to query<br/>query - the mongo query. For details see http://docs.mongodb.org/manual/core/read-operations/<br/><b>returns</b><br/>The result of the query, can be a simple document or a list<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.find("myCollection", {"key":"value"});</pre><br/>',
        "!type": "fn(collectionName: string, query: ?) -> ?"
      },
      find_14: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a query on the named collection using find (with a projection)<br/>http://docs.mongodb.org/manual/reference/method/db.collection.find<br/><b>params</b><br/>collectionName - the collection to query<br/>query - the mongo query. For details see http://docs.mongodb.org/manual/core/read-operations/<br/>projection - the projection,<br/><b>returns</b><br/>The result of the query, can be a simple document or a list<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.find("myCollection", {"key":"value"}, {"projectionKey":"projectionValue"});</pre><br/>',
        "!type": "fn(collectionName: string, query: ?, projection: ?) -> ?"
      },
      lock: {
        "!doc": '<b>validity</b> All Scripts<br/>Locks a challenge for writing. Whilst the script \'owns\' this lock no other script can modify the challenge<br/>Useful for situations where there may be concurrent access required to a SparkChallengeObject.<br/>Other scripts can continue to read the Challenge<br/>If a Script gains a lock to the object, it will be released once the release method is called, or if the release method is not called, when the script terminates.<br/><b>params</b><br/>challenge - the challenge to lock<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.lock(mychallenge);</pre><br/>',
        "!type": "fn(challenge: SparkChallenge)"
      },
      unlock: {
        "!doc": '<b>validity</b> All Scripts<br/>Unlocks the challenge.<br/>This makes it available for other scripts to acquire a lock on it.<br/><b>params</b><br/>challenge - the challenge to unlock<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.unlock(mychallenge);</pre><br/>',
        "!type": "fn(challenge: SparkChallenge)"
      },
      lockKey: {
        "!doc": '<b>validity</b> All Scripts<br/>Creates a lock on an arbitrary key. Whilst the script \'owns\' this lock no other script can lock on the same key, and will be blocked until the lock is released.<br/>Useful for situations where there may be concurrent access required to an object or data.<br/>Locks are reentrant and recursive, i.e. if you lock the same key twice, you will need to call unlockKey() twice to completely release the lock.<br/>Alternatively, an unlockKeyFully() call will release the lock regardless of how many times it has been locked by this thread.<br/>Locks will always be released fully when the script terminates.<br/><b>params</b><br/>lockKey - a unique identifier for the lock<br/>tryMillis - if another thread has the lock, how long to block and attempt to acquire the lock before giving up<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var gotLock = Spark.lockKey(lockName, 0);</pre><br/><b>returns</b><br/>true if the lock was acquired, false otherwise<br/>',
        "!type": "fn(lockName: string, tryMillis: number) -> bool"
      },
      unlockKey: {
        "!doc": '<b>validity</b> All Scripts<br/>Releases a lock on the given key, assuming it is held by this thread.<br/>This makes it available for other scripts to acquire a lock on it.<br/>Note that locks are recursive, i.e. if you have locked twice on this key, you must unlock twice before other scripts can gain this lock.<br/><b>params</b><br/>lockKey - the key that was previously locked<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.unlock(lockName);</pre><br/><b>returns</b><br/>true if the lock was released, false otherwise<br/>',
        "!type": "fn(lockName: string) -> bool"
      },
      unlockKeyFully: {
        "!doc": '<b>validity</b> All Scripts<br/>Fully releases all locks on the given key, assuming they are held by this thread.<br/>This makes it immediately available for other scripts to acquire a lock on it, regardless of how many times you have locked it previously.<br/><b>params</b><br/>lockKey - the key that was previously locked<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.unlockKeyFully(lockName);</pre><br/><b>returns</b><br/>true if the lock was released, false otherwise<br/>',
        "!type": "fn(lockName: string) -> bool"
      },
      hasScriptErrors: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows the script to detect if there have been any script errors set during the request or response.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var hasErrors = Spark.hasScriptErrors();</pre><br/>',
        "!type": "fn() -> bool"
      },
      setScriptError: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows an error to be added to either the request or a response being acted upon.<br/>In the case of requests this will cause the request to be rejected. This is useful if you have some custom logic that needs to determine whether GameSparks should process the request.<br/>The \'error\' object of the Response or Message objects will contain an entry that matches the supplied parameters.<br/><b>params</b><br/>key - the key to the data<br/>value - the data, can be either complex JSON or simple types<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.setScriptError("myerrorkey", {"test":12345});</pre><br/>',
        "!type": "fn(key: string, value: ?)"
      },
      getScriptError: {
        "!doc": 'Gets the value of the script error for the given key.  In the case of response scripts this may have been set in the request.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var error = Spark.getScriptError("name");</pre><br/>',
        "!type": "fn(key: string) -> ?"
      },
      removeScriptError: {
        "!doc": 'Removes a value from a name value pair structure containing any script errors that have previously been set.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.removeScriptError("name");</pre><br/>',
        "!type": "fn(key: string)"
      },
      removeAllScriptErrors: {
        "!doc": 'Removes all script errors that have been set<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.removeAllScriptErrors();</pre><br/>',
        "!type": "fn()"
      },
      getLog: {
        "!doc": '<b>validity</b> All Scripts<br/>Provides access to a SparkLog interface<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var logger = Spark.getLog();</pre><br/>',
        "!type": "fn() -> SparkLog"
      },
      getPlayerIds: {
        "!doc": '<b>validity</b>Global Message Scripts<br/>Messages are targeted to multiple players.<br/>This method gives access to the ID\'s of all the target players.<br/>This can be accessed in both Global Message Scripts and User Message Scripts<br/>The ID\'s can in turn be used with getPlayer to access the player details<br/><b>returns</b><br/> An array of Id\'s<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var playerIds = Spark.getPlayerIds();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      logEvent: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to post a LogEventRequest on behalf of the current player.<br/>Can be useful to post a score to a global leaderboard when a score has been posted to a challenge.<br/><b>params</b><br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.logEvent("HS", {"HS":234});</pre><br/>',
        "!type": "fn(eventKey: string, values: ?)"
      },
      getHttp: {
        "!doc": '<b>validity</b> All Scripts<br/>Provides access to a SparkHttp interface<br/><b>params</b><br/>url - the URL of the service to connect to<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var httpSender = Spark.getHttp();</pre><br/>',
        "!type": "fn(url: string) -> SparkHttp"
      },
      dismissMessage: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to dismiss a given message. <br/>Returns true if a message was dismissed. This method does not check if the message belongs to the current user.<br/><b>params</b><br/>messageId - the id of the message to dismiss<br/><b>returns</b><br/>true if the message was dismissed<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.dismissMessage("528b3411e4b09c9ee8497949");</pre><br/>',
        "!type": "fn(messageId: string) -> bool"
      },
      runtimeCollection: {
        "!doc": '<b>validity</b> All Scripts<br/>Gets a runtime collection by name, this collection has bot read and write access and can be interacted with using SparkMongoCollectionReadOnly and SparkMongoCollectionReadWrite methods.<br/><b>params</b><br/>collectionName - the name of the collection you wish to access<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var myRuntimeCollection = Spark.runtimeCollection("runtimetest");</pre><br/>',
        "!type": "fn(collectionName: string) -> SparkMongoCollectionReadWrite"
      },
      metaCollection: {
        "!doc": '<b>validity</b> All Scripts<br/>Gets a metadata collection by name, this collection is read only and can be queried using the methods defined in the SparkMongoCollectionReadOnly object.<br/><b>params</b><br/>collectionName - the name of the collection you wish to access<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var myMetaCollection = Spark.metaCollection("metatest");</pre><br/>',
        "!type": "fn(collectionName: string) -> SparkMongoCollectionReadOnly"
      },
      getFiles: {
        "!doc": '<b>validity</b> All Scripts<br/>Provides access to file operations via a SparkFiles interface<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var files = Spark.getFiles();</pre><br/>',
        "!type": "fn() -> SparkFiles"
      },
      uploadedXml: {
        "!doc": '<b>DEPRECATED use Spark.getFiles().uploadedXml(uploadId)</b><br/><b>validity</b> All Scripts<br/>Provides access to an uploaded file via a SparkXmlReader interface<br/><b>params</b><br/>uploadId - the id of the uploaded file<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.uploadedXml("myUploadId");</pre><br/>',
        "!type": "fn(uploadId: string) -> SparkXmlReader"
      },
      uploadedJson: {
        "!doc": '<b>DEPRECATED use Spark.getFiles().uploadedJson(uploadId)</b><br/><b>validity</b> All Scripts<br/>Provides access to an uploaded file via a JSON object<br/><b>params</b><br/>uploadId - the id of the uploaded file<br/><b>returns</b><br/>A JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.uploadedJson("myUploadId");</pre><br/>',
        "!type": "fn(uploadId: string) -> ?"
      },
      downloadableXml: {
        "!doc": '<b>DEPRECATED use Spark.getFiles().downloadableXml(shortCode)</b><br/><b>validity</b> All Scripts<br/>Provides access to a downloadable file via a SparkXmlReader interface<br/><b>params</b><br/>shortCode - the short code for the downloadable file<br/><b>returns</b><br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.downloadableXml("shortCode");</pre><br/>',
        "!type": "fn(shortCode: string) -> SparkXmlReader"
      },
      downloadableJson: {
        "!doc": '<b>DEPRECATED use Spark.getFiles().downloadableJson(shortCode)</b><br/><b>validity</b> All Scripts<br/>Provides access to a downloadable file via a JSON object<br/><b>params</b><br/>shortCode - the short code for the downloadable file<br/><b>returns</b><br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.downloadableJson("shortCode");</pre><br/>',
        "!type": "fn(shortCode: string) -> ?"
      },
      sendGrid: {
        "!doc": '<b>validity</b> All Scripts<br/>Send an email via the SendGrid email delivery provider<br/><b>params</b><br/>username - your SendGrid accounet username<br/>password - your SendGrid account password<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendGrid(username, password);</pre><br/>',
        "!type": "fn(username: string, password: string) -> SendGrid"
      },
      getScheduler: {
        "!doc": '<b>validity</b> All Scripts<br/>Utility to schedule execution of a module in the future<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getScheduler();</pre><br/>',
        "!type": "fn() -> SparkScheduler"
      },
      getCache: {
        "!doc": '<b>validity</b> All Scripts<br/>Utility to cache complex objects in memory<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getCache();</pre><br/>',
        "!type": "fn() -> SparkCache"
      },
      sendRequest: {
        "!doc": '<b>validity</b> All Scripts<br/>Sends a Request to the platform, this mimics the process a client uses to send requests<br/>The request is sent as the current player, if there is no current player the method will fail.<br/><b>Cloud code attached to the request/response will not be executed.</b> Use the SparkRequests API if cloud code execution is required.<br/>returns - The response as would be returned to the client<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendRequest({"@class": ".LogEventRequest", "eventKey": "SOT", "SC": "1000"});</pre><br/>',
        "!type": "fn(request: ?) -> ?"
      },
      sendRequestAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Sends a Request to the platform, this mimics the process a client uses to send requests<br/>The request is sent as the player identified by playerId, if there playerId is invalid the requst will fail.<br/><b>Cloud code attached to the request/response will not be executed.</b> Use the SparkRequests API if cloud code execution is required.<br/>returns - The response as would be returned to the client<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.sendRequestAs({"@class": ".LogEventRequest", "eventKey": "SOT", "SC": "1000"}, "1234567890");</pre><br/>',
        "!type": "fn(request: ?, playerId: string) -> ?"
      },
      getRedis: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a reference to a SparkRedis object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getRedis();</pre><br/>',
        "!type": "fn() -> SparkRedis"
      },
      getLeaderboards: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a reference to a SparkLeaderboards object, used to access the leaderboards for this game.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLeaderboards();</pre><br/>',
        "!type": "fn() -> SparkLeaderboards"
      },
      getClientIp: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns the client IP address of the current websocket connection (if any).<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var ip = Spark.getClientIp();</pre><br/>',
        "!type": "fn() -> string"
      },
      getConfig: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns configuration information about the currently published game.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var myGameConfig = Spark.getConfig();</pre><br/>',
        "!type": "fn() -> SparkConfig"
      },
      getSparkScriptOptions: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a configuration object for cloud-code scripts.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var options = Spark.getSparkScriptOptions();</pre><br/>',
        "!type": "fn() -> SparkScriptOptions"
      },
      getTeams: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a reference to a SparkTeams object, used to access the teams for this game.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getTeams();</pre><br/>',
        "!type": "fn() -> SparkTeams"
      },
      getMultiplayer: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a reference to a SparkMultiplayer object, used to access the platform\'s multiplayer capabilities.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getMultiplayer();</pre><br/>',
        "!type": "fn() -> SparkMultiplayer"
      },
      getProperties: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a reference to a SparkProperties object, used to access the Properties and Property Sets configured against a game.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getProperties();</pre><br/>',
        "!type": "fn() -> SparkProperties"
      },
      getBulkScheduler: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a reference to a SparkBulkScheduler object, used to perform operations on multiple players at once.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getBulkScheduler();</pre><br/>',
        "!type": "fn() -> SparkBulkScheduler"
      },
      getDigester: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a reference to a SparkDigest object.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getDigester();</pre><br/>',
        "!type": "fn() -> SparkDigest"
      },
      getCredentialType: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns the type of the credential used for the current connection (if any).<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var credentialType = Spark.getCredentialType();</pre><br/>',
        "!type": "fn() -> string"
      },
      getSessionId: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns the session ID of the current player (if any).<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var sessionId = Spark.getSessionId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getUploadableUtils: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns a utility class to enable uploading and retrieval of uploadables from cloud code.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var util = Spark.getUploadableUtils();</pre><br/>',
        "!type": "fn() -> SparkUploadableUtils"
      },
      exit: {
        "!doc": 'Terminates execution of the current script<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.exit();</pre><br/>',
        "!type": "fn()"
      },
      getScriptData: {
        "!doc": 'Gets the value from a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var value = Spark.getPlayer().getScriptData("name");</pre><br/>',
        "!type": "fn(name: string) -> ?"
      },
      setScriptData: {
        "!doc": 'Allows arbitrary data to be added to the object being acted upon.<br/>Sets a value into a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/>The data is visible to the client<br/>This data is sent to the player(s) in the \'scriptData\' attribute of the Request, Response or Message object.<br/>When scriptData is set to a request, it gets set against the response that will be returned to the player. This allows basic communication between request and response scripts.<br/><b>params</b><br/>name - The name in the name value pair<br/>value - The value to set in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().setScriptData("name", "value");</pre><br/>',
        "!type": "fn(name: string, value: ?)"
      },
      removeScriptData: {
        "!doc": 'Removes a value from a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().removeScriptData("name");</pre><br/>',
        "!type": "fn(name: string)"
      },
      removeAllScriptData: {
        "!doc": 'Removes all script data that has been set<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.removeAllScriptData();</pre><br/>',
        "!type": "fn()"
      },
      getRemainingMilliseconds: {
        "!doc": "Gets the number of milliseconds this script has left to run before a longRunningScriptError is thrown<br/>",
        "!type": "fn() -> number"
      },
      getData: {
        "!doc": '<b>validity</b> All Scripts<br/>A JSON version of the object being scripted. Can be either a Request, Response or Message.<br/>The structure of the JSON is as the Client either receives or sends it. Attributes can be read, but not changed<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var userName = Spark.getData().userName;</pre><br/>',
        "!type": "fn() -> ?"
      }
    },
    SparkLeaderboardCursor: {
      "!doc": "A cursor over entries within a leaderboard.<br/>e.g.<br/>var leaderboard = Spark.getLeaderboards().getLeaderboard(shortCode).getEntries();<br/>",
      hasNext: {
        "!doc": 'Returns true if there are more entries available.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var hasNext = cursor.hasNext();</pre><br/>',
        "!type": "fn() -> bool"
      },
      next: {
        "!doc": 'Returns the entry the cursor is at and moves the cursor ahead by one.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var entry = cursor.next();</pre><br/>',
        "!type": "fn() -> SparkLeaderboardEntry"
      }
    },
    SparkLeaderboardEntry: {
      "!doc": "An entry within a leaderboard.<br/>e.g.<br/>var entry = leaderboard.getEntries().next();<br/>",
      getUserId: {
        "!doc": 'Returns the playerId of the player whose entry in the leaderboard this is.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var playerId = entry.getUserId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getUserName: {
        "!doc": 'Returns the displayName of the player whose entry in the leaderboard this is.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var displayName = entry.getUserName();</pre><br/>',
        "!type": "fn() -> string"
      },
      getRank: {
        "!doc": 'Returns the position of this entry within the leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var rank = entry.getRank();</pre><br/>',
        "!type": "fn() -> number"
      },
      getRankPercentage: {
        "!doc": 'Returns the rank of the player as a percentage of total entries.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var rankPercentage = entry.getRankPercentage();</pre><br/>',
        "!type": "fn() -> number"
      },
      getWhen: {
        "!doc": 'Returns a String representing the time this entry was recorded, in the format yyyy-MM-dd\'T\'HH:mm\'Z\'.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var when = entry.getWhen();</pre><br/>',
        "!type": "fn() -> string"
      },
      getAttribute: {
        "!doc": 'Returns the attribute <b>name</b> from this leaderboard entry.  Use this to get custom attributes from this entry.<br/><b>params</b><br/>name - the name of the attribute to be returned<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var score = entry.getAttribute("SCORE");</pre><br/>',
        "!type": "fn(name: string) -> ?"
      }
    },
    SparkPlayer: {
      "!doc": "Provides access to a player details<br/>e.g.<br/>var player = Spark.getPlayer();<br/>or<br/>var player = Spark.loadPlayer(myplayerid);<br/>",
      getAllBalances: {
        "!doc": 'Returns a map of the player\'s balance for each currency type.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var allBalances = Spark.getPlayer().getAllCurrencies();</pre><br/>',
        "!type": "fn() -> ?"
      },
      getDisplayName: {
        "!doc": 'Gets the display name of the player.<br/>This may be null for a player who has only used device authentication. Other authentication mechanisms will return a value.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var displayName = Spark.getPlayer().getDisplayName();</pre><br/>',
        "!type": "fn() -> string"
      },
      getUserName: {
        "!doc": 'Gets the username name of the player.<br/>For a player who has only used device authentication this value will be generated from the device id.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var userName = Spark.getPlayer().getUserName();</pre><br/>',
        "!type": "fn() -> string"
      },
      getPlayerId: {
        "!doc": 'Gets the GameSparks ID of the player<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var playerId = Spark.getPlayer().getPlayerId();</pre><br/>',
        "!type": "fn() -> string"
      },
      persist: {
        "!doc": 'Saves the players data to the DB. By default, changes are persisted after the script executes. This method ensures changes are saved immediately so other scripts running in parallel see the changes immediately.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().persist();</pre><br/>',
        "!type": "fn()"
      },
      credit1: {
        "!doc": 'Credits the currency1 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit1(20);</pre><br/>',
        "!type": "fn(quantity: number)"
      },
      credit1_6: {
        "!doc": 'Credits the currency1 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/>reason - the reason for the credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit1(20, "Loyalty Bonus");</pre><br/>',
        "!type": "fn(quantity: number, reason: string)"
      },
      debit1: {
        "!doc": 'Debits the currency1 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to debit<br/>reason - the reason for the debit<br/><b>returns</b><br/> true if the debit was successful, false if the current balance was not sufficient<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit1(5, "Loser Penalty");</pre><br/>',
        "!type": "fn(quantity: number, reason: string) -> bool"
      },
      debit1_8: {
        "!doc": 'Debits the currency1 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to debit<br/><b>returns</b><br/> true if the debit was successful, false if the current balance was not sufficient<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit1(5);</pre><br/>',
        "!type": "fn(quantity: number) -> bool"
      },
      credit2: {
        "!doc": 'Credits the currency2 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/>reason - the reason for the credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit2(20, "Loyalty Bonus");</pre><br/>',
        "!type": "fn(quantity: number, reason: string)"
      },
      credit2_10: {
        "!doc": 'Credits the currency2 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit2(20);</pre><br/>',
        "!type": "fn(quantity: number)"
      },
      debit2: {
        "!doc": 'Debits the currency2 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/>reason - the reason for the debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit2(5, "Loser Penalty");</pre><br/>',
        "!type": "fn(quantity: number, reason: string) -> bool"
      },
      debit2_12: {
        "!doc": 'Debits the currency2 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit2(5);</pre><br/>',
        "!type": "fn(quantity: number) -> bool"
      },
      credit3: {
        "!doc": 'Credits the currency3 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/>reason - the reason for the credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit3(20, "Loyalty Bonus");</pre><br/>',
        "!type": "fn(quantity: number, reason: string)"
      },
      credit3_14: {
        "!doc": 'Credits the currency3 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit3(20);</pre><br/>',
        "!type": "fn(quantity: number)"
      },
      debit3: {
        "!doc": 'Debits the currency3 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit3(5);</pre><br/>',
        "!type": "fn(quantity: number) -> bool"
      },
      debit3_16: {
        "!doc": 'Debits the currency3 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/>reason - the reason for the debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit3(5, "Loser Penalty");</pre><br/>',
        "!type": "fn(quantity: number, reason: string) -> bool"
      },
      credit4: {
        "!doc": 'Credits the currency4 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit4(20);</pre><br/>',
        "!type": "fn(quantity: number)"
      },
      credit4_18: {
        "!doc": 'Credits the currency4 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/>reason - the reason for the credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit4(20, "Loyalty Bonus");</pre><br/>',
        "!type": "fn(quantity: number, reason: string)"
      },
      debit4: {
        "!doc": 'Debits the currency4 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit4(5);</pre><br/>',
        "!type": "fn(quantity: number) -> bool"
      },
      debit4_20: {
        "!doc": 'Debits the currency4 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/>reason - the reason for the debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit4(5, "Loser Penalty");</pre><br/>',
        "!type": "fn(quantity: number, reason: string) -> bool"
      },
      credit5: {
        "!doc": 'Credits the currency5 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/>reason - the reason for the credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit5(20, "Loyalty Bonus");</pre><br/>',
        "!type": "fn(quantity: number, reason: string)"
      },
      credit5_22: {
        "!doc": 'Credits the currency5 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit5(20);</pre><br/>',
        "!type": "fn(quantity: number)"
      },
      debit5: {
        "!doc": 'Debits the currency5 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/>reason - the reason for the debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit5(5, "Loser Penalty");</pre><br/>',
        "!type": "fn(quantity: number, reason: string) -> bool"
      },
      debit5_24: {
        "!doc": 'Debits the currency5 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit5(5);</pre><br/>',
        "!type": "fn(quantity: number) -> bool"
      },
      credit6: {
        "!doc": 'Credits the currency6 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/>reason - the reason for the credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit6(20, "Loyalty Bonus");</pre><br/>',
        "!type": "fn(quantity: number, reason: string)"
      },
      credit6_26: {
        "!doc": 'Credits the currency6 balance of the player with the amount specified.<br/><b>params</b><br/>quantity - the amount to credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit6(20);</pre><br/>',
        "!type": "fn(quantity: number)"
      },
      debit6: {
        "!doc": 'Debits the currency6 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit6(5);</pre><br/>',
        "!type": "fn(quantity: number) -> bool"
      },
      debit6_28: {
        "!doc": 'Debits the currency6 balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>quantity - the amount to debit<br/>reason - the reason for the debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit6(5, "Loser Penalty");</pre><br/>',
        "!type": "fn(quantity: number, reason: string) -> bool"
      },
      getBalance1: {
        "!doc": 'Gets the currency1 balance of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var bal = Spark.getPlayer().getBalance1();</pre><br/>',
        "!type": "fn() -> number"
      },
      debit: {
        "!doc": 'Debits the named currency balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>shortCode - the shortCode of the named currency to debit<br/>quantity - the amount to debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit("GOLD", 5);</pre><br/>',
        "!type": "fn(shortCode: string, quantity: number) -> bool"
      },
      debit_31: {
        "!doc": 'Debits the named currency balance of the player with the amount specified.<br/>Returns true if the debit was successful, false if the current balance was not sufficient.<br/><b>params</b><br/>shortCode - the shortCode of the named currency to debit<br/>quantity - the amount to debit<br/>reason - the reason for the debit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().debit("GOLD", 5, "Loser Penalty");</pre><br/>',
        "!type": "fn(shortCode: string, quantity: number, reason: string) -> bool"
      },
      getBalance2: {
        "!doc": 'Gets the currency2 balance of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var bal = Spark.getPlayer().getBalance2();</pre><br/>',
        "!type": "fn() -> number"
      },
      credit: {
        "!doc": 'Credits the named currency balance of the player with the amount specified.<br/><b>params</b><br/>shortCode - the short code of the named currency to credit<br/>quantity - the amount to credit<br/>reason - the reason for the credit<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().credit("GOLD", 20, "Loyalty Bonus");</pre><br/>',
        "!type": "fn(shortCode: string, quantity: number, reason: string)"
      },
      getBalance3: {
        "!doc": 'Gets the currency3 balance of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var bal = Spark.getPlayer().getBalance3();</pre><br/>',
        "!type": "fn() -> number"
      },
      getBalance4: {
        "!doc": 'Gets the currency4 balance of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var bal = Spark.getPlayer().getBalance4();</pre><br/>',
        "!type": "fn() -> number"
      },
      getBalance5: {
        "!doc": 'Gets the currency5 balance of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var bal = Spark.getPlayer().getBalance5();</pre><br/>',
        "!type": "fn() -> number"
      },
      getBalance6: {
        "!doc": 'Gets the currency6 balance of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var bal = Spark.getPlayer().getBalance6();</pre><br/>',
        "!type": "fn() -> number"
      },
      getBalance: {
        "!doc": 'Gets the player\'s balance for the specified currency.<br/><b>params</b><br/>shortCode - The short code of the named currency to get the player\'s balance for.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var bal = Spark.getPlayer().getBalance("GOLD");</pre><br/>',
        "!type": "fn(shortCode: string) -> number"
      },
      addVGood: {
        "!doc": 'Finds a virtual good by short code and adds the quantity specified to the player this SparkPlayer object represents.<br/>Returns true if the add was successful. false if the shortcode does not exist, or the user already has the maximum amount of the specified good.<br/><b>params</b><br/>shortCode - the virtual good\'s short code<br/>quantity - the amount to add<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var goodsAdded = Spark.getPlayer().addVGood(vgShortCode, 42);</pre><br/>',
        "!type": "fn(shortCode: string, quantity: number) -> bool"
      },
      addVGood_41: {
        "!doc": 'Finds a virtual good by short code and adds the quantity specified to the player this SparkPlayer object represents.<br/>Returns true if the add was successful. false if the shortcode does not exist, or the user already has the maximum amount of the specified good.<br/><b>params</b><br/>shortCode - the virtual good\'s short code<br/>quantity - the amount to add<br/>reason - the reason for adding the virtual good<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var goodsAdded = Spark.getPlayer().addVGood(vgShortCode, 42, "Loyalty bonus");</pre><br/>',
        "!type": "fn(shortCode: string, quantity: number, reason: string) -> bool"
      },
      useVGood: {
        "!doc": 'Removes a quantity of virtual goods from the player.<br/>Returns true if the player had enough of the virtual good specified by short code. If the method returns false, no modification is made.<br/><b>params</b><br/>shortCode - the virtual good\'s short code<br/>quantity - the amount to consume<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var goodsUsed = Spark.getPlayer().useVGood(vgShortCode, 34);</pre><br/>',
        "!type": "fn(shortCode: string, quantity: number) -> bool"
      },
      useVGood_43: {
        "!doc": 'Removes a quantity of virtual goods from the player.<br/>Returns true if the player had enough of the virtual good specified by short code. If the method returns false, no modification is made.<br/><b>params</b><br/>shortCode - the virtual good\'s short code<br/>quantity - the amount to consume<br/>reason - the reason for using the virtual good<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var goodsUsed = Spark.getPlayer().useVGood(vgShortCode, 34, "Loser penalty");</pre><br/>',
        "!type": "fn(shortCode: string, quantity: number, reason: string) -> bool"
      },
      hasVGood: {
        "!doc": 'Determines whether the player has a particular virtual good.<br/>Returns the quantity of the virtual good the player has.<br/><b>params</b><br/>shortCode - the virtual good\'s short code<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var hasGood = Spark.getPlayer().hasVGood(vgShortCode);</pre><br/>',
        "!type": "fn(shortCode: string) -> number"
      },
      addAchievement: {
        "!doc": 'Adds an achievement to the player this SparkPlayer object represents.<br/>The player will be given any award that is configured against the award in the developer portal.<br/>Returns true if the achievement was added. false if the player already had the achievement, or the shortCode does not exist<br/><b>params</b><br/>shortCode - The shortCode of the achievement<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var achievementAdded = Spark.getPlayer().addAchievement(shortCode);</pre><br/>',
        "!type": "fn(shortCode: string) -> bool"
      },
      removeAchievement: {
        "!doc": 'Removes an achievement from the player.<br/>Returns true if the achievement was removed. false if player did not have the achievement.<br/>Returns false if the player did not have the achievement.<br/><b>params</b><br/>shortCode the shortCode of the achievement to remove<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var achievementRemoved = Spark.getPlayer().removeAchievement(shortCode);</pre><br/>',
        "!type": "fn(shortCode: string) -> bool"
      },
      hasAchievement: {
        "!doc": 'Determines whether the player has a particular achievement.<br/>Returns true if the player has the achievement<br/><b>params</b><br/>shortCode - The shortCode of the achievement<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var hasAchievement = Spark.getPlayer().hasAchievement(shortCode);</pre><br/>',
        "!type": "fn(shortCode: string) -> bool"
      },
      dismissMessage: {
        "!doc": 'Allows a script to dismiss a given message that belongs to a player.<br/>Returns true if a message was dismissed.<br/><b>params</b><br/>messageId<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var messageDismissed = Spark.getPlayer().dismissMessage(messageId);</pre><br/>',
        "!type": "fn(messageId: string) -> bool"
      },
      getExternalIds: {
        "!doc": 'Returns a map of external system ids to external ids.<br/>This allows you to determine, for example, the player facebook id.<br/>Map keys: \'FB\' - Indicates the ID is a facebook id<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var externalIds = Spark.getPlayer().getExternalIds();</pre><br/>',
        "!type": "fn() -> ?"
      },
      getFriendIds: {
        "!doc": 'Returns an array of the player\'s social friend ids.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var friends = Spark.getPlayer().getFriendIds();</pre><br/>',
        "!type": "fn() -> ?"
      },
      isOnline: {
        "!doc": 'Returns true if this player is currently has an open WebSocket.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var online = Spark.getPlayer().isOnline();</pre><br/>',
        "!type": "fn() -> bool"
      },
      validatePassword: {
        "!doc": 'Validates the given password against the one stored for this player.<br/><b>params</b><br/>password - the password to validate<br/><b>returns</b><br/>true if the given password matches the one stored for this player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var doesPasswordMatch = Spark.getPlayer().validatePassword(passwordEnteredByPlayer);</pre><br/>',
        "!type": "fn(password: string) -> bool"
      },
      setPassword: {
        "!doc": 'Sets a new password for this player.<br/><b>params</b><br/>password - the password to set<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().setPassword(password);</pre><br/>',
        "!type": "fn(password: string)"
      },
      isHiddenOnLeaderboards: {
        "!doc": 'Boolean value indicating if this player is currently being hidden from leaderboards.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var hidden = Spark.getPlayer().isHidden();</pre><br/>',
        "!type": "fn() -> bool"
      },
      hideOnLeaderboards: {
        "!doc": 'Hide the player from current leaderboards.  Prevents any new scores posted showing up as well.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().hideOnLeaderboards();</pre><br/>',
        "!type": "fn()"
      },
      showOnLeaderboards: {
        "!doc": 'Show the player on current leaderboards, redisplaying any existing scores.  New scores will begin to show up on leaderboards again as they are recorded.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().showOnLeaderboards();</pre><br/>',
        "!type": "fn()"
      },
      getPushRegistrations: {
        "!doc": 'Gets push registrations of the player<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var pushRegistrations = Spark.getPlayer().getPushRegistrations();</pre><br/>',
        "!type": "fn() -> [SparkPushRegistration]"
      },
      removePushRegistration: {
        "!doc": 'Removes the registration with the given id.  The device associated with this registration will no longer receive push notifications for this player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().removePushRegistration(registrationId);</pre><br/>',
        "!type": "fn(id: string)"
      },
      setSegmentValue: {
        "!doc": 'Sets a value for a single segment against the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().setSegmentValue("PROFILE", "P1");</pre><br/>',
        "!type": "fn(segmentType: string, segmentValue: string)"
      },
      getSegmentValue: {
        "!doc": 'Gets a value for a single segment from the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var profileSegmentValue = Spark.getPlayer().getSegmentValue("PROFILE");</pre><br/>',
        "!type": "fn(segmentType: string) -> string"
      },
      getSegments: {
        "!doc": 'Gets all segment values from the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var segments = Spark.getPlayer().getSegments();</pre><br/>',
        "!type": "fn() -> ?"
      },
      disconnect: {
        "!doc": 'Disconnects this player, a SessionTerminatedMessage will be sent to the socket, and the socket will be unauthenticated<br/><b>params</b><br/>excludeCurrent - If the script is running in the context of the user being disconnected, the current socket will not be disconnected<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().disconnect(true);</pre><br/>',
        "!type": "fn(excludeCurrent: bool)"
      },
      getAchievements: {
        "!doc": 'Gets all achievements from this player<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().getAchievements();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      getVirtualGoods: {
        "!doc": 'Gets all virtual goods from the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var goods = Spark.getPlayer().getVirtualGoods();</pre><br/>',
        "!type": "fn() -> ?"
      },
      resetAuthTokens: {
        "!doc": 'Removes all auth tokens for this user, this will force a re-authentication.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().resetAuthTokens();</pre><br/>',
        "!type": "fn()"
      },
      resetAuthTokens_66: {
        "!doc": 'Removes auth tokens for this user, this will force a re-authentication.<br/><b>params</b><br/>excludeCurrent - If the script is running in the context of the user having tokens reset, the current token will not be reset<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().resetAuthTokens(true);</pre><br/>',
        "!type": "fn(excludeCurrent: bool)"
      },
      getLastSeen: {
        "!doc": 'Gets the lastSeen value for the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var lastSeen = Spark.getPlayer().getLastSeen();</pre><br/>',
        "!type": "fn() -> date"
      },
      unlock: {
        "!doc": 'Unlocks the account for this player if it has been locked by too many failed login attempts.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().unlock();</pre><br/>',
        "!type": "fn()"
      },
      getCreationDate: {
        "!doc": 'Gets the creation date of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var creationDate = Spark.getPlayer().getCreationDate();</pre><br/>',
        "!type": "fn() -> date"
      },
      matchesMongoQuery: {
        "!doc": 'Checks if this player would be returned by the given mongo query.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var isMatch = Spark.getPlayer().matchesMongoQuery({});</pre><br/>',
        "!type": "fn(mongoQuery: ScriptableObject) -> bool"
      },
      matchesMongoQueryString: {
        "!doc": 'Checks if this player would be returned by the given mongo query (as a string).<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var isMatch = Spark.getPlayer().matchesMongoQueryString("");</pre><br/>',
        "!type": "fn(mongoQueryString: string) -> bool"
      },
      getExperimentSegments: {
        "!doc": 'Returns the current experiment segments of the player.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var experiments = Spark.getPlayer().getExperimentSegments();</pre><br/>',
        "!type": "fn() -> [SparkPlayerExperimentSegment]"
      },
      removeExperiment: {
        "!doc": 'Removes the player from the given experiment.<br/><b>returns</b><br/> true if the player was part of the experiment, false if the player was not part of the experiment<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var removed = Spark.getPlayer().removeExperiment();</pre><br/>',
        "!type": "fn(experimentId: number) -> bool"
      },
      setExperimentSegment: {
        "!doc": 'Sets the experiment segment for the player.<br/><b>returns</b><br/> true if the experiment segment was added to the player, false if the player already had the experiment segment<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var added = Spark.getPlayer().setExperimentSegment(47, "FireSale");</pre><br/>',
        "!type": "fn(experimentId: number, experimentSegmentName: string) -> bool"
      },
      deletePlayer: {
        "!doc": 'Deletes this player and associated data from system collections.<br/>Note that any data linked to the player in runtime collections is not deleted, since the GameSparks platform has no way of identifying this data automatically.<br/>This deletion is irreversible and should be used with extreme caution.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var userName = Spark.loadPlayer("57f4af757d196627bc79abc9").deletePlayer();</pre><br/>',
        "!type": "fn()"
      },
      getPrivateData: {
        "!doc": 'Gets the value from a name value pair structure that allows custom data to be attached to this object. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var privateData = Spark.getPlayer().getPrivateData("name");</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var privateData = Spark.getChallenge().getPrivateData("name");</pre><br/>',
        "!type": "fn(name: string) -> ?"
      },
      setPrivateData: {
        "!doc": 'Allows arbitrary data to be added to the object being acted upon.<br/>Sets a value into a name value pair structure that allows custom data to be attached to this object. This data can either be complex JSON or simple values.<br/>The data is not visible to the client<br/><b>params</b><br/>name - The name in the name value pair<br/>value - The value to set in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().setPrivateData("name", "value");</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getChallenge().setPrivateData("name", "value");</pre><br/>',
        "!type": "fn(name: string, value: ?)"
      },
      removePrivateData: {
        "!doc": 'Removes a value from a name value pair structure that allows custom data to be attached to this. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().removePrivateData("name");</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getChallenge().removePrivateData("name");</pre><br/>',
        "!type": "fn(name: string)"
      },
      getScriptData: {
        "!doc": 'Gets the value from a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var value = Spark.getPlayer().getScriptData("name");</pre><br/>',
        "!type": "fn(name: string) -> ?"
      },
      setScriptData: {
        "!doc": 'Allows arbitrary data to be added to the object being acted upon.<br/>Sets a value into a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/>The data is visible to the client<br/>This data is sent to the player(s) in the \'scriptData\' attribute of the Request, Response or Message object.<br/>When scriptData is set to a request, it gets set against the response that will be returned to the player. This allows basic communication between request and response scripts.<br/><b>params</b><br/>name - The name in the name value pair<br/>value - The value to set in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().setScriptData("name", "value");</pre><br/>',
        "!type": "fn(name: string, value: ?)"
      },
      removeScriptData: {
        "!doc": 'Removes a value from a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().removeScriptData("name");</pre><br/>',
        "!type": "fn(name: string)"
      }
    },
    SparkChallenge: {
      "!doc": "Provides access to a challenge's details.<br/>e.g.<br/>var challenge = Spark.getChallenge(mychallengeid);<br/>",
      getRunState: {
        "!doc": 'The run state of the object. Valid states are:<br/>ACCEPTED - All players have accepted the challenge<br/>WAITING - The challenge is in it\'s waiting state, between expiryDate and startDate<br/>RUNNING - The challenge is running<br/>COMPLETE - The challenge is complete<br/>DECLINED - All players have declined the challenge<br/>EXPIRED - The expiry time for the challenge has passed before all players have accepted<br/>ISSUED - The challenge has been issued but is waiting for other to accept before play can begin<br/>WITHDRAWN - The challenger has withdrawn the challenge<br/>LAPSED - The end time of this challenge has passed before the challenge was started<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var runState = Spark.getChallenge(mychallengeid).getRunState();</pre><br/>',
        "!type": "fn() -> string"
      },
      getId: {
        "!doc": 'Gets the ID of this challenge.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var id = Spark.getChallenge(mychallengeid).getId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getShortCode: {
        "!doc": 'Returns the shortCode of the challenge<br/>Can be useful when block or code should only run for a particular challenge type.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var shortCode = Spark.getChallenge(mychallengeid).getShortCode();</pre><br/>',
        "!type": "fn() -> string"
      },
      winChallenge: {
        "!doc": 'Complete the challenge and uses the provided SparkPlayer as the winner.<br/>If the supplied SparkPlayer is not part of the challenge this call will be ignored (silently)<br/><b>params</b><br/>winner - the SparkPlayer to set as the winner<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getChallenge(mychallengeid).winChallenge(aPlayer);</pre><br/>',
        "!type": "fn(winner: SparkPlayer)"
      },
      drawChallenge: {
        "!doc": 'Complete the challenge with no winner.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getChallenge(mychallengeid).drawChallenge();</pre><br/>',
        "!type": "fn()"
      },
      startChallenge: {
        "!doc": 'Starts the challenge in the current state. This method only checks that the state is ISSUED or WAITING and that there is at least 2 players in the challenge <br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getChallenge(mychallengeid).startChallenge();</pre><br/>',
        "!type": "fn()"
      },
      getChallengedPlayerIds: {
        "!doc": 'Returns a list of Players ID\'s that can be used to load the player details using Spark.getPlayer(String player)<br/><b>returns</b><br/>The array of player Ids this challenge was issued to<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var players = Spark.getChallenge(mychallengeid).getChallengedPlayerIds();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      getAcceptedPlayerIds: {
        "!doc": 'Returns a list of Players ID\'s that can be used to load the player details using Spark.getPlayer(String player)<br/><b>returns</b><br/>The array of player Ids who have accepted this challenge<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var players = Spark.getChallenge(mychallengeid).getAcceptedPlayerIds();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      getDeclinedPlayerIds: {
        "!doc": 'Returns a list of Players ID\'s that can be used to load the player details using Spark.getPlayer(String player)<br/><b>returns</b><br/>The array of player Ids who have declined this challenge<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var players = Spark.getChallenge(mychallengeid).getDeclinedPlayerIds()</pre><br/>',
        "!type": "fn() -> [string]"
      },
      getChallengerId: {
        "!doc": 'Gets the player id of whoever issued the challenge.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var challengerId = Spark.getChallenge(mychallengeid).getChallengerId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getEndDate: {
        "!doc": 'Gets the end date of the challenge.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var endDate = Spark.getChallenge(mychallengeid).getEndDate();</pre><br/>',
        "!type": "fn() -> date"
      },
      getExpiryDate: {
        "!doc": 'Gets the expiry date of the challenge.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var expiryDate = Spark.getChallenge(mychallengeid).getExpiryDate();</pre><br/>',
        "!type": "fn() -> date"
      },
      getStartDate: {
        "!doc": 'Gets the start date of the challenge.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var startDate = Spark.getChallenge(mychallengeid).getStartDate();</pre><br/>',
        "!type": "fn() -> date"
      },
      consumeTurn: {
        "!doc": 'Takes a turn for a player in a turn based challenge, without sending a ChallengeTurnTaken message.<br/><b>params</b><br/>playerId - the id of the player who has taken their turn<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var challenge = Spark.getChallenge(mychallengeid).consumeTurn(playerId);</pre><br/>',
        "!type": "fn(playerId: string) -> bool"
      },
      takeTurn: {
        "!doc": 'Takes a turn for a player in a turn based challenge, and sends a ChallengeTurnTaken message.<br/><b>params</b><br/>playerId - the id of the player who has taken their turn<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var challenge = Spark.getChallenge(mychallengeid).takeTurn(playerId);</pre><br/>',
        "!type": "fn(playerId: string) -> bool"
      },
      removePlayer: {
        "!doc": 'Removes a player from this challenge.<br/><b>params</b><br/>playerId - the id of the player to remove<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var challenge = Spark.getChallenge(mychallengeid).removePlayer(playerId);</pre><br/>',
        "!type": "fn(playerId: string) -> bool"
      },
      getChallengeName: {
        "!doc": "Gets the challenge name<br/>",
        "!type": "fn() -> string"
      },
      getPrivateData: {
        "!doc": 'Gets the value from a name value pair structure that allows custom data to be attached to this object. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var privateData = Spark.getPlayer().getPrivateData("name");</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var privateData = Spark.getChallenge().getPrivateData("name");</pre><br/>',
        "!type": "fn(name: string) -> ?"
      },
      setPrivateData: {
        "!doc": 'Allows arbitrary data to be added to the object being acted upon.<br/>Sets a value into a name value pair structure that allows custom data to be attached to this object. This data can either be complex JSON or simple values.<br/>The data is not visible to the client<br/><b>params</b><br/>name - The name in the name value pair<br/>value - The value to set in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().setPrivateData("name", "value");</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getChallenge().setPrivateData("name", "value");</pre><br/>',
        "!type": "fn(name: string, value: ?)"
      },
      removePrivateData: {
        "!doc": 'Removes a value from a name value pair structure that allows custom data to be attached to this. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().removePrivateData("name");</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getChallenge().removePrivateData("name");</pre><br/>',
        "!type": "fn(name: string)"
      },
      getScriptData: {
        "!doc": 'Gets the value from a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var value = Spark.getPlayer().getScriptData("name");</pre><br/>',
        "!type": "fn(name: string) -> ?"
      },
      setScriptData: {
        "!doc": 'Allows arbitrary data to be added to the object being acted upon.<br/>Sets a value into a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/>The data is visible to the client<br/>This data is sent to the player(s) in the \'scriptData\' attribute of the Request, Response or Message object.<br/>When scriptData is set to a request, it gets set against the response that will be returned to the player. This allows basic communication between request and response scripts.<br/><b>params</b><br/>name - The name in the name value pair<br/>value - The value to set in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().setScriptData("name", "value");</pre><br/>',
        "!type": "fn(name: string, value: ?)"
      },
      removeScriptData: {
        "!doc": 'Removes a value from a name value pair structure that allows custom data to be attached to the challenge. This data can either be complex JSON or simple values.<br/><b>params</b><br/>name - The name in the name value pair<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getPlayer().removeScriptData("name");</pre><br/>',
        "!type": "fn(name: string)"
      }
    },
    SparkDigest: {
      "!doc": "Returns a reference to a SparkDigest object.<br/>Implements a number of hashing functions similar to those found in CryptoJS.<br/>example<br/>Spark.getDigester();<br/>",
      hmacMd5Base64: {
        "!doc": "Returns a HmacMD5 Message Authentication Code (MAC) as a base64 encoded string for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacMd5Base64WithBase64Key: {
        "!doc": "Returns a HmacMD5 Message Authentication Code (MAC) as a base64 encoded string for the given base64 encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacMd5Hex: {
        "!doc": "Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacMd5HexWithHexKey: {
        "!doc": "Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given hex encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha1Base64: {
        "!doc": "Returns a HmacSHA1 Message Authentication Code (MAC) as a base64 encoded string for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha1Base64WithBase64Key: {
        "!doc": "Returns a HmacSHA1 Message Authentication Code (MAC) as a base64 encoded string for the given base64 encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha1Hex: {
        "!doc": "Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha1HexWithHexKey: {
        "!doc": "Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given hex encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha256Base64: {
        "!doc": "Returns a HmacSHA256 Message Authentication Code (MAC) as a base64 encoded string for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha256Base64WithBase64Key: {
        "!doc": "Returns a HmacSHA256 Message Authentication Code (MAC) as a base64 encoded string for the given base64 encoded key and value.<br/>",
        "!type": "fn(base64Key: string, valueToDigest: string) -> string"
      },
      hmacSha256Hex: {
        "!doc": "Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha256HexWithHexKey: {
        "!doc": "Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given hex encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha384Base64: {
        "!doc": "Returns a HmacSHA384 Message Authentication Code (MAC) as a base64 encoded string for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha384Base64WithBase64Key: {
        "!doc": "Returns a HmacSHA384 Message Authentication Code (MAC) as a base64 encoded string for the given base64 encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha384Hex: {
        "!doc": "Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha384HexWithHexKey: {
        "!doc": "Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given hex encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha512Base64: {
        "!doc": "Returns a HmacSHA512 Message Authentication Code (MAC) as a base64 encoded string for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha512Base64WithBase64Key: {
        "!doc": "Returns a HmacSHA512 Message Authentication Code (MAC) as a base64 encoded string for the given base64 encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha512Hex: {
        "!doc": "Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      hmacSha512HexWithHexKey: {
        "!doc": "Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given hex encoded key and value.<br/>",
        "!type": "fn(key: string, valueToDigest: string) -> string"
      },
      md2Base64: {
        "!doc": "Calculates the MD2 digest and returns the value as a a base64 encoded string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      md2Hex: {
        "!doc": "Calculates the MD2 digest and returns the value as a 32 character hex string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      md5Base64: {
        "!doc": "Calculates the MD5 digest and returns the value as a base64 encoded string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      md5Hex: {
        "!doc": "Calculates the MD5 digest and returns the value as a 32 character hex string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha1Base64: {
        "!doc": "Calculates the SHA-1 digest and returns the value as a base64 encoded string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha1Hex: {
        "!doc": "Calculates the SHA-1 digest and returns the value as a hex string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha256Base64: {
        "!doc": "Calculates the SHA-256 digest and returns the value as a base64 encoded string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha256Hex: {
        "!doc": "Calculates the SHA-256 digest and returns the value as a hex string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha384Base64: {
        "!doc": "Calculates the SHA-384 digest and returns the value as a base64 encoded string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha384Hex: {
        "!doc": "Calculates the SHA-384 digest and returns the value as a hex string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha512Base64: {
        "!doc": "Calculates the SHA-512 digest and returns the value as a base64 encoded string.<br/>",
        "!type": "fn(data: string) -> string"
      },
      sha512Hex: {
        "!doc": "Calculates the SHA-512 digest and returns the value as a hex string.<br/>",
        "!type": "fn(data: string) -> string"
      }
    },
    SparkRedis: {
      "!doc": "Provides access to the Games Redis Instance.<br/>Rather than copy and paste the excellent documentation from the Redis site, we've opted to link to the relevant page through the documentation.<br/>e.g.<br/>var redis = Spark.getRedis();<br/>",
      append: {
        "!doc": 'See <a href="http://redis.io/commands/append">http://redis.io/commands/append</a><br/>',
        "!type": "fn(key: string, value: string) -> number"
      },
      bitcount: {
        "!doc": 'See <a href="http://redis.io/commands/bitcount">http://redis.io/commands/bitcount</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> number"
      },
      bitcount_2: {
        "!doc": 'See <a href="http://redis.io/commands/bitcount">http://redis.io/commands/bitcount</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      bitop: {
        "!doc": 'See <a href="http://redis.io/commands/bitop">http://redis.io/commands/bitop</a><br/>',
        "!type": "fn(op: string, destKey: string, srcKeys: [string]) -> number"
      },
      decr: {
        "!doc": 'See <a href="http://redis.io/commands/decr">http://redis.io/commands/decr</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      decrBy: {
        "!doc": 'See <a href="http://redis.io/commands/decrBy">http://redis.io/commands/decrBy</a><br/>',
        "!type": "fn(key: string, integer: number) -> number"
      },
      del: {
        "!doc": 'See <a href="http://redis.io/commands/del">http://redis.io/commands/del</a><br/>',
        "!type": "fn(keys: [string]) -> number"
      },
      exists: {
        "!doc": 'See <a href="http://redis.io/commands/exists">http://redis.io/commands/exists</a><br/>',
        "!type": "fn(key: string) -> bool"
      },
      expire: {
        "!doc": 'See <a href="http://redis.io/commands/expire">http://redis.io/commands/expire</a><br/>',
        "!type": "fn(key: string, seconds: number) -> number"
      },
      expireAt: {
        "!doc": 'See <a href="http://redis.io/commands/expireAt">http://redis.io/commands/expireAt</a><br/>',
        "!type": "fn(key: string, unixTime: number) -> number"
      },
      flushdb: {
        "!doc": 'See <a href="http://redis.io/commands/flushdb">http://redis.io/commands/flushdb</a><br/>',
        "!type": "fn() -> string"
      },
      get: {
        "!doc": 'See <a href="http://redis.io/commands/get">http://redis.io/commands/get</a><br/>',
        "!type": "fn(key: string) -> string"
      },
      getbit: {
        "!doc": 'See <a href="http://redis.io/commands/getbit">http://redis.io/commands/getbit</a><br/>',
        "!type": "fn(key: string, offset: number) -> bool"
      },
      getrange: {
        "!doc": 'See <a href="http://redis.io/commands/getrange">http://redis.io/commands/getrange</a><br/>',
        "!type": "fn(key: string, startOffset: number, endOffset: number) -> string"
      },
      hdel: {
        "!doc": 'See <a href="http://redis.io/commands/hdel">http://redis.io/commands/hdel</a><br/>',
        "!type": "fn(key: string, fields: [string]) -> number"
      },
      hexists: {
        "!doc": 'See <a href="http://redis.io/commands/hexists">http://redis.io/commands/hexists</a><br/>',
        "!type": "fn(key: string, field: string) -> bool"
      },
      hget: {
        "!doc": 'See <a href="http://redis.io/commands/hget">http://redis.io/commands/hget</a><br/>',
        "!type": "fn(key: string, field: string) -> string"
      },
      hgetAll: {
        "!doc": 'See <a href="http://redis.io/commands/hgetAll">http://redis.io/commands/hgetAll</a><br/>',
        "!type": "fn(key: string) -> [string]"
      },
      hincrBy: {
        "!doc": 'See <a href="http://redis.io/commands/hincrBy">http://redis.io/commands/hincrBy</a><br/>',
        "!type": "fn(key: string, field: string, value: number) -> number"
      },
      hincrByFloat: {
        "!doc": 'See <a href="http://redis.io/commands/hincrByFloat">http://redis.io/commands/hincrByFloat</a><br/>',
        "!type": "fn(key: string, field: string, increment: number) -> number"
      },
      hkeys: {
        "!doc": 'See <a href="http://redis.io/commands/hkeys">http://redis.io/commands/hkeys</a><br/>',
        "!type": "fn(key: string) -> [string]"
      },
      hlen: {
        "!doc": 'See <a href="http://redis.io/commands/hlen">http://redis.io/commands/hlen</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      hmget: {
        "!doc": 'See <a href="http://redis.io/commands/hmget">http://redis.io/commands/hmget</a><br/>',
        "!type": "fn(key: string, fields: [string]) -> [string]"
      },
      hmset: {
        "!doc": 'See <a href="http://redis.io/commands/hmset">http://redis.io/commands/hmset</a><br/>',
        "!type": "fn(key: string, hash: ?) -> string"
      },
      hset: {
        "!doc": 'See <a href="http://redis.io/commands/hset">http://redis.io/commands/hset</a><br/>',
        "!type": "fn(key: string, field: string, value: string) -> number"
      },
      hsetnx: {
        "!doc": 'See <a href="http://redis.io/commands/hsetnx">http://redis.io/commands/hsetnx</a><br/>',
        "!type": "fn(key: string, field: string, value: string) -> number"
      },
      hvals: {
        "!doc": 'See <a href="http://redis.io/commands/hvals">http://redis.io/commands/hvals</a><br/>',
        "!type": "fn(key: string) -> [string]"
      },
      incr: {
        "!doc": 'See <a href="http://redis.io/commands/incr">http://redis.io/commands/incr</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      incrBy: {
        "!doc": 'See <a href="http://redis.io/commands/incrBy">http://redis.io/commands/incrBy</a><br/>',
        "!type": "fn(key: string, integer: number) -> number"
      },
      incrByFloat: {
        "!doc": 'See <a href="http://redis.io/commands/incrByFloat">http://redis.io/commands/incrByFloat</a><br/>',
        "!type": "fn(key: string, increment: number) -> number"
      },
      keys: {
        "!doc": 'See <a href="http://redis.io/commands/keys">http://redis.io/commands/keys</a><br/>',
        "!type": "fn(pattern: string) -> [string]"
      },
      lindex: {
        "!doc": 'See <a href="http://redis.io/commands/lindex">http://redis.io/commands/lindex</a><br/>',
        "!type": "fn(key: string, index: number) -> string"
      },
      linsert: {
        "!doc": 'See <a href="http://redis.io/commands/linsert">http://redis.io/commands/linsert</a><br/>',
        "!type": "fn(key: string, where: string, pivit: string, value: string) -> number"
      },
      llen: {
        "!doc": 'See <a href="http://redis.io/commands/llen">http://redis.io/commands/llen</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      lpop: {
        "!doc": 'See <a href="http://redis.io/commands/lpop">http://redis.io/commands/lpop</a><br/>',
        "!type": "fn(key: string) -> string"
      },
      lpush: {
        "!doc": 'See <a href="http://redis.io/commands/lpush">http://redis.io/commands/lpush</a><br/>',
        "!type": "fn(key: string, strings: [string]) -> number"
      },
      lpushx: {
        "!doc": 'See <a href="http://redis.io/commands/lpushx">http://redis.io/commands/lpushx</a><br/>',
        "!type": "fn(key: string, strings: [string]) -> number"
      },
      lrange: {
        "!doc": 'See <a href="http://redis.io/commands/lrange">http://redis.io/commands/lrange</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> [string]"
      },
      lrem: {
        "!doc": 'See <a href="http://redis.io/commands/lrem">http://redis.io/commands/lrem</a><br/>',
        "!type": "fn(key: string, count: number, value: string) -> number"
      },
      lset: {
        "!doc": 'See <a href="http://redis.io/commands/lset">http://redis.io/commands/lset</a><br/>',
        "!type": "fn(key: string, index: number, value: string) -> string"
      },
      ltrim: {
        "!doc": 'See <a href="http://redis.io/commands/ltrim">http://redis.io/commands/ltrim</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> string"
      },
      mget: {
        "!doc": 'See <a href="http://redis.io/commands/mget">http://redis.io/commands/mget</a><br/>',
        "!type": "fn(keys: [string]) -> [string]"
      },
      mset: {
        "!doc": 'See <a href="http://redis.io/commands/mset">http://redis.io/commands/mset</a><br/>',
        "!type": "fn(keysvalues: [string]) -> string"
      },
      msetnx: {
        "!doc": 'See <a href="http://redis.io/commands/msetnx">http://redis.io/commands/msetnx</a><br/>',
        "!type": "fn(keysvalues: [string]) -> number"
      },
      persist: {
        "!doc": 'See <a href="http://redis.io/commands/persist">http://redis.io/commands/persist</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      pexpire: {
        "!doc": 'See <a href="http://redis.io/commands/pexpire">http://redis.io/commands/pexpire</a><br/>',
        "!type": "fn(key: string, milliseconds: number) -> number"
      },
      pexpireAt: {
        "!doc": 'See <a href="http://redis.io/commands/pexpireAt">http://redis.io/commands/pexpireAt</a><br/>',
        "!type": "fn(key: string, millisecondsTimestamp: number) -> number"
      },
      psetex: {
        "!doc": 'See <a href="http://redis.io/commands/psetex">http://redis.io/commands/psetex</a><br/>',
        "!type": "fn(key: string, milliseconds: number, value: string) -> string"
      },
      pttl: {
        "!doc": 'See <a href="http://redis.io/commands/pttl">http://redis.io/commands/pttl</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      rename: {
        "!doc": 'See <a href="http://redis.io/commands/rename">http://redis.io/commands/rename</a><br/>',
        "!type": "fn(oldkey: string, newkey: string) -> string"
      },
      renamenx: {
        "!doc": 'See <a href="http://redis.io/commands/renamenx">http://redis.io/commands/renamenx</a><br/>',
        "!type": "fn(oldkey: string, newkey: string) -> number"
      },
      rpop: {
        "!doc": 'See <a href="http://redis.io/commands/rpop">http://redis.io/commands/rpop</a><br/>',
        "!type": "fn(key: string) -> string"
      },
      rpoplpush: {
        "!doc": 'See <a href="http://redis.io/commands/rpoplpush">http://redis.io/commands/rpoplpush</a><br/>',
        "!type": "fn(srckey: string, dstkey: string) -> string"
      },
      rpush: {
        "!doc": 'See <a href="http://redis.io/commands/rpush">http://redis.io/commands/rpush</a><br/>',
        "!type": "fn(key: string, strings: [string]) -> number"
      },
      rpushx: {
        "!doc": 'See <a href="http://redis.io/commands/rpushx">http://redis.io/commands/rpushx</a><br/>',
        "!type": "fn(key: string, strings: [string]) -> number"
      },
      sadd: {
        "!doc": 'See <a href="http://redis.io/commands/sadd">http://redis.io/commands/sadd</a><br/>',
        "!type": "fn(key: string, members: [string]) -> number"
      },
      scard: {
        "!doc": 'See <a href="http://redis.io/commands/scard">http://redis.io/commands/scard</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      sdiff: {
        "!doc": 'See <a href="http://redis.io/commands/sdiff">http://redis.io/commands/sdiff</a><br/>',
        "!type": "fn(keys: [string]) -> [string]"
      },
      sdiffstore: {
        "!doc": 'See <a href="http://redis.io/commands/sdiffstore">http://redis.io/commands/sdiffstore</a><br/>',
        "!type": "fn(dstkey: string, keys: [string]) -> number"
      },
      getSet: {
        "!doc": 'See <a href="http://redis.io/commands/getSet">http://redis.io/commands/getSet</a><br/>',
        "!type": "fn(key: string, value: string) -> string"
      },
      set: {
        "!doc": 'See <a href="http://redis.io/commands/set">http://redis.io/commands/set</a><br/>',
        "!type": "fn(key: string, value: string) -> string"
      },
      set_61: {
        "!doc": 'See <a href="http://redis.io/commands/set">http://redis.io/commands/set</a><br/>',
        "!type": "fn(key: string, value: string, nxxx: string, expx: string, time: number) -> string"
      },
      set_62: {
        "!doc": 'See <a href="http://redis.io/commands/set">http://redis.io/commands/set</a><br/>',
        "!type": "fn(key: string, value: string, nxxx: string, expx: string, time: number) -> string"
      },
      set_63: {
        "!doc": 'See <a href="http://redis.io/commands/set">http://redis.io/commands/set</a><br/>',
        "!type": "fn(key: string, value: string, nxxx: string) -> string"
      },
      setbit: {
        "!doc": 'See <a href="http://redis.io/commands/setbit">http://redis.io/commands/setbit</a><br/>',
        "!type": "fn(key: string, offset: number, value: bool) -> bool"
      },
      setex: {
        "!doc": 'See <a href="http://redis.io/commands/setex">http://redis.io/commands/setex</a><br/>',
        "!type": "fn(key: string, seconds: number, value: string) -> string"
      },
      setnx: {
        "!doc": 'See <a href="http://redis.io/commands/setnx">http://redis.io/commands/setnx</a><br/>',
        "!type": "fn(key: string, value: string) -> number"
      },
      setrange: {
        "!doc": 'See <a href="http://redis.io/commands/setrange">http://redis.io/commands/setrange</a><br/>',
        "!type": "fn(key: string, offset: number, value: string) -> number"
      },
      sinter: {
        "!doc": 'See <a href="http://redis.io/commands/sinter">http://redis.io/commands/sinter</a><br/>',
        "!type": "fn(keys: [string]) -> [string]"
      },
      sinterstore: {
        "!doc": 'See <a href="http://redis.io/commands/sinterstore">http://redis.io/commands/sinterstore</a><br/>',
        "!type": "fn(dstkey: string, keys: [string]) -> number"
      },
      sismember: {
        "!doc": 'See <a href="http://redis.io/commands/sismember">http://redis.io/commands/sismember</a><br/>',
        "!type": "fn(key: string, member: string) -> bool"
      },
      smembers: {
        "!doc": 'See <a href="http://redis.io/commands/smembers">http://redis.io/commands/smembers</a><br/>',
        "!type": "fn(key: string) -> [string]"
      },
      smove: {
        "!doc": 'See <a href="http://redis.io/commands/smove">http://redis.io/commands/smove</a><br/>',
        "!type": "fn(srckey: string, dstkey: string, member: string) -> number"
      },
      sort: {
        "!doc": 'See <a href="http://redis.io/commands/sort">http://redis.io/commands/sort</a><br/>',
        "!type": "fn(key: string, dstkey: string) -> number"
      },
      sort_74: {
        "!doc": 'See <a href="http://redis.io/commands/sort">http://redis.io/commands/sort</a><br/>',
        "!type": "fn(key: string) -> [string]"
      },
      spop: {
        "!doc": 'See <a href="http://redis.io/commands/spop">http://redis.io/commands/spop</a><br/>',
        "!type": "fn(key: string) -> string"
      },
      srandmember: {
        "!doc": 'See <a href="http://redis.io/commands/srandmember">http://redis.io/commands/srandmember</a><br/>',
        "!type": "fn(key: string) -> string"
      },
      srandmember_77: {
        "!doc": 'See <a href="http://redis.io/commands/srandmember">http://redis.io/commands/srandmember</a><br/>',
        "!type": "fn(key: string, count: number) -> [string]"
      },
      srem: {
        "!doc": 'See <a href="http://redis.io/commands/srem">http://redis.io/commands/srem</a><br/>',
        "!type": "fn(key: string, members: [string]) -> number"
      },
      strlen: {
        "!doc": 'See <a href="http://redis.io/commands/strlen">http://redis.io/commands/strlen</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      substr: {
        "!doc": 'See <a href="http://redis.io/commands/substr">http://redis.io/commands/substr</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> string"
      },
      sunion: {
        "!doc": 'See <a href="http://redis.io/commands/sunion">http://redis.io/commands/sunion</a><br/>',
        "!type": "fn(keys: [string]) -> [string]"
      },
      sunionstore: {
        "!doc": 'See <a href="http://redis.io/commands/sunionstore">http://redis.io/commands/sunionstore</a><br/>',
        "!type": "fn(dstkey: string, keys: [string]) -> number"
      },
      ttl: {
        "!doc": 'See <a href="http://redis.io/commands/ttl">http://redis.io/commands/ttl</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      type: {
        "!doc": 'See <a href="http://redis.io/commands/type">http://redis.io/commands/type</a><br/>',
        "!type": "fn(key: string) -> string"
      },
      zadd: {
        "!doc": 'See <a href="http://redis.io/commands/zadd">http://redis.io/commands/zadd</a><br/>',
        "!type": "fn(key: string, score: number, member: string) -> number"
      },
      zcard: {
        "!doc": 'See <a href="http://redis.io/commands/zcard">http://redis.io/commands/zcard</a><br/>',
        "!type": "fn(key: string) -> number"
      },
      zcount: {
        "!doc": 'See <a href="http://redis.io/commands/zcount">http://redis.io/commands/zcount</a><br/>',
        "!type": "fn(key: string, min: string, max: string) -> number"
      },
      zcount_88: {
        "!doc": 'See <a href="http://redis.io/commands/zcount">http://redis.io/commands/zcount</a><br/>',
        "!type": "fn(key: string, min: number, max: number) -> number"
      },
      zincrby: {
        "!doc": 'See <a href="http://redis.io/commands/zincrby">http://redis.io/commands/zincrby</a><br/>',
        "!type": "fn(key: string, score: number, member: string) -> number"
      },
      zinterstore: {
        "!doc": 'See <a href="http://redis.io/commands/zinterstore">http://redis.io/commands/zinterstore</a><br/>',
        "!type": "fn(dstkey: string, sets: [string]) -> number"
      },
      zrange: {
        "!doc": 'See <a href="http://redis.io/commands/zrange">http://redis.io/commands/zrange</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> [string]"
      },
      zrangeByScore: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScore">http://redis.io/commands/zrangeByScore</a><br/>',
        "!type": "fn(key: string, min: number, max: number, offset: number, count: number) -> [string]"
      },
      zrangeByScore_93: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScore">http://redis.io/commands/zrangeByScore</a><br/>',
        "!type": "fn(key: string, min: string, max: string, offset: number, count: number) -> [string]"
      },
      zrangeByScore_94: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScore">http://redis.io/commands/zrangeByScore</a><br/>',
        "!type": "fn(key: string, min: number, max: number) -> [string]"
      },
      zrangeByScore_95: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScore">http://redis.io/commands/zrangeByScore</a><br/>',
        "!type": "fn(key: string, min: string, max: string) -> [string]"
      },
      zrangeByScoreWithScores: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScoreWithScores">http://redis.io/commands/zrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, min: string, max: string, offset: number, count: number) -> ?"
      },
      zrangeByScoreWithScores_97: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScoreWithScores">http://redis.io/commands/zrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, min: string, max: string) -> ?"
      },
      zrangeByScoreWithScores_98: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScoreWithScores">http://redis.io/commands/zrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, min: number, max: number, offset: number, count: number) -> ?"
      },
      zrangeByScoreWithScores_99: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeByScoreWithScores">http://redis.io/commands/zrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, min: number, max: number) -> ?"
      },
      zrangeWithScores: {
        "!doc": 'See <a href="http://redis.io/commands/zrangeWithScores">http://redis.io/commands/zrangeWithScores</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> ?"
      },
      zrank: {
        "!doc": 'See <a href="http://redis.io/commands/zrank">http://redis.io/commands/zrank</a><br/>',
        "!type": "fn(key: string, member: string) -> number"
      },
      zrem: {
        "!doc": 'See <a href="http://redis.io/commands/zrem">http://redis.io/commands/zrem</a><br/>',
        "!type": "fn(key: string, members: [string]) -> number"
      },
      zremrangeByRank: {
        "!doc": 'See <a href="http://redis.io/commands/zremrangeByRank">http://redis.io/commands/zremrangeByRank</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> number"
      },
      zremrangeByScore: {
        "!doc": 'See <a href="http://redis.io/commands/zremrangeByScore">http://redis.io/commands/zremrangeByScore</a><br/>',
        "!type": "fn(key: string, start: string, end: string) -> number"
      },
      zremrangeByScore_105: {
        "!doc": 'See <a href="http://redis.io/commands/zremrangeByScore">http://redis.io/commands/zremrangeByScore</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> number"
      },
      zrevrange: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrange">http://redis.io/commands/zrevrange</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> [string]"
      },
      zrevrangeByScore: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScore">http://redis.io/commands/zrevrangeByScore</a><br/>',
        "!type": "fn(key: string, max: string, min: string, offset: number, count: number) -> [string]"
      },
      zrevrangeByScore_108: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScore">http://redis.io/commands/zrevrangeByScore</a><br/>',
        "!type": "fn(key: string, max: string, min: string) -> [string]"
      },
      zrevrangeByScore_109: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScore">http://redis.io/commands/zrevrangeByScore</a><br/>',
        "!type": "fn(key: string, max: number, min: number) -> [string]"
      },
      zrevrangeByScore_110: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScore">http://redis.io/commands/zrevrangeByScore</a><br/>',
        "!type": "fn(key: string, max: number, min: number, offset: number, count: number) -> [string]"
      },
      zrevrangeByScoreWithScores: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScoreWithScores">http://redis.io/commands/zrevrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, max: number, min: number, offset: number, count: number) -> ?"
      },
      zrevrangeByScoreWithScores_112: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScoreWithScores">http://redis.io/commands/zrevrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, max: number, min: number) -> ?"
      },
      zrevrangeByScoreWithScores_113: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScoreWithScores">http://redis.io/commands/zrevrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, max: string, min: string, offset: number, count: number) -> ?"
      },
      zrevrangeByScoreWithScores_114: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeByScoreWithScores">http://redis.io/commands/zrevrangeByScoreWithScores</a><br/>',
        "!type": "fn(key: string, max: string, min: string) -> ?"
      },
      zrevrangeWithScores: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrangeWithScores">http://redis.io/commands/zrevrangeWithScores</a><br/>',
        "!type": "fn(key: string, start: number, end: number) -> ?"
      },
      zrevrank: {
        "!doc": 'See <a href="http://redis.io/commands/zrevrank">http://redis.io/commands/zrevrank</a><br/>',
        "!type": "fn(key: string, member: string) -> number"
      },
      zscore: {
        "!doc": 'See <a href="http://redis.io/commands/zscore">http://redis.io/commands/zscore</a><br/>',
        "!type": "fn(key: string, member: string) -> number"
      },
      zunionstore: {
        "!doc": 'See <a href="http://redis.io/commands/zunionstore">http://redis.io/commands/zunionstore</a><br/>',
        "!type": "fn(dstkey: string, sets: [string]) -> number"
      }
    },
    SparkLeaderboard: {
      "!doc": "Provides access to the entries of a leaderboard.<br/>e.g.<br/>var leaderboard = Spark.getLeaderboards().getLeaderboard(shortCode);<br/>",
      getDescription: {
        "!doc": 'Returns the description of this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var desc = Spark.getLeaderboards().getLeaderboard(shortCode).getDescription();</pre><br/>',
        "!type": "fn() -> string"
      },
      getName: {
        "!doc": 'Returns the name of this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var shortCode = Spark.getLeaderboards().getLeaderboard(shortCode).getName();</pre><br/>',
        "!type": "fn() -> string"
      },
      getShortCode: {
        "!doc": 'Returns the shortCode of this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var shortCode = Spark.getLeaderboards().getLeaderboard(shortCode).getShortCode();</pre><br/>',
        "!type": "fn() -> string"
      },
      getEntryCount: {
        "!doc": 'Returns the total number of entries in this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = Spark.getLeaderboards().getLeaderboard(shortCode).getEntryCount();</pre><br/>',
        "!type": "fn() -> number"
      },
      getEntryCountForIdentifier: {
        "!doc": 'Returns the total number of entries in this leaderboard for the specified identifier.<br/>The later can be the userId of a player or the id of a team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = Spark.getLeaderboards().getLeaderboard(shortCode).getEntryCountForIdentifier("myPlayerId");</pre><br/>',
        "!type": "fn(identifier: string) -> number"
      },
      getEntries: {
        "!doc": 'Returns a cursor over all the entries in this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = Spark.getLeaderboards().getLeaderboard(shortCode).getEntries();</pre><br/>',
        "!type": "fn() -> SparkLeaderboardCursor"
      },
      getEntries_6: {
        "!doc": 'Returns a cursor over <b>count</b> entries in this leaderboard, starting at <b>offset</b>.<br/><b>params</b><br/>count - the number of entries over which to obtain a cursor.<br/>offset - the number of entries to skip before the start of the cursor.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = Spark.getLeaderboards().getLeaderboard(shortCode).getEntries(mycount, myoffset);</pre><br/>',
        "!type": "fn(count: number, offset: number) -> SparkLeaderboardCursor"
      },
      isPartitioned: {
        "!doc": 'Returns true if this leaderboard has or can have partitions.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var isPartitioned = Spark.getLeaderboards().getLeaderboard(shortCode).isPartitioned();</pre><br/>',
        "!type": "fn() -> bool"
      },
      isPartition: {
        "!doc": 'Returns true if this leaderboard is a single partition of a parent leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var isPartitioned = Spark.getLeaderboards().getLeaderboard(shortCode).isPartition();</pre><br/>',
        "!type": "fn() -> bool"
      },
      getPartitions: {
        "!doc": 'Returns an array containing the partitions of this leaderboard if it is partitioned, otherwise an empty array is returned.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var partitions = Spark.getLeaderboards().getLeaderboard(shortCode).getPartitions();</pre><br/>',
        "!type": "fn() -> [SparkLeaderboardPartition]"
      },
      drop: {
        "!doc": 'Deletes the underlying data for this leaderboard, making it like new.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLeaderboards().getLeaderboard(shortCode).drop();</pre><br/>',
        "!type": "fn()"
      },
      drop_11: {
        "!doc": 'See #drop.  Additionally deletes the underlying running total data, resetting any record of players\' scores.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.drop(true);</pre><br/>',
        "!type": "fn(deleteRunningTotalData: bool)"
      },
      getEntriesForIdentifier: {
        "!doc": 'Returns the array of leaderboard entries that correspond to the supplied identifier and customIdFilter<br/>If the customIdFilter is null, the method returns all the entries in the leaderboard for the suplied identifier<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getEntriesForIdentifier(myPlayerId, {});</pre><br/>',
        "!type": "fn(identifier: string, customIdFilter: ?) -> SparkLeaderboardEntry[]"
      },
      getEntriesFromPlayer: {
        "!doc": 'Returns a cursor over the leaderboard entries starting from the highest score of the supplied playerId<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getEntriesFromPlayer(myPlayerId, 50);</pre><br/>',
        "!type": "fn(playerId: string, count: number) -> SparkLeaderboardCursor"
      },
      getEntriesFromPlayerForCustomId: {
        "!doc": 'Returns a cursor over the leaderboard entries starting from the highest score of the supplied playerId and customIdFilter<br/>If the customId filter is not an object with valid ID fields, it will return an empty cursor<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getEntriesFromPlayerForCustomId(myPlayerId, 50, {carType:"raceCar"});</pre><br/>',
        "!type": "fn(playerId: string, count: number, customIdFilter: ?) -> SparkLeaderboardCursor"
      },
      getIdFields: {
        "!doc": 'Returns the list of custom ID fields that are defined on the leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getIdFields();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      getScoreFields: {
        "!doc": 'Returns the list of fields that are defined on the leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getScoreFields();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      deleteAllEntries: {
        "!doc": 'Deletes all entries from the leaderboard that correspond to this identifier. If your leaderboard has custom IDs set up, <br/>it will delete the entries for all the custom IDs<br/>This method only works for realtime leaderboards<br/>If deleteRunningTotals is true, all running total data for these entries will also be deleted<br/>deleting running totals may affect other leaderbaords using the same running totals<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.deleteEntry(myPlayerId, true);</pre><br/>',
        "!type": "fn(identifier: string, deleteRunningTotals: bool) -> bool"
      },
      deleteEntriesForCustomId: {
        "!doc": 'Deletes the entries from the leaderboard that match the specified customIdFilter.<br/>This method only works for realtime leaderboards<br/>If deleteRunningTotals is true, all running total data for this leaderboard will also be deleted<br/>deleting running totals may affect other leaderbaords using the same running totals<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.deleteEntriesForCustomId(myPlayerId, true, {"carType":"raceCar"});</pre><br/>',
        "!type": "fn(identifier: string, deleteRunningTotals: bool, customIdFilter: ?) -> bool"
      },
      deleteEntry: {
        "!doc": '<b>DEPRECATED use leaderboard.deleteAllEntries(identifier, deleteRunningTotals)<br/> or leaderboard.deleteEntriesForCustomId(identifier, deleteRunningTotals, customIdFilter).</b><br/>Deletes the entry from the leaderboard that correspond to this identifier.<br/>This method is not supported for leaderboards with custom IDs and will throw an java.lang.UnsupportedOperationException<br/>This method only works for realtime leaderboards<br/>If deleteRunningTotals is true, all running total data for these entries will also be deleted<br/>deleting running totals may affect other leaderbaords using the same running totals<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.deleteEntry(myPlayerId, true);</pre><br/>',
        "!type": "fn(identifier: string, deleteRunningTotals: bool) -> bool"
      },
      getPropertySet: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the property set associated with this leaderboard<br/>",
        "!type": "fn() -> ?"
      },
      getRankForScore: {
        "!doc": 'Returns the rank a given score would be at on this Global leaderboard, without it actually being entered into the leaderboard.<br/>Calling this on a Team or Social leaderboard will return null.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var rank = leaderboard.getRankForScore({"score" : 123});</pre><br/>',
        "!type": "fn(score: ?) -> number"
      },
      rebuildLeaderboard: {
        "!doc": 'Drops the current leaderboard and it rebuilds it from the running totals.<br/>The current leaderboard may not have valid ranks for the duration of this process.<br/>You can only rebuild realtime leaderboards. You cannot rebuild partitioned leaderboards, you can only rebuild the individual partitions.<br/>If the flag awardAchievements is set to true, at the end of the rebuild process the appropriate achievements will be awarded<br/>Please use with care, because during the rebuild process any new data coming from the players might temporarily have incorrect ranks<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.rebuildLeaderboard(true);</pre><br/>',
        "!type": "fn(awardAchievements: bool)"
      }
    },
    SparkLeaderboards: {
      "!doc": "Provides access to the leaderboards for the current game.<br/>var leaderboards = Spark.getLeaderboards();<br/>",
      getLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a SparkLeaderboard object by its shortCode.<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getLeaderboard(shortCode);</pre><br/>',
        "!type": "fn(shortCode: string) -> SparkLeaderboard"
      },
      getSocialLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode, where the social group contains the current player and the players with the given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>friendsIds - the ids of the other players to be included in this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getSocialLeaderboard(shortCode, myplayerids);</pre><br/>',
        "!type": "fn(shortCode: string, friendIds: [string]) -> SparkLeaderboard"
      },
      getInverseSocialLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode for the current player, where the social group excludes the players with the given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>friendsIds - the ids of the other players to be excluded from this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseSocialLeaderboard(shortCode, myplayerids);</pre><br/>',
        "!type": "fn(shortCode: string, friendIds: [string]) -> SparkLeaderboard"
      },
      getSocialLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode, where the social group contains the player with the given playerId and the players with given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>playerId - the playerId to load the social leaderboard for.<br/>friendsIds - the ids of the other players to be included in this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getSocialLeaderboardAs(shortCode, myplayerid, myplayerids);</pre><br/>',
        "!type": "fn(shortCode: string, playerId: string, friendIds: [string]) -> SparkLeaderboard"
      },
      getInverseSocialLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode for the given player, where the social group excludes the players with the given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>playerId - the playerId to load the social leaderboard for.<br/>friendsIds - the ids of the other players to be excluded from this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseSocialLeaderboardAs(shortCode, myplayerid, myplayerids);</pre><br/>',
        "!type": "fn(shortCode: string, playerId: string, friendIds: [string]) -> SparkLeaderboard"
      },
      getTeamLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode, where the social group contains the current player and the players belonging to the teams with the given teamIds<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>teamids - the ids of the teams to be included in this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getTeamLeaderboard(shortCode, myteamids);</pre><br/>',
        "!type": "fn(shortCode: string, teamIds: [string]) -> SparkLeaderboard"
      },
      getInverseTeamLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode for the current player, where the social group excludes the players belonging to the teams with the given teamIds<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>teamids - the ids of the teams to be excluded from this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseTeamLeaderboard(shortCode, myteamids);</pre><br/>',
        "!type": "fn(shortCode: string, teamIds: [string]) -> SparkLeaderboard"
      },
      getTeamLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode, where the social group contains the player for the given playerId and the players belonging to the teams with the given teamIds<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>playerId - the playerId to load the social leaderboard for.<br/>teamids - the ids of the teams to be included in this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getTeamLeaderboard(shortCode, myplayerid, myteamids);</pre><br/>',
        "!type": "fn(shortCode: string, playerId: string, teamIds: [string]) -> SparkLeaderboard"
      },
      getInverseTeamLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard object by its shortCode for the given player, where the social group excludes the players belonging to the teams with the given teamIds<br/><b>params</b><br/>shortCode - the shortCode of the leaderboard.<br/>playerId - the playerId to load the social leaderboard for.<br/>teamids - the ids of the teams to be excluded from this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseTeamLeaderboard(shortCode, myplayerid, myteamids);</pre><br/>',
        "!type": "fn(shortCode: string, playerId: string, teamIds: [string]) -> SparkLeaderboard"
      },
      listLeaderboards: {
        "!doc": '<b>validity</b> All Scripts<br/>Gives access to all leaderboards configured for the game<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboards = Spark.getLeaderboards().listLeaderboards();</pre><br/>',
        "!type": "fn() -> [SparkLeaderboard]"
      },
      getChallengeLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a SparkLeaderboard object for a specific challenge by the challengeInstanceId.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getChallengeLeaderboard(challengeInstanceId);</pre><br/>',
        "!type": "fn(challengeInstanceId: string) -> SparkLeaderboard"
      },
      getSocialChallengeLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge, where the social group contains the current player and the given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>friendsIds - the ids of the other players to be included in this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getSocialChallengeLeaderboard(challengeInstanceId, myplayerids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, friendsIds: [string]) -> SparkLeaderboard"
      },
      union: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a union on the set of owners returned as result of evaluating the first operation and the set of owners returned as result of evaluating the second operation.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inAny = Spark.getLeaderboards().union(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboardOperations, rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      union_13: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a union on the set of owners returned as result of evaluating the operation and the owners of entries within the leaderboard.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inAny = Spark.getLeaderboards().union(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboardOperations, rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      union_14: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a union on the set of owners of entries within the leaderboard and the set of owners returned as result of evaluating the operation.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inAny = Spark.getLeaderboards().union(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboard, rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      union_15: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a union on the set of owners of entries within the first leaderboard and the set of owners of entries within the second.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inAny = Spark.getLeaderboards().union(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboard, rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      getInverseSocialChallengeLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge for the current player, where the social group excludes the players with the given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>friendsIds - the ids of the other players to be excluded from this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseSocialChallengeLeaderboard(challengeInstanceId, myplayerids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, friendsIds: [string]) -> SparkLeaderboard"
      },
      getSocialChallengeLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge, where the social group contains the player with the given playerId and the players with given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>playerId - the playerId to load the social leaderboard for.<br/>friendsIds - the ids of the other players to be included in this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getSocialChallengeLeaderboardAs(challengeInstanceId, myplayerid, myplayerids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, playerId: string, friendIds: [string]) -> SparkLeaderboard"
      },
      getInverseSocialChallengeLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge for the current player, where the social group excludes the players with given playerIds.<br/>If no playerIds are provided the player\'s game friends are used.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>playerId - the playerId to load the social leaderboard for.<br/>friendsIds - the ids of the players to be excluded from this social leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseSocialChallengeLeaderboardAs(challengeInstanceId, myplayerid, myplayerids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, playerId: string, friendIds: [string]) -> SparkLeaderboard"
      },
      getTeamChallengeLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge, where the social group contains the current player and the players belonging to the teams with the given teamIds.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>teamids - the ids of the teams to be included in this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getTeamChallengeLeaderboard(challengeInstanceId, myteamids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, teamIds: [string]) -> SparkLeaderboard"
      },
      getInverseTeamChallengeLeaderboard: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge for the current player, where the social group excludes the players belonging to the teams with the given teamIds.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>teamids - the ids of the teams to be excluded from this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseTeamChallengeLeaderboard(challengeInstanceId, myteamids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, teamIds: [string]) -> SparkLeaderboard"
      },
      intersection: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs an intersection on the set of owners returned as result of evaluating the operation and the owners of entries within the leaderboard.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inBoth = Spark.getLeaderboards().intersection(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboardOperations, rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      intersection_22: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs an intersection on the set of owners returned as result of evaluating the first operation and the set of owners returned as result of evaluating the second operation.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inBoth = Spark.getLeaderboards().intersection(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboardOperations, rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      intersection_23: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs an intersection on the set of owners of entries within the leaderboard and the set of owners returned as result of evaluating the operation.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inBoth = Spark.getLeaderboards().intersection(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboard, rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      intersection_24: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs an intersection on the set of owners of entries within the first leaderboard and the set of owners of entries within the second.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inBoth = Spark.getLeaderboards().intersection(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboard, rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      getTeamChallengeLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge where the social group contains the player for the given playerId and the players belonging to the teams with the given teamIds.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>playerId - the playerId to load the social leaderboard for.<br/>teamids - the ids of the teams to be included in this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getTeamChallengeLeaderboard(challengeInstanceId, myplayerid, myteamids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, playerId: string, teamIds: [string]) -> SparkLeaderboard"
      },
      getInverseTeamChallengeLeaderboardAs: {
        "!doc": '<b>validity</b> All Scripts<br/>Allows a script to load a social SparkLeaderboard for a specific challenge for the given player, where the social group  excludes the players belonging to the teams with the given teamIds.<br/><b>params</b><br/>challengeInstanceId - the id of the challenge instance to load the leaderboard for.<br/>playerId - the playerId to load the social leaderboard for.<br/>teamids - the ids of the teams to be excluded from this social leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var leaderboard = Spark.getLeaderboards().getInverseTeamChallengeLeaderboard(challengeInstanceId, myplayerid, myteamids);</pre><br/>',
        "!type": "fn(challengeInstanceId: string, playerId: string, teamIds: [string]) -> SparkLeaderboard"
      },
      difference: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a difference on the set of owners returned as result of evaluating the operation and the owners of entries within the leaderboard.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var onlyInFirst = Spark.getLeaderboards().difference(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboardOperations, rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      difference_28: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a difference on the set of owners returned as result of evaluating the first operation and the set of owners returned as result of evaluating the second operation.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var onlyInFirst = Spark.getLeaderboards().difference(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboardOperations, rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      difference_29: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a difference on the set of owners of entries within the leaderboard and the set of owners returned as result of evaluating the operation.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var onlyInFirst = Spark.getLeaderboards().difference(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboard, rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      difference_30: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a difference on the set of owners of entries within the first leaderboard and the set of owners of entries within the second.<br/>Returns a SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>lhs - the left-hand side of the operation.<br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var onlyInFirst = Spark.getLeaderboards().difference(lhs, rhs).evaluate();</pre><br/>',
        "!type": "fn(lhs: SparkLeaderboard, rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      }
    },
    SparkLog: {
      "!doc": "A Logging interface that can be called from scripts.<br/>This interface writes to the script.log table that is accessible in the developer portal using the NoSQL explorer tool.<br/>The object passed can either be complex JSON or simple javascript values.<br/>e.g.<br/>var logger = Spark.getLog();<br/>",
      debug: {
        "!doc": 'Records value into the spark.log table with the level set to debug.<br/><b>params</b><br/>msg - the message to log<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLog().debug("Simple string logging");</pre><br/>',
        "!type": "fn(msg: ?)"
      },
      info: {
        "!doc": 'Records value into the spark.log table with the level set to info.<br/><b>params</b><br/>msg - the message to log<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLog().info({type:"JSON logging"});</pre><br/>',
        "!type": "fn(msg: ?)"
      },
      warn: {
        "!doc": 'Records value into the spark.log table with the level set to warn.<br/><b>params</b><br/>msg - the message to log<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLog().warn({type:"JSON logging"})</pre><br/>',
        "!type": "fn(msg: ?)"
      },
      error: {
        "!doc": 'Records value into the spark.log table with the level set to info.<br/><b>params</b><br/>msg - the message to log<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLog().error({type:"JSON logging"})</pre><br/>',
        "!type": "fn(msg: ?)"
      },
      getLevel: {
        "!doc": 'Returns the currently configured log level.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLog().getLevel()</pre><br/>',
        "!type": "fn() -> string"
      },
      setLevel: {
        "!doc": 'Updates the current level that logs will be written at.<br/>Entries will only be written if the level is greater than the current level set.<br/>Available levels are: "DEBUG", "INFO", "WARN", "ERROR".<br/>Note: this change takes time to propagate throughout the system, it may be minutes before all servers are using the new level.<br/><b>params</b><br/>level - the new level at which to log<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLog().setLevel("DEBUG")</pre><br/>',
        "!type": "fn(level: string)"
      }
    },
    SparkPushRegistration: {
      "!doc": "The registration of a device to receive push notifications.<br/>e.g.<br/>var player = Spark.getPlayer().getPushRegistrations();<br/>",
      getId: {
        "!doc": 'Gets the id of this registration.  This is the registrationId returned from the PushRegistrationResponse.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pushRegistration.getId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getPushId: {
        "!doc": 'Returns the id that uniquely identifies the device to the 3rd party push service.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pushRegistration.getPushId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getDeviceOS: {
        "!doc": 'Returns the OS type for the device to which this registration belongs.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pushRegistration.getDeviceOS();</pre><br/>',
        "!type": "fn() -> string"
      }
    },
    SparkBulkJob: {
      "!doc": "An object that represents a bulk job.<br/>e.g.<br/>var bulkJob = Spark.getBulkJobScheduler().listBulkJobs(null)[0];<br/>",
      getId: {
        "!doc": 'Returns the ID of this bulk job.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getBulkJobScheduler().listBulkJobs(null)[0].getId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getActualCount: {
        "!doc": "The actual count of players affected by the bulk job<br/>",
        "!type": "fn() -> number"
      },
      getCompleted: {
        "!doc": "The time at which the bulk job completed execution<br/>",
        "!type": "fn() -> date"
      },
      getCreated: {
        "!doc": "The time at which the bulk job was created<br/>",
        "!type": "fn() -> date"
      },
      getData: {
        "!doc": "Data to be passed into the Module or Script<br/>",
        "!type": "fn() -> ?"
      },
      getDoneCount: {
        "!doc": "The number of players processed by the bulk job<br/>",
        "!type": "fn() -> number"
      },
      getErrorCount: {
        "!doc": "The number of errors encountered whilst running the Module or Script for players<br/>",
        "!type": "fn() -> number"
      },
      getEstimatedCount: {
        "!doc": "The estimated count of players affected by the bulk job<br/>",
        "!type": "fn() -> number"
      },
      getModuleShortCode: {
        "!doc": "The Cloud Code Module to run for each player<br/>",
        "!type": "fn() -> string"
      },
      getPlayerQuery: {
        "!doc": "The query to identify players to perform the bulk job on<br/>",
        "!type": "fn() -> ?"
      },
      getScheduledTime: {
        "!doc": "The time at which the job was scheduled to run<br/>",
        "!type": "fn() -> date"
      },
      getScript: {
        "!doc": "The Cloud Code script to run for each player<br/>",
        "!type": "fn() -> string"
      },
      getStarted: {
        "!doc": "The time at which the bulk job started to execute<br/>",
        "!type": "fn() -> date"
      }
    },
    SparkHttp: {
      "!doc": 'Provides access to a HTTP client object.<br/>e.g.<br/>var httpSender = Spark.getHttp("http://somehost");<br/>',
      setBasicAuth: {
        "!doc": 'Sets credentials to be used for Basic Auth<br/><b>params</b><br/>userName - the username to use<br/>password - the password to use<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).setBasicAuth("myusername", "mypassword");</pre><br/>',
        "!type": "fn(username: string, password: string) -> SparkHttp"
      },
      setHeaders: {
        "!doc": 'Add custom header to the request<br/><b>params</b><br/>headers - A JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).setHeaders({"X-Custom-header":"1234"});</pre><br/>',
        "!type": "fn(headers: ?) -> SparkHttp"
      },
      get: {
        "!doc": 'Perform a HTTP GET request<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).get();</pre><br/>',
        "!type": "fn() -> SparkHttpResponse"
      },
      postForm: {
        "!doc": 'Perform a HTTP POST using a JSON form object<br/><b>params</b><br/>form - the HTTP form data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).postForm(form);</pre><br/>',
        "!type": "fn(form: ?) -> SparkHttpResponse"
      },
      postXml: {
        "!doc": 'Perform a HTTP POST using an XML form object<br/><b>params</b><br/>form - the HTTP form data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).postXml(xmlForm);</pre><br/>',
        "!type": "fn(form: XMLObject) -> SparkHttpResponse"
      },
      postJson: {
        "!doc": 'Perform a HTTP POST using a JSON form object<br/><b>params</b><br/>form - the HTTP form data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).postJson(jsonForm);</pre><br/>',
        "!type": "fn(form: ?) -> SparkHttpResponse"
      },
      postString: {
        "!doc": 'Perform a HTTP POST using a string<br/><b>params</b><br/>data - the HTTP POST data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).postString(data);</pre><br/>',
        "!type": "fn(data: string) -> SparkHttpResponse"
      },
      putForm: {
        "!doc": 'Perform a HTTP PUT using a JSON form object<br/><b>params</b><br/>form - the HTTP form data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).putForm(form);</pre><br/>',
        "!type": "fn(form: ?) -> SparkHttpResponse"
      },
      putXml: {
        "!doc": 'Perform a HTTP PUT using an XML form object<br/><b>params</b><br/>form - the HTTP form data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).putXml(xmlForm);</pre><br/>',
        "!type": "fn(form: XMLObject) -> SparkHttpResponse"
      },
      putJson: {
        "!doc": 'Perform a HTTP PUT using a JSON form object<br/><b>params</b><br/>form - the HTTP form data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).putJson(jsonForm);</pre><br/>',
        "!type": "fn(form: ?) -> SparkHttpResponse"
      },
      putString: {
        "!doc": 'Perform a HTTP PUT using a string<br/><b>params</b><br/>data - the HTTP PUT data<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getHttp(url).putString(data);</pre><br/>',
        "!type": "fn(data: string) -> SparkHttpResponse"
      },
      delete: {
        "!doc": 'Perform a HTTP DELETE request<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).delete();</pre><br/>',
        "!type": "fn() -> SparkHttpResponse"
      }
    },
    SparkLeaderboardPartition: {
      "!doc": "Represents a single partition of a leaderboard. A partition is also a SparkLeaderboard and can be used wherever a SparkLeaderboard is used.<br/>e.g.<br/>var partition = Spark.getLeaderboards().getLeaderboard(shortCode).getPartitions()[0];<br/>",
      getDescription: {
        "!doc": 'Returns the description of this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var desc = Spark.getLeaderboards().getLeaderboard(shortCode).getDescription();</pre><br/>',
        "!type": "fn() -> string"
      },
      getName: {
        "!doc": 'Returns the name of this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var shortCode = Spark.getLeaderboards().getLeaderboard(shortCode).getName();</pre><br/>',
        "!type": "fn() -> string"
      },
      getShortCode: {
        "!doc": 'Returns the shortCode of this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var shortCode = Spark.getLeaderboards().getLeaderboard(shortCode).getShortCode();</pre><br/>',
        "!type": "fn() -> string"
      },
      getEntryCount: {
        "!doc": 'Returns the total number of entries in this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = Spark.getLeaderboards().getLeaderboard(shortCode).getEntryCount();</pre><br/>',
        "!type": "fn() -> number"
      },
      getEntryCountForIdentifier: {
        "!doc": 'Returns the total number of entries in this leaderboard for the specified identifier.<br/>The later can be the userId of a player or the id of a team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = Spark.getLeaderboards().getLeaderboard(shortCode).getEntryCountForIdentifier("myPlayerId");</pre><br/>',
        "!type": "fn(identifier: string) -> number"
      },
      getEntries: {
        "!doc": 'Returns a cursor over all the entries in this leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = Spark.getLeaderboards().getLeaderboard(shortCode).getEntries();</pre><br/>',
        "!type": "fn() -> SparkLeaderboardCursor"
      },
      getEntries_6: {
        "!doc": 'Returns a cursor over <b>count</b> entries in this leaderboard, starting at <b>offset</b>.<br/><b>params</b><br/>count - the number of entries over which to obtain a cursor.<br/>offset - the number of entries to skip before the start of the cursor.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = Spark.getLeaderboards().getLeaderboard(shortCode).getEntries(mycount, myoffset);</pre><br/>',
        "!type": "fn(count: number, offset: number) -> SparkLeaderboardCursor"
      },
      isPartitioned: {
        "!doc": 'Returns true if this leaderboard has or can have partitions.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var isPartitioned = Spark.getLeaderboards().getLeaderboard(shortCode).isPartitioned();</pre><br/>',
        "!type": "fn() -> bool"
      },
      isPartition: {
        "!doc": 'Returns true if this leaderboard is a single partition of a parent leaderboard.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var isPartitioned = Spark.getLeaderboards().getLeaderboard(shortCode).isPartition();</pre><br/>',
        "!type": "fn() -> bool"
      },
      getPartitions: {
        "!doc": 'Returns an array containing the partitions of this leaderboard if it is partitioned, otherwise an empty array is returned.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var partitions = Spark.getLeaderboards().getLeaderboard(shortCode).getPartitions();</pre><br/>',
        "!type": "fn() -> [SparkLeaderboardPartition]"
      },
      drop: {
        "!doc": 'Deletes this leaderboard partition, removing it from the parent leaderboard and deleting the underling leaderboard data for this partition.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLeaderboards().getLeaderboard(shortCode).getPartitions()[0].drop();</pre><br/>',
        "!type": "fn()"
      },
      drop_11: {
        "!doc": 'See #drop.  Additionally deletes the underlying running total data, resetting any record of players\' scores.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.drop(true);</pre><br/>',
        "!type": "fn(deleteRunningTotalData: bool)"
      },
      archive: {
        "!doc": 'Archives this leaderboard partition.  Players will no longer be able to post new scores to this leaderboard, but the leaderboard is still available to view.<br/>If the leaderboard partition has already been archived calling this has no effect.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLeaderboards().getLeaderboard(shortCode).getPartitions()[0].archive();</pre><br/>',
        "!type": "fn()"
      },
      isArchived: {
        "!doc": 'Returns true if this partition has been archived.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getLeaderboards().getLeaderboard(shortCode).getPartitions()[0].isArchived();</pre><br/>',
        "!type": "fn() -> bool"
      },
      getEntriesForIdentifier: {
        "!doc": 'Returns the array of leaderboard entries that correspond to the supplied identifier and customIdFilter<br/>If the customIdFilter is null, the method returns all the entries in the leaderboard for the suplied identifier<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getEntriesForIdentifier(myPlayerId, {});</pre><br/>',
        "!type": "fn(identifier: string, customIdFilter: ?) -> SparkLeaderboardEntry[]"
      },
      getEntriesFromPlayer: {
        "!doc": 'Returns a cursor over the leaderboard entries starting from the highest score of the supplied playerId<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getEntriesFromPlayer(myPlayerId, 50);</pre><br/>',
        "!type": "fn(playerId: string, count: number) -> SparkLeaderboardCursor"
      },
      getEntriesFromPlayerForCustomId: {
        "!doc": 'Returns a cursor over the leaderboard entries starting from the highest score of the supplied playerId and customIdFilter<br/>If the customId filter is not an object with valid ID fields, it will return an empty cursor<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getEntriesFromPlayerForCustomId(myPlayerId, 50, {carType:"raceCar"});</pre><br/>',
        "!type": "fn(playerId: string, count: number, customIdFilter: ?) -> SparkLeaderboardCursor"
      },
      getIdFields: {
        "!doc": 'Returns the list of custom ID fields that are defined on the leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getIdFields();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      getScoreFields: {
        "!doc": 'Returns the list of fields that are defined on the leaderboard<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.getScoreFields();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      deleteAllEntries: {
        "!doc": 'Deletes all entries from the leaderboard that correspond to this identifier. If your leaderboard has custom IDs set up, <br/>it will delete the entries for all the custom IDs<br/>This method only works for realtime leaderboards<br/>If deleteRunningTotals is true, all running total data for these entries will also be deleted<br/>deleting running totals may affect other leaderbaords using the same running totals<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.deleteEntry(myPlayerId, true);</pre><br/>',
        "!type": "fn(identifier: string, deleteRunningTotals: bool) -> bool"
      },
      deleteEntriesForCustomId: {
        "!doc": 'Deletes the entries from the leaderboard that match the specified customIdFilter.<br/>This method only works for realtime leaderboards<br/>If deleteRunningTotals is true, all running total data for this leaderboard will also be deleted<br/>deleting running totals may affect other leaderbaords using the same running totals<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.deleteEntriesForCustomId(myPlayerId, true, {"carType":"raceCar"});</pre><br/>',
        "!type": "fn(identifier: string, deleteRunningTotals: bool, customIdFilter: ?) -> bool"
      },
      deleteEntry: {
        "!doc": '<b>DEPRECATED use leaderboard.deleteAllEntries(identifier, deleteRunningTotals)<br/> or leaderboard.deleteEntriesForCustomId(identifier, deleteRunningTotals, customIdFilter).</b><br/>Deletes the entry from the leaderboard that correspond to this identifier.<br/>This method is not supported for leaderboards with custom IDs and will throw an java.lang.UnsupportedOperationException<br/>This method only works for realtime leaderboards<br/>If deleteRunningTotals is true, all running total data for these entries will also be deleted<br/>deleting running totals may affect other leaderbaords using the same running totals<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.deleteEntry(myPlayerId, true);</pre><br/>',
        "!type": "fn(identifier: string, deleteRunningTotals: bool) -> bool"
      },
      getPropertySet: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the property set associated with this leaderboard<br/>",
        "!type": "fn() -> ?"
      },
      getRankForScore: {
        "!doc": 'Returns the rank a given score would be at on this Global leaderboard, without it actually being entered into the leaderboard.<br/>Calling this on a Team or Social leaderboard will return null.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var rank = leaderboard.getRankForScore({"score" : 123});</pre><br/>',
        "!type": "fn(score: ?) -> number"
      },
      rebuildLeaderboard: {
        "!doc": 'Drops the current leaderboard and it rebuilds it from the running totals.<br/>The current leaderboard may not have valid ranks for the duration of this process.<br/>You can only rebuild realtime leaderboards. You cannot rebuild partitioned leaderboards, you can only rebuild the individual partitions.<br/>If the flag awardAchievements is set to true, at the end of the rebuild process the appropriate achievements will be awarded<br/>Please use with care, because during the rebuild process any new data coming from the players might temporarily have incorrect ranks<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">leaderboard.rebuildLeaderboard(true);</pre><br/>',
        "!type": "fn(awardAchievements: bool)"
      }
    },
    SparkHttpResponse: {
      "!doc": "Represents the response form the HTTP call.<br/>e.g.<br/>var headers = response.getHeaders();<br/>",
      getHeaders: {
        "!doc": 'Returns the headers from the response.<br/><b>returns</b><br/>A JSON object containing the headers<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).get();</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var headers = response.getHeaders();</pre><br/>',
        "!type": "fn() -> ?"
      },
      getCookies: {
        "!doc": 'Returns values for \'Set-Cookie\' headers in the response.<br/><b>returns</b><br/>A JSON array containing values of the Set-Cookie headers<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).get();</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cookies = response.getCookies();</pre><br/>',
        "!type": "fn() -> ?"
      },
      getResponseCode: {
        "!doc": 'Returns the response code.<br/>e.g. 200<br/><b>returns</b><br/>the HTTP status code<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).get();</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var statusCode = response.getResponseCode();</pre><br/>',
        "!type": "fn() -> number"
      },
      getResponseString: {
        "!doc": 'Returns the body from the response.<br/><b>returns</b><br/>A string representing the body of the response.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).get();</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var body = response.getResponseString();</pre><br/>',
        "!type": "fn() -> string"
      },
      getResponseXml: {
        "!doc": 'Returns the body from the response as XML.<br/><b>returns</b><br/>An XML object representing the body of the response.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).get();</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var body = response.getResponseXml();</pre><br/>',
        "!type": "fn() -> ?"
      },
      getResponseJson: {
        "!doc": 'Returns the body from the response as JSON.<br/><b>returns</b><br/>A JSON object representing the body of the response.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var response = Spark.getHttp(url).get();</pre><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var body = response.getResponseJson();</pre><br/>',
        "!type": "fn() -> ?"
      }
    },
    SparkFiles: {
      "!doc": "Provides access uploaded files along with downloadables<br/>",
      deleteUploadedFile: {
        "!doc": '<b>validity</b> All Scripts<br/>Deletes a previously uploaded file by uploadId<br/><b>params</b><br/>uploadId - the id of the uploaded file<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getFiles().deleteUploadedFile("myUploadId");</pre><br/>',
        "!type": "fn(uploadId: string) -> bool"
      },
      uploadedXml: {
        "!doc": '<b>validity</b> All Scripts<br/>Provides access to an uploaded file via a SparkXmlReader interface<br/><b>params</b><br/>uploadId - the id of the uploaded file<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.getFiles().uploadedXml("myUploadId");</pre><br/>',
        "!type": "fn(uploadId: string) -> SparkXmlReader"
      },
      uploadedJson: {
        "!doc": '<b>validity</b> All Scripts<br/>Provides access to an uploaded file via a JSON object<br/><b>params</b><br/>uploadId - the id of the uploaded file<br/><b>returns</b><br/>A JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.getFiles().uploadedJson("myUploadId");</pre><br/>',
        "!type": "fn(uploadId: string) -> ?"
      },
      downloadableXml: {
        "!doc": '<b>validity</b> All Scripts<br/>Provides access to a downloadable file via a SparkXmlReader interface<br/><b>params</b><br/>shortCode - the short code for the downloadable file<br/><b>returns</b><br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.getFiles().downloadableXml("shortCode");</pre><br/>',
        "!type": "fn(shortCode: string) -> SparkXmlReader"
      },
      downloadableJson: {
        "!doc": '<b>validity</b> All Scripts<br/>Provides access to a downloadable file via a JSON object<br/><b>params</b><br/>shortCode - the short code for the downloadable file<br/><b>returns</b><br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var reader = Spark.getFiles().downloadableJson("shortCode");</pre><br/>',
        "!type": "fn(shortCode: string) -> ?"
      }
    },
    SparkXmlReader: {
      "!doc": 'Provides read only access to an Xml document in gamesparks storage.<br/>e.g.<br/>var myXmlReader = Spark.uploadedXml("7359237762da4245add41e44bc994cdd");<br/>or<br/>var myXmlReader = Spark.downloadableXml("SHORTCODE");<br/>',
      registerCallback: {
        "!doc": 'Registers a function to be called when a given element is found.<br/><b>params</b><br/>path - A dot notated path representing the element to attach to<br/>function - Your javascript function that should be called when the element is found<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">uploadedXml.registerCallback("catalog.book", processBookElement);</pre><br/>',
        "!type": "fn(path: string, startCallback: Function)"
      },
      process: {
        "!doc": 'Processes each document element and triggers any registered callback<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">uploadedXml.process();</pre><br/>',
        "!type": "fn()"
      },
      getElement: {
        "!doc": 'Returns the current element in the document, generally only useful during callbacks<br/>The returned element only contains the element name and any attributes, it does not include children<br/><b>returns</b><br/>The current element<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var element = uploadedXml.element;</pre><br/>',
        "!type": "fn() -> ?"
      },
      getXml: {
        "!doc": 'Returns the current element in the document as a complete xml structure including all children<br/><b>returns</b><br/>The current element as a document<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var element = uploadedXml.xml;</pre><br/>',
        "!type": "fn() -> ?"
      }
    },
    SparkMongoCollectionReadOnly: {
      "!doc": "Provides read only access to a mongo collection.<br/>e.g.<br/>var myMetaCollection = Spark.metaCollection('metatest');<br/>",
      count: {
        "!doc": 'Returns the number of documents in this collection<br/><b>returns</b><br/>the number of documents<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = myMetaCollection.count();</pre><br/>',
        "!type": "fn() -> number"
      },
      count_1: {
        "!doc": 'Returns the number of documents that match the supplied query<br/><b>returns</b><br/>the number of documents<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = Spark.metaCollection(\'metatest\').count({"metafield" : "metavalue"});</pre><br/>',
        "!type": "fn(query: ?) -> number"
      },
      distinct: {
        "!doc": 'Returns a list of distinct values for the given key in the collection<br/><b>params</b><br/>key - the key to use in the query<br/><b>returns</b><br/>an object array<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var keys = Spark.metaCollection(\'metatest\').distinct("metafield");</pre><br/>',
        "!type": "fn(key: string) -> ?"
      },
      distinct_3: {
        "!doc": 'Returns a list of distinct values for the given key in the collection that match the supplied query<br/><b>params</b><br/>key - the key to use in the query<br/>query - the Mongo query<br/><b>returns</b><br/>an object array<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var keys = Spark.metaCollection(\'metatest\').distinct("metafield", {"metafield1":{"$gte" : 5}});</pre><br/>',
        "!type": "fn(key: string, query: ?) -> ?"
      },
      dropIndex: {
        "!doc": 'Drops or removes the specified index from a collection.<br/><b>params</b><br/>keys - the index definition used in ensureIndex.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').dropIndex({"metafield" : 1});</pre><br/>',
        "!type": "fn(keys: ?)"
      },
      dropIndexByName: {
        "!doc": 'Drops or removes the specified index from a collection.<br/><b>params</b><br/>name - the name of the index to drop.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').dropIndexByName("myIndex");</pre><br/>',
        "!type": "fn(name: string)"
      },
      ensureIndex: {
        "!doc": 'Creates an index on the specified fields if the index does not already exist.<br/><b>params</b><br/>keys - the index definition used in ensureIndex.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').ensureIndex({"metafield" : 1, "metafield1" : 1});</pre><br/>',
        "!type": "fn(keys: ?)"
      },
      ensureIndex_7: {
        "!doc": 'Creates an index on the specified fields if the index does not already exist.<br/><b>params</b><br/>keys - the index definition used in ensureIndex.<br/>optionsIN - index options<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').ensureIndex({"metafield" : 1, "metafield1" : 1}, {"name":"myIndex"});</pre><br/>',
        "!type": "fn(keys: ?, optionsIN: ?)"
      },
      find: {
        "!doc": 'Returns a SparkMongoCursor of all documents in this collection<br/><b>params</b><br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').find();</pre><br/>',
        "!type": "fn() -> SparkMongoCursor"
      },
      find_9: {
        "!doc": 'Returns a SparkMongoCursor of all documents in this collection that match the supplied query<br/><b>params</b><br/>query - a Mongo query<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').find({"metatest1" : {"$gt" : 1}});</pre><br/>',
        "!type": "fn(query: ?) -> SparkMongoCursor"
      },
      find_10: {
        "!doc": 'Returns a SparkMongoCursor of all documents in this collection that match the supplied query.<br/>The returned documents only contain the fields supplied in the fieldsToReturn parameter. This reduces the document size when being returned.<br/><b>params</b><br/>query -  a Mongo query<br/>fields - the fields to return<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').find({"metatest1" : {"$gt" : 1}}, {"metatest" : 1});</pre><br/>',
        "!type": "fn(query: ?, fields: ?) -> SparkMongoCursor"
      },
      findOne: {
        "!doc": 'Returns the first document from the collection according to natural order (which reflects the order of documents on the disk)<br/><b>returns</b><br/>A JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').findOne();</pre><br/>',
        "!type": "fn() -> ?"
      },
      findOne_12: {
        "!doc": 'Returns one document that satisfies the specified query criteria.<br/>If multiple documents satisfy the query, this method returns the first document according to the natural order which reflects the order of documents on the disk.<br/><b>params</b><br/>query - a Mongo query<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var result = Spark.metaCollection(\'metatest\').findOne({"metatest1" : {"$gt" : 1}}</pre><br/>',
        "!type": "fn(query: ?) -> ?"
      },
      findOne_13: {
        "!doc": 'Returns one document that satisfies the specified query criteria.<br/>If multiple documents satisfy the query, this method returns the first document according to the natural order which reflects the order of documents on the disk.<br/>The returned documents only contain the fields supplied in the fieldsToReturn parameter. This reduces the document size when being returned.<br/><b>params</b><br/>query - a Mongo query<br/>fields - the fields to return<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var result = Spark.metaCollection(\'metatest\').findOne({"metatest1" : {"$gt" : 1}}, {"metatest" : 1});</pre><br/>',
        "!type": "fn(query: ?, fields: ?) -> ?"
      },
      findOne_14: {
        "!doc": 'Returns one document that satisfies the specified query criteria.<br/>If multiple documents satisfy the query, this method returns the first document according to the natural order which reflects the order of documents on the disk.<br/>The returned documents only contain the fields supplied in the fieldsToReturn parameter. This reduces the document size when being returned.<br/><b>params</b><br/>query - a Mongo query<br/>fields - the fields to return<br/>orderBy - the order clause<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var result = Spark.metaCollection(\'metatest\').findOne({"metatest1" : {"$gt" : 1}}, {"metatest" : 1});</pre><br/>',
        "!type": "fn(query: ?, fields: ?, orderBy: ?) -> ?"
      },
      aggregate: {
        "!doc": "<br/>",
        "!type": "fn(firstOp: ?, additionalOps: [?]) -> ?"
      },
      getIndexInfo: {
        "!doc": 'Return a list of the indexes for this collection. Each object in the list is the "info document" from MongoDB<br/><b>returns</b><br/>list of index documents<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var indexes = Spark.metaCollection(\'metatest\').getIndexInfo();</pre><br/>',
        "!type": "fn() -> ?"
      },
      getLastError: {
        "!doc": 'Gets the error (if there is one) from the previous operation on this connection.<br/><b>returns</b><br/>a JSON object with error and status information<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var errors = Spark.metaCollection(\'metatest\').getLastError();</pre><br/>',
        "!type": "fn() -> ?"
      }
    },
    SparkProperties: {
      "!doc": "Provides access to the properties for the current game.<br/>var properties = Spark.getProperties();<br/>",
      getProperty: {
        "!doc": 'Returns the property with the given shortCode, as JSON<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var property = Spark.getProperties().getProperty(propertyShortCode);</pre><br/>',
        "!type": "fn(propertyShortCode: string) -> ?"
      },
      getPropertySet: {
        "!doc": 'Returns the property set with the given shortCode, as JSON<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var propertySet = Spark.getProperties().getPropertySet(propertySetShortCode);</pre><br/>',
        "!type": "fn(propertySetShortCode: string) -> ?"
      }
    },
    SparkMongoCollectionReadWrite: {
      "!doc": "Provides read write access to a mongo collection.<br/>All methods defined in SparkMongoCollectionReadOnly are available in this object along with those listed below.<br/>e.g.<br/>var myRuntimeCollection = Spark.runtimeCollection('runtimetest');<br/>",
      count: {
        "!doc": 'Returns the number of documents in this collection<br/><b>returns</b><br/>the number of documents<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = myMetaCollection.count();</pre><br/>',
        "!type": "fn() -> number"
      },
      count_1: {
        "!doc": 'Returns the number of documents that match the supplied query<br/><b>returns</b><br/>the number of documents<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = Spark.metaCollection(\'metatest\').count({"metafield" : "metavalue"});</pre><br/>',
        "!type": "fn(query: ?) -> number"
      },
      distinct: {
        "!doc": 'Returns a list of distinct values for the given key in the collection<br/><b>params</b><br/>key - the key to use in the query<br/><b>returns</b><br/>an object array<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var keys = Spark.metaCollection(\'metatest\').distinct("metafield");</pre><br/>',
        "!type": "fn(key: string) -> ?"
      },
      distinct_3: {
        "!doc": 'Returns a list of distinct values for the given key in the collection that match the supplied query<br/><b>params</b><br/>key - the key to use in the query<br/>query - the Mongo query<br/><b>returns</b><br/>an object array<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var keys = Spark.metaCollection(\'metatest\').distinct("metafield", {"metafield1":{"$gte" : 5}});</pre><br/>',
        "!type": "fn(key: string, query: ?) -> ?"
      },
      dropIndex: {
        "!doc": 'Drops or removes the specified index from a collection.<br/><b>params</b><br/>keys - the index definition used in ensureIndex.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').dropIndex({"metafield" : 1});</pre><br/>',
        "!type": "fn(keys: ?)"
      },
      dropIndexByName: {
        "!doc": 'Drops or removes the specified index from a collection.<br/><b>params</b><br/>name - the name of the index to drop.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').dropIndexByName("myIndex");</pre><br/>',
        "!type": "fn(name: string)"
      },
      ensureIndex: {
        "!doc": 'Creates an index on the specified fields if the index does not already exist.<br/><b>params</b><br/>keys - the index definition used in ensureIndex.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').ensureIndex({"metafield" : 1, "metafield1" : 1});</pre><br/>',
        "!type": "fn(keys: ?)"
      },
      ensureIndex_7: {
        "!doc": 'Creates an index on the specified fields if the index does not already exist.<br/><b>params</b><br/>keys - the index definition used in ensureIndex.<br/>optionsIN - index options<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.metaCollection(\'metatest\').ensureIndex({"metafield" : 1, "metafield1" : 1}, {"name":"myIndex"});</pre><br/>',
        "!type": "fn(keys: ?, optionsIN: ?)"
      },
      find: {
        "!doc": 'Returns a SparkMongoCursor of all documents in this collection<br/><b>params</b><br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').find();</pre><br/>',
        "!type": "fn() -> SparkMongoCursor"
      },
      find_9: {
        "!doc": 'Returns a SparkMongoCursor of all documents in this collection that match the supplied query<br/><b>params</b><br/>query - a Mongo query<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').find({"metatest1" : {"$gt" : 1}});</pre><br/>',
        "!type": "fn(query: ?) -> SparkMongoCursor"
      },
      find_10: {
        "!doc": 'Returns a SparkMongoCursor of all documents in this collection that match the supplied query.<br/>The returned documents only contain the fields supplied in the fieldsToReturn parameter. This reduces the document size when being returned.<br/><b>params</b><br/>query -  a Mongo query<br/>fields - the fields to return<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').find({"metatest1" : {"$gt" : 1}}, {"metatest" : 1});</pre><br/>',
        "!type": "fn(query: ?, fields: ?) -> SparkMongoCursor"
      },
      findOne: {
        "!doc": 'Returns the first document from the collection according to natural order (which reflects the order of documents on the disk)<br/><b>returns</b><br/>A JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = Spark.metaCollection(\'metatest\').findOne();</pre><br/>',
        "!type": "fn() -> ?"
      },
      findOne_12: {
        "!doc": 'Returns one document that satisfies the specified query criteria.<br/>If multiple documents satisfy the query, this method returns the first document according to the natural order which reflects the order of documents on the disk.<br/><b>params</b><br/>query - a Mongo query<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var result = Spark.metaCollection(\'metatest\').findOne({"metatest1" : {"$gt" : 1}}</pre><br/>',
        "!type": "fn(query: ?) -> ?"
      },
      findOne_13: {
        "!doc": 'Returns one document that satisfies the specified query criteria.<br/>If multiple documents satisfy the query, this method returns the first document according to the natural order which reflects the order of documents on the disk.<br/>The returned documents only contain the fields supplied in the fieldsToReturn parameter. This reduces the document size when being returned.<br/><b>params</b><br/>query - a Mongo query<br/>fields - the fields to return<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var result = Spark.metaCollection(\'metatest\').findOne({"metatest1" : {"$gt" : 1}}, {"metatest" : 1});</pre><br/>',
        "!type": "fn(query: ?, fields: ?) -> ?"
      },
      findOne_14: {
        "!doc": 'Returns one document that satisfies the specified query criteria.<br/>If multiple documents satisfy the query, this method returns the first document according to the natural order which reflects the order of documents on the disk.<br/>The returned documents only contain the fields supplied in the fieldsToReturn parameter. This reduces the document size when being returned.<br/><b>params</b><br/>query - a Mongo query<br/>fields - the fields to return<br/>orderBy - the order clause<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var result = Spark.metaCollection(\'metatest\').findOne({"metatest1" : {"$gt" : 1}}, {"metatest" : 1});</pre><br/>',
        "!type": "fn(query: ?, fields: ?, orderBy: ?) -> ?"
      },
      findAndModify: {
        "!doc": 'Calls findAndModify(query, fields, sort, remove, update, returnNew, upsert) with fields=null, remove=false, returnNew=false, upsert=false, sort=null<br/><b>params</b><br/>query - Specifies the selection criteria for the modification. The query field employs the same query selectors as used in the find() method. Although the query may match multiple documents, findAndModify will only select one document to modify.<br/>update -  Must specify either the remove or the update field in the findAndModify command. The update field employs the same update operators or field: value specifications to modify the selected document.<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var doc = myRuntimeCollection.findAndModify({"field" : "value"}, {"field" : 1}, {"field" : "value1"});</pre><br/>',
        "!type": "fn(query: ?, update: ?) -> ?"
      },
      findAndModify_16: {
        "!doc": 'Calls findAndModify(query, fields, sort, remove, update, returnNew, upsert) with fields=null, remove=false, returnNew=false, upsert=false<br/><b>params</b><br/>query - Specifies the selection criteria for the modification. The query field employs the same query selectors as used in the find() method. Although the query may match multiple documents, findAndModify will only select one document to modify.<br/>sort - Determines which document the operation will modify if the query selects multiple documents. findAndModify will modify the first document in the sort order specified by this argument.<br/>update -  Must specify either the remove or the update field in the findAndModify command. The update field employs the same update operators or field: value specifications to modify the selected document.<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var doc = myRuntimeCollection.findAndModify({"field" : "value"},{"field" : 1}, {"field" : "value1"});</pre><br/>',
        "!type": "fn(query: ?, sort: ?, update: ?) -> ?"
      },
      findAndModify_17: {
        "!doc": 'Atomically modifies and returns a single document. By default, the returned document does not include the modifications made on the update. To return the document with the modifications made on the update, use the returnNew option.<br/><b>params</b><br/>query - specifies the selection criteria for the modification. The query field employs the same query selectors as used in the find() method. Although the query may match multiple documents, findAndModify will only select one document to modify.<br/>fields - the fields to return<br/>sort - determines which document the operation will modify if the query selects multiple documents. findAndModify will modify the first document in the sort order specified by this argument.<br/>remove - must specify either the remove or the update field in the findAndModify command. When true, removes the selected document. The default is false.<br/>update -  must specify either the remove or the update field in the findAndModify command. The update field employs the same update operators or field: value specifications to modify the selected document.<br/>returnNew - when true, returns the modified document rather than the original. The findAndModify method ignores the new option for remove operations. The default is false.<br/>upsert - used in conjunction with the update field. When true, the findAndModify command creates a new document if the query returns no documents. The default is false.<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var doc = myRuntimeCollection.findAndModify({"field" : "value"},{"field" : 1},false,{"field" : "value1"},true, {"field" : 1},false);</pre><br/>',
        "!type": "fn(query: ?, fields: ?, sort: ?, remove: bool, update: ?, returnNew: bool, upsert: bool) -> ?"
      },
      findAndRemove: {
        "!doc": 'Calls findAndModify(query, fields, sort, remove, update, returnNew, upsert) with  fields=null, sort=null, remove=true, returnNew=false, upsert=false<br/><b>params</b><br/>query - a Mongo query<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var doc = myRuntimeCollection.findAndRemove({"field" : "value"});</pre><br/>',
        "!type": "fn(query: ?) -> ?"
      },
      insert: {
        "!doc": 'Inserts a document or documents into a collection.<br/><b>params</b><br/>documents - A document or array of documents to insert into the collection.<br/><b>returns</b><br/>true if the operation was successful<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = myRuntimeCollection.insert({"field" : "value"}, {"field" : "value1"}, {"field" : "value2"});</pre><br/>',
        "!type": "fn(documents: [?]) -> bool"
      },
      aggregate: {
        "!doc": "<br/>",
        "!type": "fn(firstOp: ?, additionalOps: [?]) -> ?"
      },
      applyChanges: {
        "!doc": "Generates the correct mongo update command to set and unset fields so the mongo record matches the newDocument.<br/>This can greatly increase performance in documents where only a small amount of change has been made as only the required fields are modified.<br/>If the existing document is null, the new document is inserted directly into the collection<br/><b>params</b><br/>existingDocument - A document perviously retrieved from the database. The _id field of this document will be used to determine which document to update. If the document passed has no _id the call will fail.<br/>newDocument - The new state to persist in the database, and _id field in this document will be ignored.<br/><b>returns</b><br/>true if the operation was successful<br/>",
        "!type": "fn(existingDocument: ?, newDocument: ?) -> bool"
      },
      getIndexInfo: {
        "!doc": 'Return a list of the indexes for this collection. Each object in the list is the "info document" from MongoDB<br/><b>returns</b><br/>list of index documents<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var indexes = Spark.metaCollection(\'metatest\').getIndexInfo();</pre><br/>',
        "!type": "fn() -> ?"
      },
      getLastError: {
        "!doc": 'Gets the error (if there is one) from the previous operation on this connection.<br/><b>returns</b><br/>a JSON object with error and status information<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var errors = Spark.metaCollection(\'metatest\').getLastError();</pre><br/>',
        "!type": "fn() -> ?"
      },
      save: {
        "!doc": 'Updates an existing document or inserts a new document, depending on its document parameter.<br/>If the document does not contain an _id field, then the save() method performs an insert. During the operation, mongo will add to the document the _id field and assign it a unique ObjectId.<br/>If the document contains an _id field, then the save() method performs an upsert, querying the collection on the _id field. If a document does not exist with the specified _id value, the save() method performs an insert. If a document exists with the specified _id value, the save() method performs an update that replaces all fields in the existing document with the fields from the document.<br/><b>params</b><br/>document - the document to save<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = myRuntimeCollection.save({"field" : "value"});</pre><br/>',
        "!type": "fn(document: ?) -> bool"
      },
      remove: {
        "!doc": 'Removes any document from the collection that matches the supplied query.<br/>Return a boolean indicating whether the remove was successful.<br/><b>params</b><br/>query - the query<br/><b>returns</b><br/>true if the operation was successful<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = myRuntimeCollection.remove({"field" : "value"});</pre><br/>',
        "!type": "fn(query: ?) -> bool"
      },
      drop: {
        "!doc": 'Drop the collection<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">myRuntimeCollection.drop();</pre><br/>',
        "!type": "fn()"
      },
      update: {
        "!doc": 'Calls update(query, update, upsert, multi) with upsert=false and multi=false<br/><b>params</b><br/>query - query (document) The selection criteria for the update. Use the same query selectors as used in the find() method<br/>update - update (document) The modifications to apply. For details see Update Parameter<br/><b>returns</b><br/>true if the operation was successful<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = myRuntimeCollection.update({"field" : "value"}, {"field" : "value1"});</pre><br/>',
        "!type": "fn(query: ?, update: ?) -> bool"
      },
      update_28: {
        "!doc": 'Modifies an existing document or documents in a collection. The method can modify specific fields of existing document or documents or replace an existing document entirely, depending on the update parameter.<br/>By default, the update() method updates a single document. If the multi option is set to true, the method updates all documents that match the query criteria.<br/><b>params</b><br/>query - query (document) The selection criteria for the update. Use the same query selectors as used in the find() method<br/>update - update (document) The modifications to apply. For details see Update Parameter<br/>upsert - if set to true, creates a new document when no document matches the query criteria. The default value is false, which does not insert a new document when no match is found<br/>multi - multi (boolean) Optional. If set to true, updates multiple documents that meet the query criteria. If set to false, updates one document. The default value is false. For additional information, see Multi Parameter<br/><b>returns</b><br/>true if the operation was successful<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = myRuntimeCollection.update({"field" : "value"}, {"field" : "value1"}, false, false);</pre><br/>',
        "!type": "fn(query: ?, update: ?, upsert: bool, multi: bool) -> bool"
      },
      updateMulti: {
        "!doc": 'Calls update(query, update, upsert, multi) with upsert=false and multi=true<br/><b>params</b><br/>query - query (document) The selection criteria for the update. Use the same query selectors as used in the find() method<br/>update - update (document) The modifications to apply. For details see Update Parameter<br/><b>returns</b><br/>true if the operation was successful<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = myRuntimeCollection.updateMulti({"field" : "value"}, {"field" : "value1"});</pre><br/>',
        "!type": "fn(query: ?, update: ?) -> bool"
      }
    },
    SparkMongoCursor: {
      "!doc": "An iterator over database results. Doing a find() query on a collection returns a SparkMongoCursor thus:<br/>var cursor = collection.find( query ); if( cursor.hasNext() ) {var obj = cursor.next();}<br/>",
      limit: {
        "!doc": 'Limits the number of elements returned.<br/><b>params</b><br/>count - the limit to set<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = collection.find( query ).skip( 1000 ).limit( 100 );</pre><br/>',
        "!type": "fn(count: number) -> SparkMongoCursor"
      },
      skip: {
        "!doc": 'Discards a given number of elements at the beginning of the cursor.<br/><b>params</b><br/>count - the limit to set<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = collection.find( query ).skip( 1000 ).limit( 100 );</pre><br/>',
        "!type": "fn(count: number) -> SparkMongoCursor"
      },
      size: {
        "!doc": 'Counts the number of objects matching the query this does take limit/skip into consideration.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var size = collection.find( query ).size();</pre><br/>',
        "!type": "fn() -> number"
      },
      count: {
        "!doc": 'Counts the number of objects matching the query this does take limit/skip into consideration.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var count = collection.find( query ).count();</pre><br/>',
        "!type": "fn() -> number"
      },
      sort: {
        "!doc": 'Sorts this cursor\'s elements. This method must be called before getting any object from the cursor.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = collection.find( query ).sort( {"field" : 1} ).limit( 100 )</pre><br/>',
        "!type": "fn(orderBy: ?) -> SparkMongoCursor"
      },
      hasNext: {
        "!doc": 'Checks if there is another object available.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = collection.find( query ); if( cursor.hasNext() ) {var obj = cursor.next();}</pre><br/>',
        "!type": "fn() -> bool"
      },
      next: {
        "!doc": 'Returns the object the cursor is at and moves the cursor ahead by one.<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = collection.find( query ); if( cursor.hasNext() ) {var obj = cursor.next();}</pre><br/>',
        "!type": "fn() -> ?"
      },
      curr: {
        "!doc": 'Returns the element the cursor is at.<br/><b>returns</b><br/>a JSON object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cursor = collection.find( query ); if( cursor.hasNext() ) {cursor.next(); var obj = cursor.curr();}</pre><br/>',
        "!type": "fn() -> ?"
      }
    },
    SparkTeam: {
      "!doc": "Provides access to an instance of a team<br/>e.g.<br/>var team = Spark.getTeams().getTeam(myTeamId);<br/>",
      getOwnerId: {
        "!doc": 'Gets the playerId of the player who owns this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var ownerId = Spark.getTeams().getTeam(myTeamId).getOwnerId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getTeamId: {
        "!doc": 'Gets the teamId of this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var teamId = Spark.getTeams().getTeam(myTeamId).getTeamId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getTeamName: {
        "!doc": 'Gets the name of this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var teamName = Spark.getTeams().getTeam(myTeamId).getTeamName();</pre><br/>',
        "!type": "fn() -> string"
      },
      getTeamType: {
        "!doc": 'Gets the teamType of this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var teamType = Spark.getTeams().getTeam(myTeamId).getTeamType();</pre><br/>',
        "!type": "fn() -> string"
      },
      getMemberIds: {
        "!doc": 'Gets an array containing the playerIds of the members of this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var memberIds = Spark.getTeams().getTeam(myTeamId).getMemberIds();</pre><br/>',
        "!type": "fn() -> [string]"
      },
      setOwnerId: {
        "!doc": 'Updates the ownerId of this team.<br/>Returns true if the ownerId was successfully updated, otherwise false.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = Spark.getTeams().getTeam(myTeamId).setOwnerId(newOwnerId);</pre><br/>',
        "!type": "fn(playerId: string) -> bool"
      },
      setTeamName: {
        "!doc": 'Sets the name of this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = Spark.getTeams().getTeam(myTeamId).setTeamName("TeamName");</pre><br/>',
        "!type": "fn(teamName: string) -> bool"
      },
      addMembers: {
        "!doc": 'Adds the given playerIds as members to this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getTeams().getTeam(myTeamId).addMembers(myPlayerId1, myPlayerId2);</pre><br/>',
        "!type": "fn(playerIds: [string])"
      },
      removeMembers: {
        "!doc": 'Removes the given playerIds from the list of members of this team.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getTeams().getTeam(myTeamId).removeMembers(myPlayerId1, myPlayerId2);</pre><br/>',
        "!type": "fn(playerIds: [string])"
      },
      drop: {
        "!doc": 'Drops this team instance, deleting the underlying team data.<br/>Returns true if the team has been dropped.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = Spark.getTeams().getTeam(myTeamId).drop();</pre><br/>',
        "!type": "fn() -> bool"
      },
      listChatMessages: {
        "!doc": 'Lists the last <pre>count</pre> chat messages for this team, starting from the <pre>offset</pre>th message, most recent first.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var history = Spark.getTeams().getTeam(myTeamId).listChatMessages(50, 0);</pre><br/>',
        "!type": "fn(count: number, offset: number) -> [ChatMessage]"
      },
      getChatMessage: {
        "!doc": 'Get a message from the chat history by its id.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var message = Spark.getTeams().getTeam(myTeamId).getChatMessage(chatMessageId);</pre><br/>',
        "!type": "fn(chatMessageId: string) -> ?"
      },
      deleteChatMessage: {
        "!doc": 'Delete a message from the chat history by its id.<br/>Returns true if the message has been removed from the chat history.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = Spark.getTeams().getTeam(myTeamId).deleteChatMessage(chatMessageId);</pre><br/>',
        "!type": "fn(chatMessageId: string) -> bool"
      },
      addAchievement: {
        "!doc": 'Add an achievement to this team (and its players).<br/>Returns true if the achievement was added to the team or any of its players.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = Spark.getTeams().getTeam(myTeamId).addAchievement(achievementShortCode);</pre><br/>',
        "!type": "fn(achievementShortCode: string) -> bool"
      },
      removeAchievement: {
        "!doc": 'Remove an achievement from this team (and its players).<br/>Returns true if the achievement was removed from the team or any of its players.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var success = Spark.getTeams().getTeam(myTeamId).removeAchievement(achievementShortCode);</pre><br/>',
        "!type": "fn(achievementShortCode: string) -> bool"
      }
    },
    SendGrid: {
      "!doc": 'Provides the ability to send emails via SendGrid.<br/>You need to have already set up a SendGrid account, when acessing send grid via gamesparks you need to provide your sendgrid username & password<br/>e.g.<br/>var mySendGrid = Spark.sendGrid("userName", "password");<br/>',
      addTo: {
        "!doc": 'Adds a recipient to this email<br/><b>params</b><br/>email - The email address of the recipient<br/>query - The name of the recipient (optional)<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.addTo("info@gamesparks.com", "GameSparks")</pre><br/>',
        "!type": "fn(email: string, name: string) -> SendGrid"
      },
      send: {
        "!doc": 'Sends this email, this step should be performed after configuring the email fully<br/><b>returns</b><br/>The response from SendGrid<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.send();</pre><br/>',
        "!type": "fn() -> string"
      },
      setFrom: {
        "!doc": 'Sets the from address of this email<br/><b>params</b><br/>email - The email address of the sender<br/>query - The name of the sender (optional)<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.setFrom("info@gamesparks.com", "GameSparks")</pre><br/>',
        "!type": "fn(email: string, name: string) -> SendGrid"
      },
      setReplyTo: {
        "!doc": 'Sets the replyTo address of this email<br/><b>params</b><br/>email - The email address to replyTo<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.setReplyTo("info@gamesparks.com")</pre><br/>',
        "!type": "fn(email: string) -> SendGrid"
      },
      setBcc: {
        "!doc": 'Sets a bcc address to this email. SendGrid only allows one address in this field<br/><b>params</b><br/>email - The email address to add as bcc<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.setBcc("info@gamesparks.com")</pre><br/>',
        "!type": "fn(bcc: string) -> SendGrid"
      },
      setSubject: {
        "!doc": 'Sets the subject of this email<br/><b>params</b><br/>subject - The subject of the email<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.setSubject("Hello from GameSparks")</pre><br/>',
        "!type": "fn(subject: string) -> SendGrid"
      },
      setText: {
        "!doc": 'Sets the text body of this email. If html is set this value is ignored.<br/><b>params</b><br/>text - The body of the email<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.setText("Welcome to using SendGrid via GameSparks")</pre><br/>',
        "!type": "fn(text: string) -> SendGrid"
      },
      setHtml: {
        "!doc": 'Sets the html body of this email.<br/><b>params</b><br/>html - The html body of the email<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.setHtml("&lt;b>Welcome to using SendGrid via GameSparks&lt;/b>")</pre><br/>',
        "!type": "fn(html: string) -> SendGrid"
      },
      addUploaded: {
        "!doc": 'Adds an uploaded file to the email as an attachment<br/><b>params</b><br/>uploadId - The id of the uploaded file<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.addUploaded("7359237762da4245add41e44bc994cdd")</pre><br/>',
        "!type": "fn(uploadId: string) -> SendGrid"
      },
      addDownloadable: {
        "!doc": 'Adds an downloadable file to the email as an attachment<br/><b>params</b><br/>shortCode - The shortCode of the downloadable<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.addDownloadable("SHORTCODE")</pre><br/>',
        "!type": "fn(shortCode: string) -> SendGrid"
      },
      addHeader: {
        "!doc": 'Adds an custom SMTP header to this email<br/><b>params</b><br/>name - The header name to set<br/>value - The value to set for the header<br/><b>returns</b><br/>This SendGrid object<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">mySendGrid.addHeader("X-Sent-Using", "SendGrid-API")</pre><br/>',
        "!type": "fn(key: string, value: string) -> SendGrid"
      }
    },
    SparkBulkScheduler: {
      "!doc": "Provides access to the bulk scheduler.<br/>var bulkScheduler = Spark.getBulkScheduler();<br/>",
      submitJobModule: {
        "!doc": '<b>validity</b> All Scripts<br/>Submit a job to be executed by running a Cloud Code module.<br/><b>params</b><br/>playerQuery - A query to be run against the player collection to identify the players to execute against<br/>module - A Cloud Code module short code, to be executed against each player<br/>data - Data to be passed in to the Cloud Code module<br/>delaySeconds - The number of seconds in the future to execute the job<br/><b>returns</b><br/>The jobId if the job was accepted, or null<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var jobId = Spark.getBulkScheduler().submitJobModule(query, module, data, delaySeconds);</pre><br/>',
        "!type": "fn(playerQuery: ?, module: string, data: ?, delaySeconds: number) -> string"
      },
      submitJobScript: {
        "!doc": '<b>validity</b> All Scripts<br/>Submit a job to be executed by running an ad-hoc script.<br/><b>params</b><br/>playerQuery - A query to be run against the player collection to identify the players to execute against<br/>script - A Cloud Code script to be executed against each player<br/>data - Data to be passed in to the script<br/>delaySeconds - The number of seconds in the future to execute the job<br/><b>returns</b><br/>The jobId if the job was accepted, or null<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var jobId = Spark.getBulkScheduler().submitJobScript(query, script, data, delaySeconds);</pre><br/>',
        "!type": "fn(playerQuery: ?, script: string, data: ?, delaySeconds: number) -> string"
      },
      cancelJob: {
        "!doc": '<b>validity</b> All Scripts<br/>Cancel a previously scheduled bulk job.<br/><b>params</b><br/>jobId - The ID of the job to cancel<br/><b>returns</b><br/>true if the job was cancelled, false otherwise<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cancelled = Spark.getBulkScheduler().cancelJob(jobIdToCancel);</pre><br/>',
        "!type": "fn(jobId: string) -> bool"
      },
      listBulkJobs: {
        "!doc": '<b>validity</b> All Scripts<br/>List previously scheduled bulk jobs.<br/><b>params</b><br/>jobIds - The IDs of the jobs to list, or null to list all pending jobs<br/><b>returns</b><br/>An array of bulk jobs<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var cancelled = Spark.getBulkScheduler().listBulkJobs(null);</pre><br/>',
        "!type": "fn(jobIds: [string]) -> SparkBulkJob[]"
      }
    },
    SparkConfig: {
      "!doc": "Contains configuration information for the game<br/>",
      getStage: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the stage (preview or live) the game is running on<br/>",
        "!type": "fn() -> string"
      },
      getApiKey: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the apiKey of the game<br/>",
        "!type": "fn() -> string"
      },
      getVirtualGoods: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of the Virtual Goods configured against the game<br/>",
        "!type": "fn() -> ?"
      },
      getVirtualGood: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the virtual good with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkVirtualGood"
      },
      getAchievements: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of the Achievements configured against the game<br/>",
        "!type": "fn() -> ?"
      },
      getAchievement: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the achievement with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkAchievement"
      },
      getSegments: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of the Segments configured against the game<br/>",
        "!type": "fn() -> ?"
      },
      getSegment: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the segment with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkSegmentType"
      },
      getTeams: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of the Teams configured against the game<br/>",
        "!type": "fn() -> ?"
      },
      getTeam: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the team with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkTeamType"
      },
      getChallenges: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of the Challenges configured against the game<br/>",
        "!type": "fn() -> ?"
      },
      getChallenge: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the challenge with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkChallengeType"
      },
      getDownloadable: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the downloadable with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkDownloadable"
      },
      getDownloadables: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of all the downloadables configured for this game<br/>",
        "!type": "fn() -> [SparkDownloadable]"
      },
      getMatchConfigs: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of the match configurations for the game<br/>",
        "!type": "fn() -> ?"
      },
      getMatchConfig: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the match configuration with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkMatchConfig"
      },
      getCurrencies: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of the custom currency configurations for the game<br/>",
        "!type": "fn() -> ?"
      },
      getCurrency: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the custom currency configuration with the supplied short code<br/>",
        "!type": "fn(shortCode: string) -> SparkCurrency"
      }
    },
    SparkMultiplayer: {
      "!doc": "Provides access to the platform's multiplayer capabilities.<br/>e.g.<br/>var multiplayer = Spark.getMultiplayer();<br/>",
      createMatch: {
        "!doc": '<b>validity</b> All Scripts<br/>Create a match between the given players.<br/><b>params</b><br/>players - An array of players to include in the match<br/><b>returns</b><br/>The matchId if a match was successfully created, or null<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var matchId = Spark.getMultiplayer().createMatch(player1, player2);</pre><br/>',
        "!type": "fn(players: [SparkPlayer]) -> string"
      },
      createMatchById: {
        "!doc": '<b>validity</b> All Scripts<br/>Create a match between the players for the given playerIds.<br/><b>params</b><br/>playerIds - An array of playerIds to include in the match<br/><b>returns</b><br/>The matchId if a match was successfully created, or null<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var matchId = Spark.getMultiplayer().createMatchById(playerId1, playerId2);</pre><br/>',
        "!type": "fn(playerIds: [string]) -> string"
      },
      createMatchWithMatchId: {
        "!doc": '<b>validity</b> All Scripts<br/>Create a match between the given players, using the given matchId.<br/><b>params</b><br/>matchId - The matchId to use when creating this match<br/>players - An array of players to include in the match<br/><b>returns</b><br/>The matchId if a match was successfully created, or null<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var matchId = Spark.getMultiplayer().createMatchWithMatchId("myId", player1, player2);</pre><br/>',
        "!type": "fn(matchId: string, players: [SparkPlayer]) -> string"
      },
      createMatchByIdWithMatchId: {
        "!doc": '<b>validity</b> All Scripts<br/>Create a match between the players for the given playerIds, using the given matchId.<br/><b>params</b><br/>matchId - The matchId to use when creating this match<br/>playerIds - An array of playerIds to include in the match<br/><b>returns</b><br/>The matchId if a match was successfully created, or null<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var matchId = Spark.getMultiplayer().createMatchById("myId", playerId1, playerId2);</pre><br/>',
        "!type": "fn(matchId: string, playerIds: [string]) -> string"
      },
      loadMatch: {
        "!doc": '<b>validity</b> All Scripts<br/>Load the match with the given matchId<br/><b>params</b><br/>matchId - The id of the match to load<br/><b>returns</b><br/>The match if a match was found with the given id<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var matchId = Spark.getMultiplayer().loadMatch(matchId);</pre><br/>',
        "!type": "fn(matchId: string) -> SparkMatch"
      },
      getMatchConfig: {
        "!doc": '<b>validity</b> All Scripts<br/>Load the match configuration for the given shortCode<br/><b>params</b><br/>shortCode - The shortCode of the match configuration to load<br/><b>returns</b><br/>The match configuration if a one was found with the given shortCode<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var matchConfig = Spark.getMultiplayer().getMatchConfig(shortCode);</pre><br/>',
        "!type": "fn(shortCode: string) -> SparkMatchConfig"
      },
      loadPendingMatchById: {
        "!doc": '<b>validity</b> All Scripts<br/>Load the pending match with the given pendingMatchId<br/><b>params</b><br/>pendingMatchId - The id of the pending match to load<br/><b>returns</b><br/>The pending match if one was found with the given id<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var pendingMatch = Spark.getMultiplayer().loadPendingMatchById(pendingMatchId);</pre><br/>',
        "!type": "fn(pendingMatchId: string) -> PendingMatch"
      },
      loadPendingMatchByPlayer: {
        "!doc": '<b>validity</b> All Scripts<br/>Load the pending match containing the given player for the match shortCode and match group.<br/><b>params</b><br/>player - A player within the pending match<br/>shortCode - The shortCode of the match configuration for the pending match<br/>matchGroup - The matchGroup for the pending match<br/><b>returns</b><br/>The pending match if one was found with the given id<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var pendingMatch = Spark.getMultiplayer().loadPendingMatchByPlayer(player, matchShortCode, matchGroup);</pre><br/>',
        "!type": "fn(player: SparkPlayer, shortCode: string, matchGroup: string) -> PendingMatch"
      },
      cancelMatchmaking: {
        "!doc": '<b>validity</b> All Scripts<br/>Cancel matchmaking for the given player, match shortCode and match group.<br/><b>params</b><br/>player - A player within a pending match<br/>shortCode - The shortCode of the match configuration for the pending match<br/>matchGroup - The matchGroup for the pending match<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">Spark.getMultiplayer().cancelMatchmaking(player, matchShortCode, matchGroup);</pre><br/>',
        "!type": "fn(player: SparkPlayer, shortCode: string, matchGroup: string)"
      }
    },
    SparkScriptOptions: {
      "!doc": "Contains configuration information for cloud code scripts<br/>",
      getMaintainDbDates: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns whether dates retrieved from the database will be converted into JS Dates or longs<br/>",
        "!type": "fn() -> bool"
      },
      setMaintainDbDates: {
        "!doc": "<b>validity</b> All Scripts<br/>Sets whether dates retrieved from the database will be converted into JS Dates or longs<br/>",
        "!type": "fn(maintainDbDates: bool)"
      }
    },
    SparkTeams: {
      "!doc": "Provides access to teams for the current game.<br/>e.g.<br/>var team = Spark.getTeams().getTeam(myTeamId);<br/>",
      getTeam: {
        "!doc": 'Returns a SparkTeam object that represents the team with the given teamId.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var team = Spark.getTeams().getTeam(myTeamId);</pre><br/>',
        "!type": "fn(teamId: string) -> SparkTeam"
      },
      getTeamByOwnerIdAndTeamType: {
        "!doc": 'Returns an array of SparkTeam objects for the given ownerId and teamType.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var teams = Spark.getTeams().getTeamByOwnerIdAndTeamType(myOwnerId, myTeamType);</pre><br/>',
        "!type": "fn(ownerId: string, teamType: string) -> [SparkTeam]"
      }
    },
    SparkAchievement: {
      "!doc": "Contains configuration information for the achievement<br/>The methods in this class respect the segments of the current player when being executed<br/>",
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the name of the achievement<br/>",
        "!type": "fn() -> string"
      },
      getDescription: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the description of the achievement<br/>",
        "!type": "fn() -> string"
      },
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the achievement<br/>",
        "!type": "fn() -> string"
      },
      getCurrency1Award: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency1Award of the achievement<br/>",
        "!type": "fn() -> number"
      },
      getCurrency2Award: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency2Award of the achievement<br/>",
        "!type": "fn() -> number"
      },
      getCurrency3Award: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency3Award of the achievement<br/>",
        "!type": "fn() -> number"
      },
      getCurrency4Award: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency4Award of the achievement<br/>",
        "!type": "fn() -> number"
      },
      getCurrency5Award: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency5Award of the achievement<br/>",
        "!type": "fn() -> number"
      },
      getCurrency6Award: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency5Award of the achievement<br/>",
        "!type": "fn() -> number"
      },
      getPropertySet: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the property set associated with the achievement<br/>",
        "!type": "fn() -> ?"
      },
      getVirtualGoodAward: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the virtual good award of the achievement<br/>",
        "!type": "fn() -> SparkVirtualGood"
      },
      getCurrencyAwards: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency awards map associated with this achievement<br/>",
        "!type": "fn() -> ?"
      }
    },
    SparkChallengeType: {
      "!doc": "Contains configuration information for the challenges<br/>The methods in this class respect the segments of the current player when being executed<br/>",
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Short Code of the challenge<br/>",
        "!type": "fn() -> string"
      },
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Name of the challenge<br/>",
        "!type": "fn() -> string"
      },
      getDescription: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Description of the challenge<br/>",
        "!type": "fn() -> string"
      },
      isTurnBased: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the true if the challenge is turn based, false otherwise<br/>",
        "!type": "fn() -> bool"
      },
      getAttemptConsumers: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Attempt Consumers of the challenge<br/>",
        "!type": "fn() -> string"
      },
      isGlobal: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the true if the challenge is global, false otherwise<br/>",
        "!type": "fn() -> bool"
      }
    },
    SparkMatch: {
      "!doc": "Provides access to a match's details.<br/>e.g.<br/>var match = Spark.getMultiplayer().loadMatch(matchId);<br/>",
      getId: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>The id of this match<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var matchId = match.getId()</pre><br/>',
        "!type": "fn() -> string"
      },
      getParticipants: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>An array containing all of the participants of this match<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var participant = match.getParticipants()</pre><br/>',
        "!type": "fn() -> [SparkParticipant]"
      },
      getServer: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>The details of the realtime server on which this match will take place.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var server = match.getServer()</pre><br/>',
        "!type": "fn() -> SparkRealtimeServer"
      },
      addPlayers: {
        "!doc": '<b>validity</b> All Scripts<br/>Add the given players to this match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.addPlayers(playersToAdd)</pre><br/>',
        "!type": "fn(players: [SparkPlayer])"
      },
      addPlayersById: {
        "!doc": '<b>validity</b> All Scripts<br/>Add the players with the given playerIds to this match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.addPlayersById(playerIdsToAdd)</pre><br/>',
        "!type": "fn(playerIds: [string])"
      },
      removePlayers: {
        "!doc": '<b>validity</b> All Scripts<br/>Remove the given players from this match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.removePlayers(playersToRemove)</pre><br/>',
        "!type": "fn(players: [SparkPlayer])"
      },
      removePlayersById: {
        "!doc": '<b>validity</b> All Scripts<br/>Remove the players with the given playerIds from this match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.removePlayersById(playerIdsToRemove)</pre><br/>',
        "!type": "fn(playerIds: [string])"
      },
      enableRealtime: {
        "!doc": '<b>validity</b> All Scripts<br/>If this match is not already realtime enabled, this method will enabled realtime.<br/>The realtime servers for this match will be configured to use the realtime script provided<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.enableRealtime(\'MY_RT_SCRIPT\');</pre><br/>',
        "!type": "fn(script: string)"
      },
      enableRealtime_8: {
        "!doc": '<b>validity</b> All Scripts<br/>If this match is not already realtime enabled, this method will enabled realtime.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.enableRealtime();</pre><br/>',
        "!type": "fn()"
      },
      getMatchData: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns the matchData for the match instance.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.getMatchData();</pre><br/>',
        "!type": "fn() -> ?"
      },
      isRealtimeEnabled: {
        "!doc": '<b>validity</b> All Scripts<br/>Whether this match has realtime servers enabled.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var isEnabledForRealtime = match.isRealtimeEnabled();</pre><br/>',
        "!type": "fn() -> bool"
      },
      setMatchData: {
        "!doc": '<b>validity</b> All Scripts<br/>Sets the matchData for the match instance.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">match.setMatchData(matchData);</pre><br/>',
        "!type": "fn(matchData: ?)"
      }
    },
    SparkMatchConfig: {
      "!doc": "Contains configuration information for the match<br/>",
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the match<br/>",
        "!type": "fn() -> string"
      },
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the name of the match<br/>",
        "!type": "fn() -> string"
      },
      getDescription: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the description of the match<br/>",
        "!type": "fn() -> string"
      },
      getMinPlayers: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the minimum number of players in the match<br/>",
        "!type": "fn() -> number"
      },
      getMaxPlayers: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the minimum number of players in the match<br/>",
        "!type": "fn() -> number"
      },
      getRealtime: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the minimum number of players in the match<br/>",
        "!type": "fn() -> bool"
      },
      getRealtimeScript: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Realtime script<br/>",
        "!type": "fn() -> string"
      },
      getDropInDropOut: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns true if the match is Drop In/Drop Out<br/>",
        "!type": "fn() -> bool"
      },
      getDropInDropOutExpire: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the number of seconds before Drop In/Drop Out expires<br/>",
        "!type": "fn() -> number"
      },
      getManuallyMatch: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns true if the match is a manual match<br/>",
        "!type": "fn() -> bool"
      },
      getPlayerDisconnectThreshold: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the number of seconds before players are disconnected for Drop In/Drop Out matches<br/>",
        "!type": "fn() -> number"
      },
      getThresholds: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a list of thresholds in the match<br/>",
        "!type": "fn() -> List"
      },
      createPendingMatch: {
        "!doc": "<b>validity</b> All Scripts<br/>Creates a new pending match containing the given players.<br/>Any existing pending matches for these players with the same matchGroup will be cancelled.<br/>",
        "!type": "fn(matchGroup: string, skill: number, players: [SparkPlayer]) -> PendingMatch"
      },
      createPendingMatchWithCustomQuery: {
        "!doc": "<b>validity</b> All Scripts<br/>Creates a new pending match containing the given players.<br/>Any existing pending matches for these players with the same matchGroup will be cancelled.<br/>",
        "!type": "fn(matchGroup: string, skill: number, customQuery: ?, matchData: ?, players: [SparkPlayer]) -> PendingMatch"
      }
    },
    SparkMatchThreshold: {
      "!doc": "Contains configuration information for a match threshold<br/>",
      getPeriod: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the match<br/>",
        "!type": "fn() -> number"
      },
      getAcceptMinPlayers: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the maximum skill of the threshold<br/>",
        "!type": "fn() -> bool"
      },
      getMax: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the maximum skill of the threshold<br/>",
        "!type": "fn() -> number"
      },
      getMin: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the minimum skill of the threshold<br/>",
        "!type": "fn() -> number"
      },
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the type of the threshold<br/>",
        "!type": "fn() -> string"
      }
    },
    SparkMessage: {
      "!doc": "Provides the ability to send a ScriptMessage and provide the configuration in code rather than from within the portal<br/>",
      setSendViaSocket: {
        "!doc": "Sets the Send Via Socket option.<br/>",
        "!type": "fn(value: bool) -> SparkMessage"
      },
      setSendAsPush: {
        "!doc": "Sets the Send As Push option.<br/>",
        "!type": "fn(value: bool) -> SparkMessage"
      },
      setSupressPushOnSocketSend: {
        "!doc": "Sets the Send As Push option.<br/>",
        "!type": "fn(value: bool) -> SparkMessage"
      },
      setIncludeInPushCount: {
        "!doc": "Sets the Include In Push Count option.<br/>",
        "!type": "fn(value: bool) -> SparkMessage"
      },
      setExpireAfterHours: {
        "!doc": "Sets the Time To Live (Hours) option.<br/>",
        "!type": "fn(hours: number) -> SparkMessage"
      },
      setDeviceTypes: {
        "!doc": "Limits the message delivery to only the device types supplied.<br/>",
        "!type": "fn(deviceTypes: [string]) -> SparkMessage"
      },
      setMessageData: {
        "!doc": "Sets the data to send.<br/>",
        "!type": "fn(data: ?) -> SparkMessage"
      },
      setPlayerIds: {
        "!doc": "Sets the playerId to send the message to.<br/>",
        "!type": "fn(playerIds: [string]) -> SparkMessage"
      },
      send: {
        "!doc": "Sends the message.<br/>",
        "!type": "fn()"
      }
    },
    SparkScheduler: {
      "!doc": "Utility to schedule execution of a module in the future<br/>validity All Scripts<br/>example<br/>var theScheduler = Spark.getScheduler();<br/>",
      inSeconds: {
        "!doc": 'Schedules the execution of the supplied module. The scheduled script will run in the context of the current player<br/><b>params</b><br/>shortCode - The shortCode of the module to execute<br/>delaySeconds - How long to wait until executing the module<br/>data - The data to pass to the module. This will be available as Spark.getData() when the module is running<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">theScheduler.inSeconds("SHORT_CODE", 15, {"myData" : myData});</pre><br/>',
        "!type": "fn(shortCode: string, delaySeconds: number, data: ?) -> bool"
      },
      inSeconds_1: {
        "!doc": 'Schedules the execution of the supplied module<br/><b>params</b><br/>shortCode - The shortCode of the module to execute<br/>delaySeconds - How long to wait until executing the module<br/>data - The data to pass to the module. This will be available as Spark.getData() when the module is running<br/>key - The id of the scheduled item. If schedule already exists for the given key it\'s details will be updated<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">theScheduler.inSeconds("SHORT_CODE", 15, {"myData" : myData}, "logTimeout-" + Spark.getPlayer().getPlayerId());</pre><br/>',
        "!type": "fn(shortCode: string, delaySeconds: number, data: ?, key: string) -> bool"
      },
      cancel: {
        "!doc": "Cancels the execution of a previously scheduled module.<br/><b>params</b><br/>key - The id of the scheduled item to cancel.<br/>",
        "!type": "fn(key: string)"
      }
    },
    SparkSegmentType: {
      "!doc": "Contains configuration information for the segment<br/>",
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the name of the segment<br/>",
        "!type": "fn() -> string"
      },
      getDescription: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the description of the segment<br/>",
        "!type": "fn() -> string"
      },
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the segment<br/>",
        "!type": "fn() -> string"
      },
      getValues: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the values configured against the segment<br/>",
        "!type": "fn() -> [SparkSegmentValue]"
      }
    },
    SparkSegmentValue: {
      "!doc": "Contains configuration information for the segment value<br/>",
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the name of the segment value<br/>",
        "!type": "fn() -> string"
      },
      getDescription: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the description of the segment value<br/>",
        "!type": "fn() -> string"
      },
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the segment value<br/>",
        "!type": "fn() -> string"
      }
    },
    SparkTeamType: {
      "!doc": "Contains configuration information for the teams<br/>The methods in this class respect the segments of the current player when being executed<br/>",
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the team<br/>",
        "!type": "fn() -> string"
      },
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the name of the team<br/>",
        "!type": "fn() -> string"
      },
      getSocial: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns true if team is social<br/>",
        "!type": "fn() -> bool"
      },
      getExtendedSocial: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns true if team is extended social<br/>",
        "!type": "fn() -> bool"
      },
      getMaxMembers: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Max Members of the team<br/>",
        "!type": "fn() -> number"
      },
      getMaxMembershipPerUser: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Max Membership of the team<br/>",
        "!type": "fn() -> number"
      },
      getMaxOwnershipPerUser: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Max Ownership of the team<br/>",
        "!type": "fn() -> number"
      }
    },
    SparkVirtualGood: {
      "!doc": "Contains configuration information for the virtual good<br/>The methods in this class respect the segments of the current player when being executed<br/>",
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the name of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getDescription: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the description of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getCurrency1Cost: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency1Cost of the virtual good<br/>",
        "!type": "fn() -> number"
      },
      getCurrency2Cost: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency1Cost of the virtual good<br/>",
        "!type": "fn() -> number"
      },
      getCurrency3Cost: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency3Cost of the virtual good<br/>",
        "!type": "fn() -> number"
      },
      getCurrency4Cost: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency4Cost of the virtual good<br/>",
        "!type": "fn() -> number"
      },
      getCurrency5Cost: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency5Cost of the virtual good<br/>",
        "!type": "fn() -> number"
      },
      getCurrency6Cost: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency6Cost of the virtual good<br/>",
        "!type": "fn() -> number"
      },
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the short code of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getGooglePlayProductId: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Google Play ProductId of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getIosAppStoreProductId: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the iOS ProductId of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getWP8StoreProductId: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the WP8 ProductId of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getW8StoreProductId: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the W8 ProductId of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getAmazonStoreProductId: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Amazon Product Id of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getSteamStoreProductId: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the Steam Product Id of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getPsnStoreProductId: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the PSN Product Id of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getType: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the type of the virtual good<br/>",
        "!type": "fn() -> string"
      },
      getTags: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the tags of the virtual good<br/>",
        "!type": "fn() -> [string]"
      },
      getMaxQuantity: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the max quantity of the virtual good<br/>",
        "!type": "fn() -> number"
      },
      getBundledGoods: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the bundled goods of the virtual good<br/>",
        "!type": "fn() -> ?"
      },
      isDisabled: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns whether this VirtualGood is hidden<br/>",
        "!type": "fn() -> bool"
      },
      getPropertySet: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the property set associated with this virtual good<br/>",
        "!type": "fn() -> ?"
      },
      getCurrencyCosts: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the currency cost map associated with this virtual good<br/>",
        "!type": "fn() -> ?"
      }
    },
    SparkCurrency: {
      "!doc": "Contains configuration information for the custom currency.<br/>The methods in this class respect the segments of the current player when being executed<br/>",
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the currency<br/>",
        "!type": "fn() -> string"
      },
      getName: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the name of the currency<br/>",
        "!type": "fn() -> string"
      },
      getDescription: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the description of the currency<br/>",
        "!type": "fn() -> string"
      },
      getSignupBonus: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the signup bonus for the currency<br/>",
        "!type": "fn() -> number"
      }
    },
    SparkDownloadable: {
      "!doc": "Contains configuration information for the downloadable<br/>",
      getShortCode: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the shortCode of the downloadable<br/>",
        "!type": "fn() -> string"
      },
      getSize: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the size of the downloadable<br/>",
        "!type": "fn() -> number"
      },
      getLastModified: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns the lastModified date of the downloadable<br/>",
        "!type": "fn() -> date"
      },
      getUrl: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a url that can be used to download this content<br/>",
        "!type": "fn() -> string"
      }
    },
    SparkCache: {
      "!doc": "Provides the ability to cache javascript objects. This includes complex objects with functions. Any javascript object can be cached. This allows you to create objects of a particular structure from your JSON data in mongo that can speed up access.<br/>This differs slighty from storing data in mongo as the data is stored in memory and expired on a LRU basis. This means access time is significantly faster for these in memory objects<br/>Cached objects are backed by mongo for up to 30 days, so if an item is expired in memory, when you try to access it again it will be reloaded.<br/>There is a limited amount of memory available on servers, so this should be used for few, shared configuration type objects<br/>Using this for player data or having a large amount of objects could slow down you application as the store / reload process is more expensive than a mongo find for JSON data<br/>Code using SparkCache should be written with the expectation that the cache may return null (if data is expired) so should be able to reconstruct and re-cache the data in this scenario.<br/>e.g.<br/>var theCache = Spark.getCache();<br/>",
      put: {
        "!doc": 'Adds an object to the cache<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">theCache.put("key", myObject);</pre><br/>',
        "!type": "fn(key: string, object: ?)"
      },
      get: {
        "!doc": 'Gets an objects from the cache<br/><b>returns</b><br/>A JavaScipt object, or null depending on whether put has ben called for the given key <br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var myObject = theCache.get("key");</pre><br/>',
        "!type": "fn(key: string) -> ?"
      },
      remove: {
        "!doc": 'Remove an object from the cache<br/>The object will be removed form the cache, and form the database. Subsequent calls to get will return null<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false"> theCache.remove("key")</pre><br/>',
        "!type": "fn(key: string)"
      },
      removeAll: {
        "!doc": 'Clears everything from the cache<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false"> theCache.removeAll()</pre><br/>',
        "!type": "fn()"
      },
      removeAll_4: {
        "!doc": 'Clears all objects from the cache where the keys match the regex pattern provided.<br/>the match pattern is ultimately used by mongo to do a $regex query, which uses<br/>"Perl Compatible Regular Expressions" (PCRE) as the matching engine.<br/><pre rel="highlighter" code-brush="js" contenteditable="false"> theCache.removeAll("match\\..*\\.2014)</pre><br/>',
        "!type": "fn(pattern: string)"
      }
    },
    SparkParticipant: {
      "!doc": "Provides the details of a participant in a match<br/>e.g.<br/>var participant = Spark.getMultiplayer().loadMatch(matchId).getParticipants[0];<br/>",
      getPlayer: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>The SparkPlayer this participant represents<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var player = participant.getPlayer()</pre><br/>',
        "!type": "fn() -> SparkPlayer"
      },
      getPeerId: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>The peerId of this participant<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var peerId = participant.getPeerId()</pre><br/>',
        "!type": "fn() -> number"
      },
      getAccessToken: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>An accessToken for this participant to connect to the realtime server<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var accessToken = participant.getAccessToken()</pre><br/>',
        "!type": "fn() -> string"
      }
    },
    SparkUploadableUtils: {
      "!doc": "Provides utility methods to create and retrieve Uploadables.<br/>e.g.<br/>var uploadableUtils = Spark.getUploadableUtils();<br/>",
      uploadString: {
        "!doc": "<b>validity</b> All Scripts<br/>Uploads String data as an Uploadable<br/><b>returns</b><br/>The uploadId if the upload was successful, or null otherwise<br/>",
        "!type": "fn(stringData: string, player: SparkPlayer, fileName: string, metaData: ?) -> string"
      },
      retrieveString: {
        "!doc": "<b>validity</b> All Scripts<br/>Returns a previously uploaded String, or null otherwise<br/>",
        "!type": "fn(uploadId: string) -> string"
      }
    },
    SparkRealtimeServer: {
      "!doc": "Provides the details of the realtime server on which a match will be played out<br/>e.g.<br/>var server = Spark.getMultiplayer().loadMatch(matchId).getServer();<br/>",
      getHost: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>The hostname of the server<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var host = server.getHost()</pre><br/>',
        "!type": "fn() -> string"
      },
      getPort: {
        "!doc": '<b>validity</b> All Scripts<br/><b>returns</b><br/>The port to connect to on the server<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var port = server.getPort()</pre><br/>',
        "!type": "fn() -> number"
      }
    },
    SparkLeaderboardOperations: {
      "!doc": "A comparison operation on the owners (players in a player-based leaderboard, teams in a team-based leaderboard) of entries within leaderboards.<br/>var operation = Spark.getLeaderboards().union(lb1, lb2);<br/>",
      union: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a union on the set of owners returned as result of evaluating this operation and the owners of entries within the given leaderboard.<br/>Returns a new SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inAny = operation.union(rhs).evaluate();</pre><br/>',
        "!type": "fn(rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      union_1: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a union on the set of owners returned as result of evaluating this operation and the set of owners returned as result of evaluating the given operation.<br/>Returns a new SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inAny = operation.union(rhs).evaluate();</pre><br/>',
        "!type": "fn(rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      intersection: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs an intersection on the set of owners returned as result of evaluating this operation and the owners of entries within the given leaderboard.<br/>Returns a new SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inBoth = operation.intersection(rhs).evaluate();</pre><br/>',
        "!type": "fn(rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      intersection_3: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs an intersection on the set of owners returned as result of evaluating this operation and the set of owners returned as result of evaluating the given operation.<br/>Returns a new SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var inBoth = operation.intersection(rhs).evaluate();</pre><br/>',
        "!type": "fn(rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      difference: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a difference on the set of owners returned as result of evaluating this operation and the owners of entries within the given leaderboard.<br/>Returns a new SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var onlyInFirst = operation.difference(rhs).evaluate();</pre><br/>',
        "!type": "fn(rhs: SparkLeaderboard) -> SparkLeaderboardOperations"
      },
      difference_5: {
        "!doc": '<b>validity</b> All Scripts<br/>Performs a difference on the set of owners returned as result of evaluating this operation and the set of owners returned as result of evaluating the given operation.<br/>Returns a new SparkLeaderboardOperations object to allow further operations to be chained before evaluation.<br/>To obtain the result of the operation call evaluate() on the SparkLeaderboardOperations returned.<br/><b>params</b><br/>rhs - the the right-hand side of the operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var onlyInFirst = operation.difference(rhs).evaluate();</pre><br/>',
        "!type": "fn(rhs: SparkLeaderboardOperations) -> SparkLeaderboardOperations"
      },
      evaluate: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns an array of ids representing the result set of evaluating this operation.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">var results = operation.evaluate();</pre><br/>',
        "!type": "fn() -> [string]"
      }
    },
    ChatMessage: {
      "!doc": "A message from a group chat<br/>",
      getFromId: {
        "!doc": "The id of the player who sent this message<br/>",
        "!type": "fn() -> string"
      },
      getId: {
        "!doc": "The id of this chat message<br/>",
        "!type": "fn() -> string"
      },
      getMessage: {
        "!doc": "The text sent in this message<br/>",
        "!type": "fn() -> string"
      },
      getWhen: {
        "!doc": "A date representing the time this message was sent<br/>",
        "!type": "fn() -> date"
      },
      getWho: {
        "!doc": "The displayName of the player who sent this message<br/>",
        "!type": "fn() -> string"
      }
    },
    PendingMatch: {
      "!doc": "An object that represents a pending match.<br/>",
      getId: {
        "!doc": '<b>validity</b> All Scripts<br/>The ID for the pending match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.getId();</pre><br/>',
        "!type": "fn() -> string"
      },
      getMatchShortCode: {
        "!doc": '<b>validity</b> All Scripts<br/>The match shortCode for the pending match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.getMatchShortCode();</pre><br/>',
        "!type": "fn() -> string"
      },
      getMatchGroup: {
        "!doc": '<b>validity</b> All Scripts<br/>The match group for the pending match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.getMatchGroup();</pre><br/>',
        "!type": "fn() -> string"
      },
      getSkill: {
        "!doc": '<b>validity</b> All Scripts<br/>The average skill of players in this pending match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.getSkill();</pre><br/>',
        "!type": "fn() -> number"
      },
      getMatchedPlayers: {
        "!doc": '<b>validity</b> All Scripts<br/>The players already part of this pending match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.getMatchedPlayers();</pre><br/>',
        "!type": "fn() -> SparkMatchedPlayer[]"
      },
      joinPendingMatch: {
        "!doc": '<b>validity</b> All Scripts<br/>Join this pending match to the given pending match.<br/><b>returns</b><br/>The merged SparkPendingMatch if it was joined successfully,<br/>or null if the pendingMatch could not be joined.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.joinPendingMatch(otherPendingMatch);</pre><br/>',
        "!type": "fn(pendingMatchToJoin: PendingMatch) -> PendingMatch"
      },
      findPendingMatches: {
        "!doc": '<b>validity</b> All Scripts<br/>Find pending matches that are suitable for matchmaking with this one.<br/><b>parameters</b><br/>maxMatchesToFind - the maximum number of results to return<br/><b>returns</b><br/>An array of pending matches suitable for matching with this one.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.findPendingMatches();</pre><br/>',
        "!type": "fn(maxMatchesToFind: number) -> SparkPendingMatch[]"
      },
      getMatchData: {
        "!doc": '<b>validity</b> All Scripts<br/>Returns the matchData for the pending match.<br/><b>example</b><br/><pre rel="highlighter" code-brush="js" contenteditable="false">pendingMatch.getMatchData();</pre><br/>',
        "!type": "fn() -> ?"
      }
    },
    SparkPlayerExperimentSegment: {
      "!doc": "An experiment segment that the player is part of.<br/>",
      getExperimentId: {
        "!doc": "The experiment ID<br/>",
        "!type": "fn() -> number"
      },
      getSegmentName: {
        "!doc": "The segment that the player is in for this experiment<br/>",
        "!type": "fn() -> string"
      }
    },
    SparkRequests: {
      "!doc": "Provides access to the GameSparks Request API",
      _AcceptChallengeRequest: {
        "!type": "fn()",
        "!doc": "Accepts a challenge that has been issued to the current player.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _AccountDetailsRequest: {
        "!type": "fn()",
        "!doc": "Retrieves the details of the current authenticated player.<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _AmazonBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes the receipt from an Amazon in app purchase.<br/>The GameSparks platform will validate the amazonUserId and receiptId with Amazon using the Amazon Purchase Secret configured against the game.<br/>The receiptId in the data will be recorded and the request will be rejected if the receiptId has previously been processed, this prevents replay attacks.<br/>Once verfied, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the receipt with the 'Amazon Product Id' configured against the virtual good.<br/>",
        prototype: {
          amazonUserId: {
            "!doc": "The userId obtained from the UserData within a PurchaseResponse<br/>",
            "!type": "string"
          },
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          receiptId: {
            "!doc": "The receiptId obtained from the Receipt within a PurchaseResponse<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _AmazonConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Amazon access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Amazon platform and store them within GameSparks.<br/>If the Amazon user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Amazon user is not already registered with the game, the Amazon user will be linked to the current player.<br/>If the current player has not authenticated and the Amazon user is not known, a new player will be created using the Amazon details and the session will be authenticated against the new player.<br/>If the Amazon user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _AnalyticsRequest: {
        "!type": "fn()",
        "!doc": "Records some custom analytical data.<br/>Simple analytics, where you just need to track the number of times something happened, just take a key parameter. We'll record the players id against the data to allow you to report on averages per user<br/>Timed analytics allow you to send start and end timer requests, and with this data GameSparks can track the length of time something takes.<br/>If an end request is sent without a matching start timer the request will fail silently and your analytics data might not contain what you expect.<br/>If both start and end are supplied, the request will be treated as a start timer.<br/>An additional data payload can be attached to the event for advanced reporting. This data can be a string, number or JSON object.<br/>If a second start timer is created using a key that has already had a start timer created without an end, the previous one will be marked as abandoned.<br/>",
        prototype: {
          data: {
            "!doc": "Custom data payload<br/>",
            "!type": "?"
          },
          end: {
            "!doc": "Use the value true to indicate it's an end timer<br/>",
            "!type": "bool"
          },
          key: {
            "!doc": "The key you want to track this analysis with.<br/>",
            "!type": "string"
          },
          start: {
            "!doc": "Use the value true to indicate it's a start timer<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _AroundMeLeaderboardRequest: {
        "!type": "fn()",
        "!doc": "Returns leaderboard data that is adjacent to the currently signed in player's position within the given leaderboard.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The challenge instance to get the leaderboard data for<br/>",
            "!type": "string"
          },
          customIdFilter: {
            "!doc": "An optional filter on the customIds.<br/>If this request does not contain a custonIdFilter or if it is a partial filter, <br/>the leaderboard entries around the highest score for the given constraints will be returned.<br/>",
            "!type": "?"
          },
          dontErrorOnNotSocial: {
            "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
            "!type": "bool"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          friendIds: {
            "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
            "!type": "[string]"
          },
          includeFirst: {
            "!doc": "Number of entries to include from head of the list<br/>",
            "!type": "number"
          },
          includeLast: {
            "!doc": "Number of entries to include from tail of the list<br/>",
            "!type": "number"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboardShortCode: {
            "!doc": "The short code of the leaderboard<br/>",
            "!type": "string"
          },
          social: {
            "!doc": "If True returns a leaderboard of the player's social friends<br/>",
            "!type": "bool"
          },
          teamIds: {
            "!doc": "The IDs of the teams you are interested in<br/>",
            "!type": "[string]"
          },
          teamTypes: {
            "!doc": "The type of team you are interested in<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _AuthenticationRequest: {
        "!type": "fn()",
        "!doc": "Provides authentication using a username/password combination.<br/>The username will have been previously created using a RegistrationRequest.<br/>",
        prototype: {
          password: {
            "!doc": "The previously registered password<br/>",
            "!type": "string"
          },
          userName: {
            "!doc": "The previously registered player name<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _BatchAdminRequest: {
        "!type": "fn()",
        "!doc": "Performs a request for multiple players.<br/>",
        prototype: {
          playerIds: {
            "!doc": "The players to run the request for.<br/>",
            "!type": "[string]"
          },
          request: {
            "!doc": "The request to be run for each player.<br/>",
            "!type": "_DBObject"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _BuyVirtualGoodsRequest: {
        "!type": "fn()",
        "!doc": "Purchases a virtual good with an in game currency. Once purchased the virtual good will be added to the players account.<br/>",
        prototype: {
          currencyShortCode: {
            "!doc": "The short code of the currency to use<br/>",
            "!type": "string"
          },
          currencyType: {
            "!doc": "Which virtual currency to use. (1 to 6)<br/>",
            "!type": "number"
          },
          quantity: {
            "!doc": "The number of items to purchase<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The short code of the virtual good to be purchased<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _CancelBulkJobAdminRequest: {
        "!type": "fn()",
        "!doc": "Cancel one or more bulk jobs.<br/>",
        prototype: {
          bulkJobIds: {
            "!doc": "The IDs of existing bulk jobs to cancel<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ChangeUserDetailsRequest: {
        "!type": "fn()",
        "!doc": "Change the details of the currently signed in Player.<br/>",
        prototype: {
          displayName: {
            "!doc": "The new display name to set in the player data.<br/>",
            "!type": "string"
          },
          language: {
            "!doc": "The new language code to set in the player data.<br/>",
            "!type": "string"
          },
          newPassword: {
            "!doc": "The new password to set in the player data.<br/>",
            "!type": "string"
          },
          oldPassword: {
            "!doc": "The player's existing password. If supplied it will be checked against the password stored in the player data. This allows you re-authenticate the player making the change.<br/>",
            "!type": "string"
          },
          userName: {
            "!doc": "The new userName with which this player will sign in.  If the player currently authenticates using device authentication this will upgrade their account and require them to use username and password authentication from now on.<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ChatOnChallengeRequest: {
        "!type": "fn()",
        "!doc": "Sends a message to all players involved in the challenge. The current player must be involved in the challenge for the message to be sent.<br/>As the message is sent to all players, the current player will also see details of the message in the response. Read the section on response message aggregation for a description of this.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ConsumeVirtualGoodRequest: {
        "!type": "fn()",
        "!doc": "Consumes a given amount of the specified virtual good.<br/>",
        prototype: {
          quantity: {
            "!doc": "The amount of virtual goods to be consumed<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The short code of the virtual good to be consumed<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _CreateChallengeRequest: {
        "!type": "fn()",
        "!doc": "Issues a challenge to a group of players from the currently signed in player.<br/>The endTime field must be present unless the challenge template has an achievement set in the 'First to Achievement' field.<br/>The usersToChallenge field must be present for this request if the acessType is PRIVATE (which is the default).<br/>",
        prototype: {
          accessType: {
            "!doc": "Who can join this challenge. Either PUBLIC, PRIVATE or FRIENDS<br/>",
            "!type": "string"
          },
          autoStartJoinedChallengeOnMaxPlayers: {
            "!doc": "Whether this challenge should automatically start when a new player joins and maxPlayers is reached<br/>",
            "!type": "bool"
          },
          challengeMessage: {
            "!doc": "An optional message to include with the challenge<br/>",
            "!type": "string"
          },
          challengeShortCode: {
            "!doc": "The short code of the challenge<br/>",
            "!type": "string"
          },
          currency1Wager: {
            "!doc": "The ammount of currency type 1 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency2Wager: {
            "!doc": "The amount of currency type 2 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency3Wager: {
            "!doc": "The amount of currency type 3 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency4Wager: {
            "!doc": "The amount of currency type 4 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency5Wager: {
            "!doc": "The amount of currency type 5 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency6Wager: {
            "!doc": "The amount of currency type 6 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currencyWagers: {
            "!doc": "A JSON object containing the amounts of named currencies that the player is wagering on this challenge<br/>",
            "!type": "?"
          },
          eligibilityCriteria: {
            "!doc": "Criteria for who can and cannot find and join this challenge (when the accessType is PUBLIC or FRIENDS).<br/>Currently supports a field <i>segments</i> that contains segment type against single (where that segment value is required) or multiple (where one of the specified values is required) segment values.<br/>For each segment type a player must have one of the specified values in order to be considered eligible.<br/>",
            "!type": "?"
          },
          endTime: {
            "!doc": "The time at which this challenge will end. This is required when the challenge is not linked to an achievement<br/>",
            "!type": "date"
          },
          expiryTime: {
            "!doc": "The latest time that players can join this challenge<br/>",
            "!type": "date"
          },
          maxAttempts: {
            "!doc": "The maximum number of attempts <br/>",
            "!type": "number"
          },
          maxPlayers: {
            "!doc": "The maximum number of players that are allowed to join this challenge<br/>",
            "!type": "number"
          },
          minPlayers: {
            "!doc": "The minimum number of players that are allowed to join this challenge<br/>",
            "!type": "number"
          },
          silent: {
            "!doc": "If True  no messaging is triggered<br/>",
            "!type": "bool"
          },
          startTime: {
            "!doc": "The time at which this challenge will begin<br/>",
            "!type": "date"
          },
          usersToChallenge: {
            "!doc": "A player id or an array of player ids who will recieve this challenge<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _CreateTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a new team to be created.<br/>",
        prototype: {
          teamId: {
            "!doc": "An optional teamId to use<br/>",
            "!type": "string"
          },
          teamName: {
            "!doc": "A display name to use<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The type of team to be created<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _DeclineChallengeRequest: {
        "!type": "fn()",
        "!doc": "Declines a challenge that has been issued to the current player.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _DeviceAuthenticationRequest: {
        "!type": "fn()",
        "!doc": "Allows a device id to be used to create an anonymous profile in the game.<br/>This allows the player to be tracked and have data stored against them before using FacebookConnectRequest to create a full profile.<br/>DeviceAuthenticationRequest should not be used in conjunction with RegistrationRequest as the two accounts will not be merged.<br/>",
        prototype: {
          deviceId: {
            "!doc": "A unique device identifier. Each platform has it's own method for getting a unique id<br/>",
            "!type": "string"
          },
          deviceModel: {
            "!doc": "The device model<br/>",
            "!type": "string"
          },
          deviceName: {
            "!doc": "The device name<br/>",
            "!type": "string"
          },
          deviceOS: {
            "!doc": "An indicator of the device platform, should be IOS, ANDROID, WP8 or W8<br/>",
            "!type": "string"
          },
          deviceType: {
            "!doc": "The device type<br/>",
            "!type": "string"
          },
          displayName: {
            "!doc": "An optional displayname for the player<br/>",
            "!type": "string"
          },
          operatingSystem: {
            "!doc": "The device type<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request reates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _DismissMessageRequest: {
        "!type": "fn()",
        "!doc": "Allows a message to be dismissed. Once dismissed the message will no longer appear in either ListMessageResponse or ListMessageSummaryResponse.<br/>",
        prototype: {
          messageId: {
            "!doc": "The messageId of the message to dismiss<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _DismissMultipleMessagesRequest: {
        "!type": "fn()",
        "!doc": "Allows multiple messages to be dismissed. Once dismissed the messages will no longer appear in either ListMessageResponse or ListMessageSummaryResponse.<br/>",
        prototype: {
          messageIds: {
            "!doc": "The list of the messageIds to dismiss<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _DropTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to drop a team.<br/>",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _EndSessionRequest: {
        "!type": "fn()",
        "!doc": "Records the end of the current player's active session.<br/>The SDK will automatically create a new session ID when the application is started, this method can be useful to call when the app goes into the background to allow reporting on player session length.<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _FacebookConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows either a Facebook access token, or a Facebook authorization code to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Facebook platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Facebook user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the Facebook user is not already registered with the game, the Facebook user will be linked to the current player.<br/>If the current player has not authenticated and the Facebook user is not known, a new player will be created using the Facebook details and the session will be authenticated against the new player.<br/>If the Facebook user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>It has a longer lifetime than the authorization code, typically on the order of minutes or hours.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained via a refresh token.<br/>",
            "!type": "string"
          },
          code: {
            "!doc": "An authorization code is a short-lived token representing the user's access grant, created by the authorization server and passed to the client application via the browser.<br/>The client application sends the authorization code to the authorization server to obtain an access token and, optionally, a refresh token.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _FindChallengeRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to find challenges that they are eligible to join.<br/>",
        prototype: {
          accessType: {
            "!doc": "The type of challenge to find, either PUBLIC or FRIENDS.  Defaults to FRIENDS<br/>",
            "!type": "string"
          },
          count: {
            "!doc": "The number of challenges to return (MAX=50)<br/>",
            "!type": "number"
          },
          eligibility: {
            "!doc": "Optional.  Allows the current player's eligibility to be overridden by what is provided here.<br/>",
            "!type": "?"
          },
          offset: {
            "!doc": "The offset to start from when returning challenges (used for paging)<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "Optional shortCodes to filter the results by challenge type<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _FindPendingMatchesRequest: {
        "!type": "fn()",
        "!doc": "Find other pending matches that will match this player's previously submitted MatchmakingRequest.<br/>Used for manual matching of players, where you want control over which pending match should be chosen.<br/>Each player must match the other for the pending match to be found.<br/>",
        prototype: {
          matchGroup: {
            "!doc": "Optional. The matchGroup of the match this player previously registeredfor<br/>",
            "!type": "string"
          },
          matchShortCode: {
            "!doc": "The shortCode of the match this player previously registered for<br/>",
            "!type": "string"
          },
          maxMatchesToFind: {
            "!doc": "Optional. The maximum number of pending matches to return (default=10)<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GameCenterConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Apple account that has GameCenter to be used as an authentication mechanism.<br/>The request must supply the GameCenter user details, such as the player id and username.<br/>If the GameCenter user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the GameCenter user is not already registered with the game, the GameCenter user will be linked to the current player.<br/>If the current player has not authenticated and the GameCenter user is not known, a new player will be created using the GameCenter details and the session will be authenticated against the new player.<br/>If the GameCenter user is already known, the session will switch to being the previously created user.<br/>This API call requires the output details from GKLocalPlayer.generateIdentityVerificationSignatureWithCompletionHandler on your iOS device<br/>",
        prototype: {
          displayName: {
            "!doc": "The display of the current player from GameCenter. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          externalPlayerId: {
            "!doc": "The game center id of the current player. This value obtained be obtained from GKLocalPlayer playerID<br/>",
            "!type": "string"
          },
          publicKeyUrl: {
            "!doc": "The url from where we will download the public key. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler. <br/>",
            "!type": "string"
          },
          salt: {
            "!doc": "The salt is needed in order to prevent request forgery. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler and should be base64 encoded using [salt base64Encoding]<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          signature: {
            "!doc": "The signature is needed to validate that the request is genuine and that we can save the player. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler and should be base64 encoded using [signature base64Encoding]<br/>",
            "!type": "string"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          timestamp: {
            "!doc": "The timestamp is needed to validate the request signature. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetChallengeRequest: {
        "!type": "fn()",
        "!doc": "Gets the details of a challenge. The current player must be involved in the challenge for the request to succeed.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetDownloadableRequest: {
        "!type": "fn()",
        "!doc": "Returns a secure, time sensitive url to allow the game to download a piece of downloadable content stored in the GameSparks platform.<br/>",
        prototype: {
          shortCode: {
            "!doc": "The short code of the Downloadable item<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetLeaderboardEntriesRequest: {
        "!type": "fn()",
        "!doc": "Get the leaderboard entry data for the current player or a given player.<br/>For each leaderboard it returns the hichest score the player has<br/>",
        prototype: {
          challenges: {
            "!doc": "The challenge leaderboards to return entries for<br/>",
            "!type": "[string]"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboards: {
            "!doc": "The list of leaderboards shortcodes<br/>",
            "!type": "[string]"
          },
          player: {
            "!doc": "The player id. Leave out to use the current player id<br/>",
            "!type": "string"
          },
          social: {
            "!doc": "Set to true to include the player's game friends<br/>",
            "!type": "bool"
          },
          teamTypes: {
            "!doc": "The types of team to apply this request to<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetMessageRequest: {
        "!type": "fn()",
        "!doc": "Returns the full details of a message.<br/>",
        prototype: {
          messageId: {
            "!doc": "The messageId of the message retreive<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetMyTeamsRequest: {
        "!type": "fn()",
        "!doc": "Get the teams that the player is in. Can be filtered on team type and also on those teams that the player owns.<br/>",
        prototype: {
          ownedOnly: {
            "!doc": "Set to true to only get teams owned by the player<br/>",
            "!type": "bool"
          },
          teamTypes: {
            "!doc": "The type of teams to get<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetPropertyRequest: {
        "!type": "fn()",
        "!doc": "Get the property for the given short Code.<br/>",
        prototype: {
          propertyShortCode: {
            "!doc": "The shortCode of the property to return.<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetPropertySetRequest: {
        "!type": "fn()",
        "!doc": "Get the property set for the given short Code.<br/>",
        prototype: {
          propertySetShortCode: {
            "!doc": "The shortCode of the property set to return.<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows the details of a team to be retrieved.<br/>",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetUploadUrlRequest: {
        "!type": "fn()",
        "!doc": "Returns a secure, time sensitive URL to allow the game to upload a piece of player content to the GameSparks platform.<br/>",
        prototype: {
          uploadData: {
            "!doc": "Optional meta data which is stored against the player's uploaded content<br/>",
            "!type": "[?]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GetUploadedRequest: {
        "!type": "fn()",
        "!doc": "Returns a secure, time sensitive URL to a piece of content that was previously uploaded to the GameSparks platform by a player.<br/>",
        prototype: {
          uploadId: {
            "!doc": "The system generated id of the uploaded item<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GooglePlayBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes the response from a Google Play in app purchase flow.<br/>The GameSparks platform will validate the signature and signed data with the Google Play Public Key configured against the game.<br/>The orderId in the data will be recorded and the request will be rejected if the orderId has previously been processed, this prevents replay attacks.<br/>Once verfied, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the signed data with the 'Google Product ID' configured against the virtual good.<br/>It is critical that the signedData is sent exactly as it is returned form google, including any whitespace. Any modification of the signedData will cause the verification process to fail.<br/>",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          signature: {
            "!doc": 'The value obtained from data.getStringExtra("INAPP_DATA_SIGNATURE");<br/>',
            "!type": "string"
          },
          signedData: {
            "!doc": 'The value obtained from data.getStringExtra("INAPP_PURCHASE_DATA")<br/>',
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GooglePlayConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows either a Google Play access code or an access token to be used as an authentication mechanism.<br/>The access code needs to have at least the https://www.googleapis.com/auth/games scope.<br/>For more details about Google OAuth 2.0 scopes refer to this: https://developers.google.com/identity/protocols/googlescopes#gamesConfigurationv1configuration<br/>If the Google Play user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Google Play user is not already registered with the game, the Google Play user will be linked to the current player.<br/>If the current player has not authenticated and the Google Play user is not known, a new player will be created using the Google Play details and the session will be authenticated against the new player.<br/>If the Google Play user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The access token is used when using the service id and certificate.<br/>",
            "!type": "string"
          },
          code: {
            "!doc": "The access code is used by the client to make authenticated requests on behalf of the end user. Requires clientId and clientsecret to be set<br/>",
            "!type": "string"
          },
          displayName: {
            "!doc": "The display of the current player from Google Play. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          googlePlusScope: {
            "!doc": "Did you request the plus.login scope when you got the access code or authorisation token from Google? If this is true, we will fetch the user's google+ account and friends<br/>",
            "!type": "bool"
          },
          profileScope: {
            "!doc": "Did you request the profile scope when you got the access code or authorisation token from Google? If this is true, we will fetch the user info by calling https://www.googleapis.com/oauth2/v1/userinfo?alt=json <br/>",
            "!type": "bool"
          },
          redirectUri: {
            "!doc": "Only required when the access code has been granted using an explicit redirectUri, for example when using the mechanism described in https://developers.google.com/+/web/signin/server-side-flow<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _GooglePlusConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows either a Google Plus access code or an authentication token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Google Plus platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Google Plus user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Google Plus user is not already registered with the game, the Google Plus user will be linked to the current player.<br/>If the current player has not authenticated and the Google Plus user is not known, a new player will be created using the Google Plus details and the session will be authenticated against the new player.<br/>If the Google Plus user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The access token is used when using the service id and certificate.<br/>",
            "!type": "string"
          },
          code: {
            "!doc": "The access code is used by the client to make authenticated requests on behalf of the end user. Requires clientId and clientsecret to be set<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          redirectUri: {
            "!doc": "Only required when the access code has been granted using an explicit redirectUri, for example when using the mechanism described in https://developers.google.com/+/web/signin/server-side-flow<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _IOSBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes a transaction receipt from an App Store in app purchase.<br/>The GameSparks platform will validate the receipt with Apple and process the response. The transaction_id in the response will be recorded and the request will be rejected if the transaction_id has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the product_id in the response with the 'IOS Product ID' configured against the virtual good.<br/>",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          receipt: {
            "!doc": "The receipt obtained from SKPaymentTransaction. transactionReceipt<br/>",
            "!type": "string"
          },
          sandbox: {
            "!doc": "Should the sandbox account be used<br/>",
            "!type": "bool"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _JoinChallengeRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to join an open challenge.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          eligibility: {
            "!doc": "Optional.  Allows the current player's eligibility to be overridden by what is provided here.<br/>",
            "!type": "?"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _JoinPendingMatchRequest: {
        "!type": "fn()",
        "!doc": "Requests to join a pending match (found via FindPendingMatchesRequest).<br/>",
        prototype: {
          matchGroup: {
            "!doc": "Optional. The matchGroup of the match this player previously registeredfor<br/>",
            "!type": "string"
          },
          matchShortCode: {
            "!doc": "The shortCode of the match this player previously registered for<br/>",
            "!type": "string"
          },
          pendingMatchId: {
            "!doc": "The pending match ID to join<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _JoinTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to join a team or a team to be retrieved.<br/>",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _KongregateConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Kongregate account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Kongregate platform and store them within GameSparks.<br/>If the Kongregate user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Kongregate user is not already registered with the game, the Kongregate user will be linked to the current player.<br/>If the current player has not authenticated and the Kongregate user is not known, a new player will be created using the Kongregate details and the session will be authenticated against the new player.<br/>If the Kongregate user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          gameAuthToken: {
            "!doc": "The gameAuthToken, together with the userID are used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          userId: {
            "!doc": "The userID, together with the gameAuthToken are used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _LeaderboardDataRequest: {
        "!type": "fn()",
        "!doc": "Returns the top data for either the specified global leaderboard or the specified challenges leaderboard. The data is sorted as defined in the rules specified in the leaderboard configuration.<br/>The response contains the top of the leaderboard, and returns the number of entries as defined in the entryCount parameter.<br/>If a shortCode is supplied, the response will contain the global leaderboard data. If a challengeInstanceId is supplied, the response will contain the leaderboard data for the challenge.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The challenge instance to get the leaderboard data for<br/>",
            "!type": "string"
          },
          dontErrorOnNotSocial: {
            "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
            "!type": "bool"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          friendIds: {
            "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
            "!type": "[string]"
          },
          includeFirst: {
            "!doc": "Number of entries to include from head of the list<br/>",
            "!type": "number"
          },
          includeLast: {
            "!doc": "Number of entries to include from tail of the list<br/>",
            "!type": "number"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboardShortCode: {
            "!doc": "The short code of the leaderboard<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset into the set of leaderboards returned<br/>",
            "!type": "number"
          },
          social: {
            "!doc": "If True returns a leaderboard of the player's social friends<br/>",
            "!type": "bool"
          },
          teamIds: {
            "!doc": "The IDs of the teams you are interested in<br/>",
            "!type": "[string]"
          },
          teamTypes: {
            "!doc": "The type of team you are interested in<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _LeaderboardsEntriesRequest: {
        "!type": "fn()",
        "!doc": "Get the leaderboard entry data for the current player or a given player.<br/>For each leaderboard it returns the array of leaderboard entries that the player has.<br/>",
        prototype: {
          challenges: {
            "!doc": "The challenge leaderboards to return entries for<br/>",
            "!type": "[string]"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboards: {
            "!doc": "The list of leaderboards shortcodes<br/>",
            "!type": "[string]"
          },
          player: {
            "!doc": "The player id. Leave out to use the current player id<br/>",
            "!type": "string"
          },
          social: {
            "!doc": "Set to true to include the player's game friends<br/>",
            "!type": "bool"
          },
          teamTypes: {
            "!doc": "The types of team to apply this request to<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _LeaveTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to leave a team.<br/>",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListAchievementsRequest: {
        "!type": "fn()",
        "!doc": "Retrieves a list of the configured achievements in the game, along with whether the current player has earned the achievement.<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListBulkJobsAdminRequest: {
        "!type": "fn()",
        "!doc": "Lists existing bulk jobs.<br/>",
        prototype: {
          bulkJobIds: {
            "!doc": "The IDs of existing bulk jobs to get details for<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListChallengeRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of challenges in the state defined in the 'state' field.<br/>The response can be further filtered by passing a shortCode field which will limit the returned lists to challenges of that short code.<br/>Valid states are:<br/>WAITING : The challenge has been issued and accepted and is waiting for the start date.<br/>RUNNING : The challenge is active.<br/>ISSUED : The challenge has been issued by the current player and is waiting to be accepted.<br/>RECEIVED : The challenge has been issued to the current player and is waiting to be accepted.<br/>COMPLETE : The challenge has completed.<br/>DECLINED : The challenge has been issued by the current player and has been declined.<br/>",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The type of challenge to return<br/>",
            "!type": "string"
          },
          state: {
            "!doc": "The state of the challenged to be returned<br/>",
            "!type": "string"
          },
          states: {
            "!doc": "The states of the challenges to be returned<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListChallengeTypeRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of configured challenge types.<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListGameFriendsRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current players game friends.<br/>A Game friend is someone in their social network who also plays the game.<br/>Against each friend, an indicator is supplied to show whether the friend is currently connected to the GameSparks service<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListInviteFriendsRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current players friends in their social network, who are not yet playing this game.<br/>This is dependent on the security and privacy policies of the social network.<br/>For example, Facebook's policies prevent this friend list being provided, whereas Twitter will supply a list of users who are not playing the game.<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListLeaderboardsRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of all leaderboards configured in the game.<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListMessageDetailRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current player's messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest Read the section on Messages to see the complete list of messages and their meaning.<br/>",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          include: {
            "!doc": "An optional filter that limits the message types returned<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          status: {
            "!doc": "The status of messages to be retrieved. If omitted, messages of all statuses will be retrieved<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListMessageRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current player's messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest Read the section on Messages to see the complete list of messages and their meaning.<br/>",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          include: {
            "!doc": "An optional filter that limits the message types returned<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListMessageSummaryRequest: {
        "!type": "fn()",
        "!doc": "Returns a summary of the list of the current players messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest.<br/>The full message can be retrieved using GetMessageRequest Read the section on Messages to see the complete list of messages and their meanings.<br/>",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListTeamChatRequest: {
        "!type": "fn()",
        "!doc": "Get a list of the messages sent to the team (by players using SendTeamChatMessageRequest).<br/>",
        prototype: {
          entryCount: {
            "!doc": "The number of messages to return (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (nth message) to start from (default=0)<br/>",
            "!type": "number"
          },
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListTeamsRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of teams. Can be filtered on team name or team type.<br/>",
        prototype: {
          entryCount: {
            "!doc": "The number of teams to return in a page (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          teamNameFilter: {
            "!doc": "An optional filter to return teams with a matching name<br/>",
            "!type": "string"
          },
          teamTypeFilter: {
            "!doc": "An optional filter to return teams of a particular type<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListTransactionsRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of the current player's transaction history.<br/>",
        prototype: {
          dateFrom: {
            "!doc": "Optional date constraint to list transactions from<br/>",
            "!type": "date"
          },
          dateTo: {
            "!doc": "Optional date constraint to list transactions to<br/>",
            "!type": "date"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          include: {
            "!doc": "An optional filter that limits the transaction types returned<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ListVirtualGoodsRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of configured virtual goods.<br/>",
        prototype: {
          includeDisabled: {
            "!doc": "If true, the returned list will include disabled VirtualVoods<br/>",
            "!type": "bool"
          },
          tags: {
            "!doc": "A filter to only include goods with the given tags. Each good must have all the provided tags.<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _LogChallengeEventRequest: {
        "!type": "fn()",
        "!doc": "Allows a user defined event to be triggered. The event will be posted to the challenge specified.<br/>This call differs from most as it does not have a fixed format. The @class, challengeInstanceId and eventKey attributes are common, but the rest of the attributes are as defined in the Event object configured in the dev portal.<br/>The example below shows a request to en event with a short code of HS with 2 attributes, 'HS' & 'GL'.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID challenge instance to target<br/>",
            "!type": "string"
          },
          eventKey: {
            "!doc": "The short code of the event to trigger<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _LogEventRequest: {
        "!type": "fn()",
        "!doc": "Allows a user defined event to be triggered.<br/>This call differs from most as it does not have a fixed format. The @class and eventKey attributes are common, but the rest of the attributes are as defined in the Event object configured in the dev portal.<br/>The example below shows a request to an event with a short code of HS with 2 attributes, 'HS' & 'GL'.<br/>",
        prototype: {
          eventKey: {
            "!doc": "The short code of the event to trigger<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _MatchDetailsRequest: {
        "!type": "fn()",
        "!doc": "Find the details of an existing match this player belongs to, using the matchId<br/>",
        prototype: {
          matchId: {
            "!doc": "The matchId to find the details of<br/>",
            "!type": "string"
          },
          realtimeEnabled: {
            "!doc": "Adds realtime server details if the match has been created using Cloud Code and it has not been realtime enabled<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _MatchmakingRequest: {
        "!type": "fn()",
        "!doc": "Register this player for matchmaking, using the given skill and matchShortCode.<br/>Players looking for a match using the same matchShortCode will be considered for a match, based on the matchConfig.<br/>Each player must match the other for the match to be found.<br/>If the matchShortCode points to a match with realtime enabled, in order to minimise latency, the location of Players and their proximity to one another takes precedence over their reciprocal skill values.<br/>",
        prototype: {
          action: {
            "!doc": "The action to take on the already in-flight request for this match. Currently supported actions are: 'cancel'<br/>",
            "!type": "string"
          },
          customQuery: {
            "!doc": "The query that will be applied to the PendingMatch collection<br/>",
            "!type": "?"
          },
          matchData: {
            "!doc": "A JSON Map of any data that will be associated to the pending match<br/>",
            "!type": "?"
          },
          matchGroup: {
            "!doc": "Optional. Players will be grouped based on the distinct value passed in here, only players in the same group can be matched together<br/>",
            "!type": "string"
          },
          matchShortCode: {
            "!doc": "The shortCode of the match type this player is registering for<br/>",
            "!type": "string"
          },
          participantData: {
            "!doc": "A JSON Map of any data that will be associated to this user in a pending match<br/>",
            "!type": "?"
          },
          skill: {
            "!doc": "The skill of the player looking for a match<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _NXConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Nintendo Network Service Account (NSA) to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the NSA and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the NSA is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the NSA is not already registered with the game, the NSA will be linked to the current player.<br/>If the current player has not authenticated and the NSA is not known, a new player will be created using the NSA details and the session will be authenticated against the new player.<br/>If the NSA is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accountPerLoginId: {
            "!doc": "Whether to create one GameSparks player per console login ID<br/>",
            "!type": "bool"
          },
          displayName: {
            "!doc": "The display name of the current player from NX. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          nsaIdToken: {
            "!doc": "The NSA ID token obtained from Nintendo<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _PSNConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a PSN account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the PSN platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the PSN user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the PSN user is not already registered with the game, the PSN user will be linked to the current player.<br/>If the current player has not authenticated and the PSN user is not known, a new player will be created using the PSN details and the session will be authenticated against the new player.<br/>If the PSN user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          authorizationCode: {
            "!doc": "The authorization code obtained from PSN, as described here https://ps4.scedev.net/resources/documents/SDK/latest/NpAuth-Reference/0008.html<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          redirectUri: {
            "!doc": "When using the authorization code obtained from PlayStation4/PlayStationVita/PlayStation3, this is not required.<br/>When using the authorization code obtained with the PC authentication gateway, set the URI issued from the Developer Network website.<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _PsnBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes an update of entitlement in PlayStation network.<br/>The GameSparks platform will update the 'use_count' for an entitlement (by default 'use_count' is 1).<br/>The request will be rejected if entitlement 'use_limit' is 0<br/>GampSparks platform by default will use internally saved PSN user access token<br/>",
        prototype: {
          authorizationCode: {
            "!doc": "The authorization code obtained from PSN, as described here https://ps4.scedev.net/resources/documents/SDK/latest/NpAuth-Reference/0008.html<br/>",
            "!type": "string"
          },
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          entitlementLabel: {
            "!doc": "Specify the entitlement label of the entitlement to update. (Not an entitlement ID).<br/>",
            "!type": "string"
          },
          redirectUri: {
            "!doc": "When using the authorization code obtained from PlayStation4/PlayStationVita/PlayStation3, this is not required.<br/>When using the authorization code obtained with the PC authentication gateway, set the URI issued from the Developer Network website.<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          useCount: {
            "!doc": "Optional - specify the quantity of the entitlement to use. Default = 1<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _PushRegistrationRequest: {
        "!type": "fn()",
        "!doc": "Registers the current device for push notifications. Currently GameSparks supports iOS, Android (GCM), FCM, Kindle, Viber & Microsoft Push notifications.<br/>Supply the device type, and the push notification identifier for the device.<br/>",
        prototype: {
          deviceOS: {
            "!doc": "The type of id, valid values are ios, android, fcm, wp8, w8, kindle or viber<br/>",
            "!type": "string"
          },
          pushId: {
            "!doc": "The push notification identifier for the device<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _QQConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a QQ access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the QQ platform and store them within GameSparks.<br/>If the QQ user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the QQ user is not already registered with the game, the QQ user will be linked to the current player.<br/>If the current player has not authenticated and the QQ user is not known, a new player will be created using the QQ details and the session will be authenticated against the new player.<br/>If the QQ user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained using the refresh token.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _RegistrationRequest: {
        "!type": "fn()",
        "!doc": "Allows a new player to be created using a username, password display name.<br/>",
        prototype: {
          displayName: {
            "!doc": "A display name to use<br/>",
            "!type": "string"
          },
          password: {
            "!doc": "The previously registered password<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          userName: {
            "!doc": "The previously registered player name<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _RevokePurchaseGoodsRequest: {
        "!type": "fn()",
        "!doc": "Revokes the purchase of a good. The items aquired will be removed from remaining items of the player.<br/>",
        prototype: {
          playerId: {
            "!doc": "The playerId for which to revoke the transaction<br/>",
            "!type": "string"
          },
          storeType: {
            "!doc": "The store type for which to revoke these transactions<br/>",
            "!type": "string"
          },
          transactionIds: {
            "!doc": "The list of transactionIds to revoke<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ScheduleBulkJobAdminRequest: {
        "!type": "fn()",
        "!doc": "Schedules a bulk job to be run against multiple players.<br/>",
        prototype: {
          data: {
            "!doc": "Optional data to be passed into the script<br/>",
            "!type": "_DBObject"
          },
          moduleShortCode: {
            "!doc": "The short code of the cloud code module to be executed against each player<br/>",
            "!type": "string"
          },
          playerQuery: {
            "!doc": "The query to be run against the player collection to identify which players to execute the cloud code for<br/>",
            "!type": "_DBObject"
          },
          scheduledTime: {
            "!doc": "An optional date and time for this job to be run<br/>",
            "!type": "date"
          },
          script: {
            "!doc": "The script to be executed against each player<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _SendFriendMessageRequest: {
        "!type": "fn()",
        "!doc": "Sends a message to one or more game friend(s). A game friend is someone in the players social network who also plays the game.<br/>",
        prototype: {
          friendIds: {
            "!doc": "One or more friend ID's. This can be supplied as a single string, or a JSON array<br/>",
            "!type": "[string]"
          },
          message: {
            "!doc": "The message to send<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _SendTeamChatMessageRequest: {
        "!type": "fn()",
        "!doc": "Send a message to all the players who are member of the given team<br/>",
        prototype: {
          message: {
            "!doc": "The message to send<br/>",
            "!type": "string"
          },
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _SocialDisconnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a player's internal profile to be disconnected from an external system to which it is linked. Any friends linked as result of this connection will be removed.<br/>",
        prototype: {
          systemId: {
            "!doc": "The external system from which to disconnect this profile, supplied as a two letter ID. The options are: {FACEBOOK:FB, AMAZON:AM, GAME_CENTER:GC<br/>GOOGLE_PLAY:GY , GOOGLE_PLUS:GP, KONGREGATE:KO, PSN:PS, QQ:QQ, STEAM:ST, TWITCH:TC, TWITTER:TW, VIBER:VB, WECHAT:WC, XBOX:XB<br/>XBOXONE:X1, NINTENDO:NX}<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _SocialLeaderboardDataRequest: {
        "!type": "fn()",
        "!doc": "Returns leaderboard data that only contains entries of players that are game friends with the current player.<br/>The GameSparks platform will attempt to return players both ahead and behind the current player, where data is available.<br/>The entry count defines how many player should be returned both ahead and behind. The numer of results may vary if there are not enough friends either ahead or behind.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The challenge instance to get the leaderboard data for<br/>",
            "!type": "string"
          },
          dontErrorOnNotSocial: {
            "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
            "!type": "bool"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          friendIds: {
            "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
            "!type": "[string]"
          },
          includeFirst: {
            "!doc": "Number of entries to include from head of the list<br/>",
            "!type": "number"
          },
          includeLast: {
            "!doc": "Number of entries to include from tail of the list<br/>",
            "!type": "number"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboardShortCode: {
            "!doc": "The short code of the leaderboard<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset into the set of leaderboards returned<br/>",
            "!type": "number"
          },
          social: {
            "!doc": "If True returns a leaderboard of the player's social friends<br/>",
            "!type": "bool"
          },
          teamIds: {
            "!doc": "The IDs of the teams you are interested in<br/>",
            "!type": "[string]"
          },
          teamTypes: {
            "!doc": "The type of team you are interested in<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _SocialStatusRequest: {
        "!type": "fn()",
        "!doc": "Returns detials of the current social connections of this player. Each connection .<br/>",
        prototype: {
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _SteamBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes a 'orderid' from a Steam.<br/>The GameSparks platform will validate the 'orderid' with Steam and process the response. The 'orderid' from the response will be recorded and the request will be rejected, if the 'orderid' has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the 'itemid' in the response with the 'Steam Product ID' configured against the virtual good.<br/>",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          orderId: {
            "!doc": "Unique 64-bit ID for order<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _SteamConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Steam sessionTicket to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Steam platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Steam user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Steam user is not already registered with the game, the Steam user will be linked to the current player.<br/>If the current player has not authenticated and the Steam user is not known, a new player will be created using the Steam details and the session will be authenticated against the new player.<br/>If the Steam user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          sessionTicket: {
            "!doc": "The hex encoded UTF-8 string representation of the ticket acquired calling the Steam SDKs GetAuthSessionTicket.<br/>",
            "!type": "string"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _TwitchConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Twitch account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Twitch platform and store them within GameSparks.<br/>If the Twitch user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Twitch user is not already registered with the game, the Twitch user will be linked to the current player.<br/>If the current player has not authenticated and the Twitch user is not known, a new player will be created using the Twitch details and the session will be authenticated against the new player.<br/>If the Twitch user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _TwitterConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Twitter account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Twitter platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Twitter user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Twitter user is not already registered with the game, the Twitter user will be linked to the current player.<br/>If the current player has not authenticated and the Twitter user is not known, a new player will be created using the Twitter details and the session will be authenticated against the new player.<br/>If the Twitter user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessSecret: {
            "!doc": "The accessSecret is obtained at the same time as the accessToken, and is required to sign requests to Twitter's services that require the accessToken.<br/>",
            "!type": "string"
          },
          accessToken: {
            "!doc": "The accessToken represents a player's permission to share access to their account with your application.<br/>To obtain an accessToken for the player see https://dev.twitter.com/docs/auth/obtaining-access-tokens.<br/>Currently, Twitter accessTokens do not expire but they can be revoked by the player.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _UpdateMessageRequest: {
        "!type": "fn()",
        "!doc": "Allows a message status to be updated.<br/>",
        prototype: {
          messageId: {
            "!doc": "The messageId of the message to update<br/>",
            "!type": "string"
          },
          status: {
            "!doc": "The status to set on the message<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _ViberConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Viber account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Viber platform and store them within GameSparks.<br/>A successful authentication will also register the player to receive Viber push notifications.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Viber user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Viber user is not already registered with the game, the Viber user will be linked to the current player.<br/>If the current player has not authenticated and the Viber user is not known, a new player will be created using the Viber details and the session will be authenticated against the new player.<br/>If the Viber user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The accessToken represents a player's permission to share access to their account with your application.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          doNotRegisterForPush: {
            "!doc": "Does not automatocally register this user for push notifications. Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _WeChatConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a WeChat access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the WeChat platform and store them within GameSparks.<br/>If the WeChat user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the WeChat user is not already registered with the game, the WeChat user will be linked to the current player.<br/>If the current player has not authenticated and the WeChat user is not known, a new player will be created using the WeChat details and the session will be authenticated against the new player.<br/>If the WeChat user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          accessToken: {
            "!doc": "The access token sould be obtained from WeChat<br/>It is used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          openId: {
            "!doc": "The open ID corresponding to the WeChat user<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _WindowsBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes a transaction receipt from a windows store purchase.<br/>The GameSparks platform will validate the receipt using the signature embedded in the xml. The Id in the xml will be recorded and the request will be rejected if the Id has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the xml with the 'WP8 Product ID' configured against the virtual good.<br/>",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          platform: {
            "!doc": "Allows you to specify the platform<br/>",
            "!type": "string"
          },
          receipt: {
            "!doc": "The xml reciept returned from the windows phone 8 store<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _WithdrawChallengeRequest: {
        "!type": "fn()",
        "!doc": "Withdraws a challenge previously issued by the current player.<br/>This can only be done while the challenge is in the ISSUED state. Once it's been accepted the challenge can not be withdrawn.<br/>",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _XBOXLiveConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Xbox Live Shared Token String to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Xbox Live and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Xbox user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Xbox user is not already registered with the game, the Xbox user will be linked to the current player.<br/>If the current player has not authenticated and the Xbox user is not known, a new player will be created using the Xbox details and the session will be authenticated against the new player.<br/>If the Xbox user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          displayName: {
            "!doc": "The displayName to set for the player in GameSparks<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          stsTokenString: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>It has a longer lifetime than the authorization code, typically on the order of minutes or hours.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained via a refresh token.<br/>",
            "!type": "string"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _XboxOneConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Xbox One XSTS token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from Xbox Live and store them within GameSparks.<br/>If the Xbox One user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Xbox One user is not already registered with the game, the Xbox One user will be linked to the current player.<br/>If the current player has not authenticated and the Xbox One user is not known, a new player will be created using the Xbox Live details and the session will be authenticated against the new player.<br/>If the Xbox One user is already known, the session will switch to being the previously created user.<br/>",
        prototype: {
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          sandbox: {
            "!doc": "The Xbox Live sandbox to use. If not specified, the sandbox from the decoded token will be used.<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          token: {
            "!doc": "The Xbox One authentication token<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      AcceptChallengeRequest: {
        "!type": "fn()",
        "!doc": "Accepts a challenge that has been issued to the current player.<br/>",
        "!proto": "SparkRequests._AcceptChallengeRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AcceptChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AcceptChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AcceptChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AcceptChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      AccountDetailsRequest: {
        "!type": "fn()",
        "!doc": "Retrieves the details of the current authenticated player.<br/>",
        "!proto": "SparkRequests._AccountDetailsRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AccountDetailsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AccountDetailsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AccountDetailsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AccountDetailsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      AmazonBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes the receipt from an Amazon in app purchase.<br/>The GameSparks platform will validate the amazonUserId and receiptId with Amazon using the Amazon Purchase Secret configured against the game.<br/>The receiptId in the data will be recorded and the request will be rejected if the receiptId has previously been processed, this prevents replay attacks.<br/>Once verfied, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the receipt with the 'Amazon Product Id' configured against the virtual good.<br/>",
        "!proto": "SparkRequests._AmazonBuyGoodsRequest",
        prototype: {
          amazonUserId: {
            "!doc": "The userId obtained from the UserData within a PurchaseResponse<br/>",
            "!type": "string"
          },
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          receiptId: {
            "!doc": "The receiptId obtained from the Receipt within a PurchaseResponse<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      AmazonConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Amazon access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Amazon platform and store them within GameSparks.<br/>If the Amazon user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Amazon user is not already registered with the game, the Amazon user will be linked to the current player.<br/>If the current player has not authenticated and the Amazon user is not known, a new player will be created using the Amazon details and the session will be authenticated against the new player.<br/>If the Amazon user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._AmazonConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      AnalyticsRequest: {
        "!type": "fn()",
        "!doc": "Records some custom analytical data.<br/>Simple analytics, where you just need to track the number of times something happened, just take a key parameter. We'll record the players id against the data to allow you to report on averages per user<br/>Timed analytics allow you to send start and end timer requests, and with this data GameSparks can track the length of time something takes.<br/>If an end request is sent without a matching start timer the request will fail silently and your analytics data might not contain what you expect.<br/>If both start and end are supplied, the request will be treated as a start timer.<br/>An additional data payload can be attached to the event for advanced reporting. This data can be a string, number or JSON object.<br/>If a second start timer is created using a key that has already had a start timer created without an end, the previous one will be marked as abandoned.<br/>",
        "!proto": "SparkRequests._AnalyticsRequest",
        prototype: {
          data: {
            "!doc": "Custom data payload<br/>",
            "!type": "?"
          },
          end: {
            "!doc": "Use the value true to indicate it's an end timer<br/>",
            "!type": "bool"
          },
          key: {
            "!doc": "The key you want to track this analysis with.<br/>",
            "!type": "string"
          },
          start: {
            "!doc": "Use the value true to indicate it's a start timer<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AnalyticsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AnalyticsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AnalyticsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AnalyticsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      AroundMeLeaderboardRequest: {
        "!type": "fn()",
        "!doc": "Returns leaderboard data that is adjacent to the currently signed in player's position within the given leaderboard.<br/>",
        "!proto": "SparkRequests._AroundMeLeaderboardRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The challenge instance to get the leaderboard data for<br/>",
            "!type": "string"
          },
          customIdFilter: {
            "!doc": "An optional filter on the customIds.<br/>If this request does not contain a custonIdFilter or if it is a partial filter, <br/>the leaderboard entries around the highest score for the given constraints will be returned.<br/>",
            "!type": "?"
          },
          dontErrorOnNotSocial: {
            "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
            "!type": "bool"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          friendIds: {
            "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
            "!type": "[string]"
          },
          includeFirst: {
            "!doc": "Number of entries to include from head of the list<br/>",
            "!type": "number"
          },
          includeLast: {
            "!doc": "Number of entries to include from tail of the list<br/>",
            "!type": "number"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboardShortCode: {
            "!doc": "The short code of the leaderboard<br/>",
            "!type": "string"
          },
          social: {
            "!doc": "If True returns a leaderboard of the player's social friends<br/>",
            "!type": "bool"
          },
          teamIds: {
            "!doc": "The IDs of the teams you are interested in<br/>",
            "!type": "[string]"
          },
          teamTypes: {
            "!doc": "The type of team you are interested in<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AroundMeLeaderboardResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AroundMeLeaderboardResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AroundMeLeaderboardResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AroundMeLeaderboardResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      AuthenticationRequest: {
        "!type": "fn()",
        "!doc": "Provides authentication using a username/password combination.<br/>The username will have been previously created using a RegistrationRequest.<br/>",
        "!proto": "SparkRequests._AuthenticationRequest",
        prototype: {
          password: {
            "!doc": "The previously registered password<br/>",
            "!type": "string"
          },
          userName: {
            "!doc": "The previously registered player name<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      BatchAdminRequest: {
        "!type": "fn()",
        "!doc": "Performs a request for multiple players.<br/>",
        "!proto": "SparkRequests._BatchAdminRequest",
        prototype: {
          playerIds: {
            "!doc": "The players to run the request for.<br/>",
            "!type": "[string]"
          },
          request: {
            "!doc": "The request to be run for each player.<br/>",
            "!type": "_DBObject"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BatchAdminResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BatchAdminResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BatchAdminResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BatchAdminResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      BuyVirtualGoodsRequest: {
        "!type": "fn()",
        "!doc": "Purchases a virtual good with an in game currency. Once purchased the virtual good will be added to the players account.<br/>",
        "!proto": "SparkRequests._BuyVirtualGoodsRequest",
        prototype: {
          currencyShortCode: {
            "!doc": "The short code of the currency to use<br/>",
            "!type": "string"
          },
          currencyType: {
            "!doc": "Which virtual currency to use. (1 to 6)<br/>",
            "!type": "number"
          },
          quantity: {
            "!doc": "The number of items to purchase<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The short code of the virtual good to be purchased<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      CancelBulkJobAdminRequest: {
        "!type": "fn()",
        "!doc": "Cancel one or more bulk jobs.<br/>",
        "!proto": "SparkRequests._CancelBulkJobAdminRequest",
        prototype: {
          bulkJobIds: {
            "!doc": "The IDs of existing bulk jobs to cancel<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._CancelBulkJobAdminResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._CancelBulkJobAdminResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._CancelBulkJobAdminResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._CancelBulkJobAdminResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ChangeUserDetailsRequest: {
        "!type": "fn()",
        "!doc": "Change the details of the currently signed in Player.<br/>",
        "!proto": "SparkRequests._ChangeUserDetailsRequest",
        prototype: {
          displayName: {
            "!doc": "The new display name to set in the player data.<br/>",
            "!type": "string"
          },
          language: {
            "!doc": "The new language code to set in the player data.<br/>",
            "!type": "string"
          },
          newPassword: {
            "!doc": "The new password to set in the player data.<br/>",
            "!type": "string"
          },
          oldPassword: {
            "!doc": "The player's existing password. If supplied it will be checked against the password stored in the player data. This allows you re-authenticate the player making the change.<br/>",
            "!type": "string"
          },
          userName: {
            "!doc": "The new userName with which this player will sign in.  If the player currently authenticates using device authentication this will upgrade their account and require them to use username and password authentication from now on.<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ChangeUserDetailsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ChangeUserDetailsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ChangeUserDetailsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ChangeUserDetailsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ChatOnChallengeRequest: {
        "!type": "fn()",
        "!doc": "Sends a message to all players involved in the challenge. The current player must be involved in the challenge for the message to be sent.<br/>As the message is sent to all players, the current player will also see details of the message in the response. Read the section on response message aggregation for a description of this.<br/>",
        "!proto": "SparkRequests._ChatOnChallengeRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ChatOnChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ChatOnChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ChatOnChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ChatOnChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ConsumeVirtualGoodRequest: {
        "!type": "fn()",
        "!doc": "Consumes a given amount of the specified virtual good.<br/>",
        "!proto": "SparkRequests._ConsumeVirtualGoodRequest",
        prototype: {
          quantity: {
            "!doc": "The amount of virtual goods to be consumed<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The short code of the virtual good to be consumed<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ConsumeVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ConsumeVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ConsumeVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ConsumeVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      CreateChallengeRequest: {
        "!type": "fn()",
        "!doc": "Issues a challenge to a group of players from the currently signed in player.<br/>The endTime field must be present unless the challenge template has an achievement set in the 'First to Achievement' field.<br/>The usersToChallenge field must be present for this request if the acessType is PRIVATE (which is the default).<br/>",
        "!proto": "SparkRequests._CreateChallengeRequest",
        prototype: {
          accessType: {
            "!doc": "Who can join this challenge. Either PUBLIC, PRIVATE or FRIENDS<br/>",
            "!type": "string"
          },
          autoStartJoinedChallengeOnMaxPlayers: {
            "!doc": "Whether this challenge should automatically start when a new player joins and maxPlayers is reached<br/>",
            "!type": "bool"
          },
          challengeMessage: {
            "!doc": "An optional message to include with the challenge<br/>",
            "!type": "string"
          },
          challengeShortCode: {
            "!doc": "The short code of the challenge<br/>",
            "!type": "string"
          },
          currency1Wager: {
            "!doc": "The ammount of currency type 1 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency2Wager: {
            "!doc": "The amount of currency type 2 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency3Wager: {
            "!doc": "The amount of currency type 3 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency4Wager: {
            "!doc": "The amount of currency type 4 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency5Wager: {
            "!doc": "The amount of currency type 5 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currency6Wager: {
            "!doc": "The amount of currency type 6 that the player is wagering on this challenge<br/>",
            "!type": "number"
          },
          currencyWagers: {
            "!doc": "A JSON object containing the amounts of named currencies that the player is wagering on this challenge<br/>",
            "!type": "?"
          },
          eligibilityCriteria: {
            "!doc": "Criteria for who can and cannot find and join this challenge (when the accessType is PUBLIC or FRIENDS).<br/>Currently supports a field <i>segments</i> that contains segment type against single (where that segment value is required) or multiple (where one of the specified values is required) segment values.<br/>For each segment type a player must have one of the specified values in order to be considered eligible.<br/>",
            "!type": "?"
          },
          endTime: {
            "!doc": "The time at which this challenge will end. This is required when the challenge is not linked to an achievement<br/>",
            "!type": "date"
          },
          expiryTime: {
            "!doc": "The latest time that players can join this challenge<br/>",
            "!type": "date"
          },
          maxAttempts: {
            "!doc": "The maximum number of attempts <br/>",
            "!type": "number"
          },
          maxPlayers: {
            "!doc": "The maximum number of players that are allowed to join this challenge<br/>",
            "!type": "number"
          },
          minPlayers: {
            "!doc": "The minimum number of players that are allowed to join this challenge<br/>",
            "!type": "number"
          },
          silent: {
            "!doc": "If True  no messaging is triggered<br/>",
            "!type": "bool"
          },
          startTime: {
            "!doc": "The time at which this challenge will begin<br/>",
            "!type": "date"
          },
          usersToChallenge: {
            "!doc": "A player id or an array of player ids who will recieve this challenge<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._CreateChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._CreateChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._CreateChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._CreateChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      CreateTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a new team to be created.<br/>",
        "!proto": "SparkRequests._CreateTeamRequest",
        prototype: {
          teamId: {
            "!doc": "An optional teamId to use<br/>",
            "!type": "string"
          },
          teamName: {
            "!doc": "A display name to use<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The type of team to be created<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._CreateTeamResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._CreateTeamResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._CreateTeamResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._CreateTeamResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      DeclineChallengeRequest: {
        "!type": "fn()",
        "!doc": "Declines a challenge that has been issued to the current player.<br/>",
        "!proto": "SparkRequests._DeclineChallengeRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._DeclineChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._DeclineChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._DeclineChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._DeclineChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      DeviceAuthenticationRequest: {
        "!type": "fn()",
        "!doc": "Allows a device id to be used to create an anonymous profile in the game.<br/>This allows the player to be tracked and have data stored against them before using FacebookConnectRequest to create a full profile.<br/>DeviceAuthenticationRequest should not be used in conjunction with RegistrationRequest as the two accounts will not be merged.<br/>",
        "!proto": "SparkRequests._DeviceAuthenticationRequest",
        prototype: {
          deviceId: {
            "!doc": "A unique device identifier. Each platform has it's own method for getting a unique id<br/>",
            "!type": "string"
          },
          deviceModel: {
            "!doc": "The device model<br/>",
            "!type": "string"
          },
          deviceName: {
            "!doc": "The device name<br/>",
            "!type": "string"
          },
          deviceOS: {
            "!doc": "An indicator of the device platform, should be IOS, ANDROID, WP8 or W8<br/>",
            "!type": "string"
          },
          deviceType: {
            "!doc": "The device type<br/>",
            "!type": "string"
          },
          displayName: {
            "!doc": "An optional displayname for the player<br/>",
            "!type": "string"
          },
          operatingSystem: {
            "!doc": "The device type<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request reates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      DismissMessageRequest: {
        "!type": "fn()",
        "!doc": "Allows a message to be dismissed. Once dismissed the message will no longer appear in either ListMessageResponse or ListMessageSummaryResponse.<br/>",
        "!proto": "SparkRequests._DismissMessageRequest",
        prototype: {
          messageId: {
            "!doc": "The messageId of the message to dismiss<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._DismissMessageResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._DismissMessageResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._DismissMessageResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._DismissMessageResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      DismissMultipleMessagesRequest: {
        "!type": "fn()",
        "!doc": "Allows multiple messages to be dismissed. Once dismissed the messages will no longer appear in either ListMessageResponse or ListMessageSummaryResponse.<br/>",
        "!proto": "SparkRequests._DismissMultipleMessagesRequest",
        prototype: {
          messageIds: {
            "!doc": "The list of the messageIds to dismiss<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._DismissMultipleMessagesResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._DismissMultipleMessagesResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._DismissMultipleMessagesResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._DismissMultipleMessagesResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      DropTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to drop a team.<br/>",
        "!proto": "SparkRequests._DropTeamRequest",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._DropTeamResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._DropTeamResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._DropTeamResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._DropTeamResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      EndSessionRequest: {
        "!type": "fn()",
        "!doc": "Records the end of the current player's active session.<br/>The SDK will automatically create a new session ID when the application is started, this method can be useful to call when the app goes into the background to allow reporting on player session length.<br/>",
        "!proto": "SparkRequests._EndSessionRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._EndSessionResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._EndSessionResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._EndSessionResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._EndSessionResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      FacebookConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows either a Facebook access token, or a Facebook authorization code to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Facebook platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Facebook user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the Facebook user is not already registered with the game, the Facebook user will be linked to the current player.<br/>If the current player has not authenticated and the Facebook user is not known, a new player will be created using the Facebook details and the session will be authenticated against the new player.<br/>If the Facebook user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._FacebookConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>It has a longer lifetime than the authorization code, typically on the order of minutes or hours.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained via a refresh token.<br/>",
            "!type": "string"
          },
          code: {
            "!doc": "An authorization code is a short-lived token representing the user's access grant, created by the authorization server and passed to the client application via the browser.<br/>The client application sends the authorization code to the authorization server to obtain an access token and, optionally, a refresh token.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      FindChallengeRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to find challenges that they are eligible to join.<br/>",
        "!proto": "SparkRequests._FindChallengeRequest",
        prototype: {
          accessType: {
            "!doc": "The type of challenge to find, either PUBLIC or FRIENDS.  Defaults to FRIENDS<br/>",
            "!type": "string"
          },
          count: {
            "!doc": "The number of challenges to return (MAX=50)<br/>",
            "!type": "number"
          },
          eligibility: {
            "!doc": "Optional.  Allows the current player's eligibility to be overridden by what is provided here.<br/>",
            "!type": "?"
          },
          offset: {
            "!doc": "The offset to start from when returning challenges (used for paging)<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "Optional shortCodes to filter the results by challenge type<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._FindChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._FindChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._FindChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._FindChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      FindPendingMatchesRequest: {
        "!type": "fn()",
        "!doc": "Find other pending matches that will match this player's previously submitted MatchmakingRequest.<br/>Used for manual matching of players, where you want control over which pending match should be chosen.<br/>Each player must match the other for the pending match to be found.<br/>",
        "!proto": "SparkRequests._FindPendingMatchesRequest",
        prototype: {
          matchGroup: {
            "!doc": "Optional. The matchGroup of the match this player previously registeredfor<br/>",
            "!type": "string"
          },
          matchShortCode: {
            "!doc": "The shortCode of the match this player previously registered for<br/>",
            "!type": "string"
          },
          maxMatchesToFind: {
            "!doc": "Optional. The maximum number of pending matches to return (default=10)<br/>",
            "!type": "number"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._FindPendingMatchesResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._FindPendingMatchesResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._FindPendingMatchesResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._FindPendingMatchesResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GameCenterConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Apple account that has GameCenter to be used as an authentication mechanism.<br/>The request must supply the GameCenter user details, such as the player id and username.<br/>If the GameCenter user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the GameCenter user is not already registered with the game, the GameCenter user will be linked to the current player.<br/>If the current player has not authenticated and the GameCenter user is not known, a new player will be created using the GameCenter details and the session will be authenticated against the new player.<br/>If the GameCenter user is already known, the session will switch to being the previously created user.<br/>This API call requires the output details from GKLocalPlayer.generateIdentityVerificationSignatureWithCompletionHandler on your iOS device<br/>",
        "!proto": "SparkRequests._GameCenterConnectRequest",
        prototype: {
          displayName: {
            "!doc": "The display of the current player from GameCenter. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          externalPlayerId: {
            "!doc": "The game center id of the current player. This value obtained be obtained from GKLocalPlayer playerID<br/>",
            "!type": "string"
          },
          publicKeyUrl: {
            "!doc": "The url from where we will download the public key. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler. <br/>",
            "!type": "string"
          },
          salt: {
            "!doc": "The salt is needed in order to prevent request forgery. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler and should be base64 encoded using [salt base64Encoding]<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          signature: {
            "!doc": "The signature is needed to validate that the request is genuine and that we can save the player. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler and should be base64 encoded using [signature base64Encoding]<br/>",
            "!type": "string"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          timestamp: {
            "!doc": "The timestamp is needed to validate the request signature. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler<br/>",
            "!type": "number"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetChallengeRequest: {
        "!type": "fn()",
        "!doc": "Gets the details of a challenge. The current player must be involved in the challenge for the request to succeed.<br/>",
        "!proto": "SparkRequests._GetChallengeRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetDownloadableRequest: {
        "!type": "fn()",
        "!doc": "Returns a secure, time sensitive url to allow the game to download a piece of downloadable content stored in the GameSparks platform.<br/>",
        "!proto": "SparkRequests._GetDownloadableRequest",
        prototype: {
          shortCode: {
            "!doc": "The short code of the Downloadable item<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetDownloadableResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetDownloadableResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetDownloadableResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetDownloadableResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetLeaderboardEntriesRequest: {
        "!type": "fn()",
        "!doc": "Get the leaderboard entry data for the current player or a given player.<br/>For each leaderboard it returns the hichest score the player has<br/>",
        "!proto": "SparkRequests._GetLeaderboardEntriesRequest",
        prototype: {
          challenges: {
            "!doc": "The challenge leaderboards to return entries for<br/>",
            "!type": "[string]"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboards: {
            "!doc": "The list of leaderboards shortcodes<br/>",
            "!type": "[string]"
          },
          player: {
            "!doc": "The player id. Leave out to use the current player id<br/>",
            "!type": "string"
          },
          social: {
            "!doc": "Set to true to include the player's game friends<br/>",
            "!type": "bool"
          },
          teamTypes: {
            "!doc": "The types of team to apply this request to<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetLeaderboardEntriesResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetLeaderboardEntriesResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetLeaderboardEntriesResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetLeaderboardEntriesResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetMessageRequest: {
        "!type": "fn()",
        "!doc": "Returns the full details of a message.<br/>",
        "!proto": "SparkRequests._GetMessageRequest",
        prototype: {
          messageId: {
            "!doc": "The messageId of the message retreive<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetMessageResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetMessageResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetMessageResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetMessageResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetMyTeamsRequest: {
        "!type": "fn()",
        "!doc": "Get the teams that the player is in. Can be filtered on team type and also on those teams that the player owns.<br/>",
        "!proto": "SparkRequests._GetMyTeamsRequest",
        prototype: {
          ownedOnly: {
            "!doc": "Set to true to only get teams owned by the player<br/>",
            "!type": "bool"
          },
          teamTypes: {
            "!doc": "The type of teams to get<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetMyTeamsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetMyTeamsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetMyTeamsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetMyTeamsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetPropertyRequest: {
        "!type": "fn()",
        "!doc": "Get the property for the given short Code.<br/>",
        "!proto": "SparkRequests._GetPropertyRequest",
        prototype: {
          propertyShortCode: {
            "!doc": "The shortCode of the property to return.<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetPropertyResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetPropertyResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetPropertyResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetPropertyResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetPropertySetRequest: {
        "!type": "fn()",
        "!doc": "Get the property set for the given short Code.<br/>",
        "!proto": "SparkRequests._GetPropertySetRequest",
        prototype: {
          propertySetShortCode: {
            "!doc": "The shortCode of the property set to return.<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetPropertySetResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetPropertySetResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetPropertySetResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetPropertySetResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows the details of a team to be retrieved.<br/>",
        "!proto": "SparkRequests._GetTeamRequest",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetTeamResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetTeamResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetTeamResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetTeamResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetUploadUrlRequest: {
        "!type": "fn()",
        "!doc": "Returns a secure, time sensitive URL to allow the game to upload a piece of player content to the GameSparks platform.<br/>",
        "!proto": "SparkRequests._GetUploadUrlRequest",
        prototype: {
          uploadData: {
            "!doc": "Optional meta data which is stored against the player's uploaded content<br/>",
            "!type": "[?]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetUploadUrlResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetUploadUrlResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetUploadUrlResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetUploadUrlResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GetUploadedRequest: {
        "!type": "fn()",
        "!doc": "Returns a secure, time sensitive URL to a piece of content that was previously uploaded to the GameSparks platform by a player.<br/>",
        "!proto": "SparkRequests._GetUploadedRequest",
        prototype: {
          uploadId: {
            "!doc": "The system generated id of the uploaded item<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._GetUploadedResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._GetUploadedResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._GetUploadedResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._GetUploadedResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GooglePlayBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes the response from a Google Play in app purchase flow.<br/>The GameSparks platform will validate the signature and signed data with the Google Play Public Key configured against the game.<br/>The orderId in the data will be recorded and the request will be rejected if the orderId has previously been processed, this prevents replay attacks.<br/>Once verfied, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the signed data with the 'Google Product ID' configured against the virtual good.<br/>It is critical that the signedData is sent exactly as it is returned form google, including any whitespace. Any modification of the signedData will cause the verification process to fail.<br/>",
        "!proto": "SparkRequests._GooglePlayBuyGoodsRequest",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          signature: {
            "!doc": 'The value obtained from data.getStringExtra("INAPP_DATA_SIGNATURE");<br/>',
            "!type": "string"
          },
          signedData: {
            "!doc": 'The value obtained from data.getStringExtra("INAPP_PURCHASE_DATA")<br/>',
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GooglePlayConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows either a Google Play access code or an access token to be used as an authentication mechanism.<br/>The access code needs to have at least the https://www.googleapis.com/auth/games scope.<br/>For more details about Google OAuth 2.0 scopes refer to this: https://developers.google.com/identity/protocols/googlescopes#gamesConfigurationv1configuration<br/>If the Google Play user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Google Play user is not already registered with the game, the Google Play user will be linked to the current player.<br/>If the current player has not authenticated and the Google Play user is not known, a new player will be created using the Google Play details and the session will be authenticated against the new player.<br/>If the Google Play user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._GooglePlayConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The access token is used when using the service id and certificate.<br/>",
            "!type": "string"
          },
          code: {
            "!doc": "The access code is used by the client to make authenticated requests on behalf of the end user. Requires clientId and clientsecret to be set<br/>",
            "!type": "string"
          },
          displayName: {
            "!doc": "The display of the current player from Google Play. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          googlePlusScope: {
            "!doc": "Did you request the plus.login scope when you got the access code or authorisation token from Google? If this is true, we will fetch the user's google+ account and friends<br/>",
            "!type": "bool"
          },
          profileScope: {
            "!doc": "Did you request the profile scope when you got the access code or authorisation token from Google? If this is true, we will fetch the user info by calling https://www.googleapis.com/oauth2/v1/userinfo?alt=json <br/>",
            "!type": "bool"
          },
          redirectUri: {
            "!doc": "Only required when the access code has been granted using an explicit redirectUri, for example when using the mechanism described in https://developers.google.com/+/web/signin/server-side-flow<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      GooglePlusConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows either a Google Plus access code or an authentication token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Google Plus platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Google Plus user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Google Plus user is not already registered with the game, the Google Plus user will be linked to the current player.<br/>If the current player has not authenticated and the Google Plus user is not known, a new player will be created using the Google Plus details and the session will be authenticated against the new player.<br/>If the Google Plus user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._GooglePlusConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The access token is used when using the service id and certificate.<br/>",
            "!type": "string"
          },
          code: {
            "!doc": "The access code is used by the client to make authenticated requests on behalf of the end user. Requires clientId and clientsecret to be set<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          redirectUri: {
            "!doc": "Only required when the access code has been granted using an explicit redirectUri, for example when using the mechanism described in https://developers.google.com/+/web/signin/server-side-flow<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      IOSBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes a transaction receipt from an App Store in app purchase.<br/>The GameSparks platform will validate the receipt with Apple and process the response. The transaction_id in the response will be recorded and the request will be rejected if the transaction_id has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the product_id in the response with the 'IOS Product ID' configured against the virtual good.<br/>",
        "!proto": "SparkRequests._IOSBuyGoodsRequest",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          receipt: {
            "!doc": "The receipt obtained from SKPaymentTransaction. transactionReceipt<br/>",
            "!type": "string"
          },
          sandbox: {
            "!doc": "Should the sandbox account be used<br/>",
            "!type": "bool"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      JoinChallengeRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to join an open challenge.<br/>",
        "!proto": "SparkRequests._JoinChallengeRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          eligibility: {
            "!doc": "Optional.  Allows the current player's eligibility to be overridden by what is provided here.<br/>",
            "!type": "?"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._JoinChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._JoinChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._JoinChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._JoinChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      JoinPendingMatchRequest: {
        "!type": "fn()",
        "!doc": "Requests to join a pending match (found via FindPendingMatchesRequest).<br/>",
        "!proto": "SparkRequests._JoinPendingMatchRequest",
        prototype: {
          matchGroup: {
            "!doc": "Optional. The matchGroup of the match this player previously registeredfor<br/>",
            "!type": "string"
          },
          matchShortCode: {
            "!doc": "The shortCode of the match this player previously registered for<br/>",
            "!type": "string"
          },
          pendingMatchId: {
            "!doc": "The pending match ID to join<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._JoinPendingMatchResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._JoinPendingMatchResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._JoinPendingMatchResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._JoinPendingMatchResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      JoinTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to join a team or a team to be retrieved.<br/>",
        "!proto": "SparkRequests._JoinTeamRequest",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._JoinTeamResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._JoinTeamResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._JoinTeamResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._JoinTeamResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      KongregateConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Kongregate account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Kongregate platform and store them within GameSparks.<br/>If the Kongregate user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Kongregate user is not already registered with the game, the Kongregate user will be linked to the current player.<br/>If the current player has not authenticated and the Kongregate user is not known, a new player will be created using the Kongregate details and the session will be authenticated against the new player.<br/>If the Kongregate user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._KongregateConnectRequest",
        prototype: {
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          gameAuthToken: {
            "!doc": "The gameAuthToken, together with the userID are used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          userId: {
            "!doc": "The userID, together with the gameAuthToken are used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      LeaderboardDataRequest: {
        "!type": "fn()",
        "!doc": "Returns the top data for either the specified global leaderboard or the specified challenges leaderboard. The data is sorted as defined in the rules specified in the leaderboard configuration.<br/>The response contains the top of the leaderboard, and returns the number of entries as defined in the entryCount parameter.<br/>If a shortCode is supplied, the response will contain the global leaderboard data. If a challengeInstanceId is supplied, the response will contain the leaderboard data for the challenge.<br/>",
        "!proto": "SparkRequests._LeaderboardDataRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The challenge instance to get the leaderboard data for<br/>",
            "!type": "string"
          },
          dontErrorOnNotSocial: {
            "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
            "!type": "bool"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          friendIds: {
            "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
            "!type": "[string]"
          },
          includeFirst: {
            "!doc": "Number of entries to include from head of the list<br/>",
            "!type": "number"
          },
          includeLast: {
            "!doc": "Number of entries to include from tail of the list<br/>",
            "!type": "number"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboardShortCode: {
            "!doc": "The short code of the leaderboard<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset into the set of leaderboards returned<br/>",
            "!type": "number"
          },
          social: {
            "!doc": "If True returns a leaderboard of the player's social friends<br/>",
            "!type": "bool"
          },
          teamIds: {
            "!doc": "The IDs of the teams you are interested in<br/>",
            "!type": "[string]"
          },
          teamTypes: {
            "!doc": "The type of team you are interested in<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._LeaderboardDataResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._LeaderboardDataResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._LeaderboardDataResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._LeaderboardDataResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      LeaderboardsEntriesRequest: {
        "!type": "fn()",
        "!doc": "Get the leaderboard entry data for the current player or a given player.<br/>For each leaderboard it returns the array of leaderboard entries that the player has.<br/>",
        "!proto": "SparkRequests._LeaderboardsEntriesRequest",
        prototype: {
          challenges: {
            "!doc": "The challenge leaderboards to return entries for<br/>",
            "!type": "[string]"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboards: {
            "!doc": "The list of leaderboards shortcodes<br/>",
            "!type": "[string]"
          },
          player: {
            "!doc": "The player id. Leave out to use the current player id<br/>",
            "!type": "string"
          },
          social: {
            "!doc": "Set to true to include the player's game friends<br/>",
            "!type": "bool"
          },
          teamTypes: {
            "!doc": "The types of team to apply this request to<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._LeaderboardsEntriesResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._LeaderboardsEntriesResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._LeaderboardsEntriesResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._LeaderboardsEntriesResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      LeaveTeamRequest: {
        "!type": "fn()",
        "!doc": "Allows a player to leave a team.<br/>",
        "!proto": "SparkRequests._LeaveTeamRequest",
        prototype: {
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._LeaveTeamResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._LeaveTeamResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._LeaveTeamResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._LeaveTeamResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListAchievementsRequest: {
        "!type": "fn()",
        "!doc": "Retrieves a list of the configured achievements in the game, along with whether the current player has earned the achievement.<br/>",
        "!proto": "SparkRequests._ListAchievementsRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListAchievementsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListAchievementsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListAchievementsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListAchievementsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListBulkJobsAdminRequest: {
        "!type": "fn()",
        "!doc": "Lists existing bulk jobs.<br/>",
        "!proto": "SparkRequests._ListBulkJobsAdminRequest",
        prototype: {
          bulkJobIds: {
            "!doc": "The IDs of existing bulk jobs to get details for<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListBulkJobsAdminResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListBulkJobsAdminResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListBulkJobsAdminResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListBulkJobsAdminResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListChallengeRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of challenges in the state defined in the 'state' field.<br/>The response can be further filtered by passing a shortCode field which will limit the returned lists to challenges of that short code.<br/>Valid states are:<br/>WAITING : The challenge has been issued and accepted and is waiting for the start date.<br/>RUNNING : The challenge is active.<br/>ISSUED : The challenge has been issued by the current player and is waiting to be accepted.<br/>RECEIVED : The challenge has been issued to the current player and is waiting to be accepted.<br/>COMPLETE : The challenge has completed.<br/>DECLINED : The challenge has been issued by the current player and has been declined.<br/>",
        "!proto": "SparkRequests._ListChallengeRequest",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The type of challenge to return<br/>",
            "!type": "string"
          },
          state: {
            "!doc": "The state of the challenged to be returned<br/>",
            "!type": "string"
          },
          states: {
            "!doc": "The states of the challenges to be returned<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListChallengeTypeRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of configured challenge types.<br/>",
        "!proto": "SparkRequests._ListChallengeTypeRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListChallengeTypeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListChallengeTypeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListChallengeTypeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListChallengeTypeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListGameFriendsRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current players game friends.<br/>A Game friend is someone in their social network who also plays the game.<br/>Against each friend, an indicator is supplied to show whether the friend is currently connected to the GameSparks service<br/>",
        "!proto": "SparkRequests._ListGameFriendsRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListGameFriendsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListGameFriendsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListGameFriendsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListGameFriendsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListInviteFriendsRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current players friends in their social network, who are not yet playing this game.<br/>This is dependent on the security and privacy policies of the social network.<br/>For example, Facebook's policies prevent this friend list being provided, whereas Twitter will supply a list of users who are not playing the game.<br/>",
        "!proto": "SparkRequests._ListInviteFriendsRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListInviteFriendsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListInviteFriendsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListInviteFriendsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListInviteFriendsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListLeaderboardsRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of all leaderboards configured in the game.<br/>",
        "!proto": "SparkRequests._ListLeaderboardsRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListLeaderboardsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListLeaderboardsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListLeaderboardsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListLeaderboardsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListMessageDetailRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current player's messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest Read the section on Messages to see the complete list of messages and their meaning.<br/>",
        "!proto": "SparkRequests._ListMessageDetailRequest",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          include: {
            "!doc": "An optional filter that limits the message types returned<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          status: {
            "!doc": "The status of messages to be retrieved. If omitted, messages of all statuses will be retrieved<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListMessageDetailResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListMessageDetailResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListMessageDetailResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListMessageDetailResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListMessageRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of the current player's messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest Read the section on Messages to see the complete list of messages and their meaning.<br/>",
        "!proto": "SparkRequests._ListMessageRequest",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          include: {
            "!doc": "An optional filter that limits the message types returned<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListMessageResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListMessageResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListMessageResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListMessageResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListMessageSummaryRequest: {
        "!type": "fn()",
        "!doc": "Returns a summary of the list of the current players messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest.<br/>The full message can be retrieved using GetMessageRequest Read the section on Messages to see the complete list of messages and their meanings.<br/>",
        "!proto": "SparkRequests._ListMessageSummaryRequest",
        prototype: {
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListMessageSummaryResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListMessageSummaryResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListMessageSummaryResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListMessageSummaryResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListTeamChatRequest: {
        "!type": "fn()",
        "!doc": "Get a list of the messages sent to the team (by players using SendTeamChatMessageRequest).<br/>",
        "!proto": "SparkRequests._ListTeamChatRequest",
        prototype: {
          entryCount: {
            "!doc": "The number of messages to return (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (nth message) to start from (default=0)<br/>",
            "!type": "number"
          },
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListTeamChatResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListTeamChatResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListTeamChatResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListTeamChatResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListTeamsRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of teams. Can be filtered on team name or team type.<br/>",
        "!proto": "SparkRequests._ListTeamsRequest",
        prototype: {
          entryCount: {
            "!doc": "The number of teams to return in a page (default=50)<br/>",
            "!type": "number"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          teamNameFilter: {
            "!doc": "An optional filter to return teams with a matching name<br/>",
            "!type": "string"
          },
          teamTypeFilter: {
            "!doc": "An optional filter to return teams of a particular type<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListTeamsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListTeamsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListTeamsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListTeamsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListTransactionsRequest: {
        "!type": "fn()",
        "!doc": "Returns a list of the current player's transaction history.<br/>",
        "!proto": "SparkRequests._ListTransactionsRequest",
        prototype: {
          dateFrom: {
            "!doc": "Optional date constraint to list transactions from<br/>",
            "!type": "date"
          },
          dateTo: {
            "!doc": "Optional date constraint to list transactions to<br/>",
            "!type": "date"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          include: {
            "!doc": "An optional filter that limits the transaction types returned<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset (page number) to start from (default=0)<br/>",
            "!type": "number"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListTransactionsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListTransactionsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListTransactionsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListTransactionsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ListVirtualGoodsRequest: {
        "!type": "fn()",
        "!doc": "Returns the list of configured virtual goods.<br/>",
        "!proto": "SparkRequests._ListVirtualGoodsRequest",
        prototype: {
          includeDisabled: {
            "!doc": "If true, the returned list will include disabled VirtualVoods<br/>",
            "!type": "bool"
          },
          tags: {
            "!doc": "A filter to only include goods with the given tags. Each good must have all the provided tags.<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ListVirtualGoodsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ListVirtualGoodsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ListVirtualGoodsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ListVirtualGoodsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      LogChallengeEventRequest: {
        "!type": "fn()",
        "!doc": "Allows a user defined event to be triggered. The event will be posted to the challenge specified.<br/>This call differs from most as it does not have a fixed format. The @class, challengeInstanceId and eventKey attributes are common, but the rest of the attributes are as defined in the Event object configured in the dev portal.<br/>The example below shows a request to en event with a short code of HS with 2 attributes, 'HS' & 'GL'.<br/>",
        "!proto": "SparkRequests._LogChallengeEventRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID challenge instance to target<br/>",
            "!type": "string"
          },
          eventKey: {
            "!doc": "The short code of the event to trigger<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._LogChallengeEventResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._LogChallengeEventResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._LogChallengeEventResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._LogChallengeEventResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      LogEventRequest: {
        "!type": "fn()",
        "!doc": "Allows a user defined event to be triggered.<br/>This call differs from most as it does not have a fixed format. The @class and eventKey attributes are common, but the rest of the attributes are as defined in the Event object configured in the dev portal.<br/>The example below shows a request to an event with a short code of HS with 2 attributes, 'HS' & 'GL'.<br/>",
        "!proto": "SparkRequests._LogEventRequest",
        prototype: {
          eventKey: {
            "!doc": "The short code of the event to trigger<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._LogEventResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._LogEventResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._LogEventResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._LogEventResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      MatchDetailsRequest: {
        "!type": "fn()",
        "!doc": "Find the details of an existing match this player belongs to, using the matchId<br/>",
        "!proto": "SparkRequests._MatchDetailsRequest",
        prototype: {
          matchId: {
            "!doc": "The matchId to find the details of<br/>",
            "!type": "string"
          },
          realtimeEnabled: {
            "!doc": "Adds realtime server details if the match has been created using Cloud Code and it has not been realtime enabled<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._MatchDetailsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._MatchDetailsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._MatchDetailsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._MatchDetailsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      MatchmakingRequest: {
        "!type": "fn()",
        "!doc": "Register this player for matchmaking, using the given skill and matchShortCode.<br/>Players looking for a match using the same matchShortCode will be considered for a match, based on the matchConfig.<br/>Each player must match the other for the match to be found.<br/>If the matchShortCode points to a match with realtime enabled, in order to minimise latency, the location of Players and their proximity to one another takes precedence over their reciprocal skill values.<br/>",
        "!proto": "SparkRequests._MatchmakingRequest",
        prototype: {
          action: {
            "!doc": "The action to take on the already in-flight request for this match. Currently supported actions are: 'cancel'<br/>",
            "!type": "string"
          },
          customQuery: {
            "!doc": "The query that will be applied to the PendingMatch collection<br/>",
            "!type": "?"
          },
          matchData: {
            "!doc": "A JSON Map of any data that will be associated to the pending match<br/>",
            "!type": "?"
          },
          matchGroup: {
            "!doc": "Optional. Players will be grouped based on the distinct value passed in here, only players in the same group can be matched together<br/>",
            "!type": "string"
          },
          matchShortCode: {
            "!doc": "The shortCode of the match type this player is registering for<br/>",
            "!type": "string"
          },
          participantData: {
            "!doc": "A JSON Map of any data that will be associated to this user in a pending match<br/>",
            "!type": "?"
          },
          skill: {
            "!doc": "The skill of the player looking for a match<br/>",
            "!type": "number"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._MatchmakingResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._MatchmakingResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._MatchmakingResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._MatchmakingResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      NXConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Nintendo Network Service Account (NSA) to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the NSA and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the NSA is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the NSA is not already registered with the game, the NSA will be linked to the current player.<br/>If the current player has not authenticated and the NSA is not known, a new player will be created using the NSA details and the session will be authenticated against the new player.<br/>If the NSA is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._NXConnectRequest",
        prototype: {
          accountPerLoginId: {
            "!doc": "Whether to create one GameSparks player per console login ID<br/>",
            "!type": "bool"
          },
          displayName: {
            "!doc": "The display name of the current player from NX. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          nsaIdToken: {
            "!doc": "The NSA ID token obtained from Nintendo<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      PSNConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a PSN account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the PSN platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the PSN user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the PSN user is not already registered with the game, the PSN user will be linked to the current player.<br/>If the current player has not authenticated and the PSN user is not known, a new player will be created using the PSN details and the session will be authenticated against the new player.<br/>If the PSN user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._PSNConnectRequest",
        prototype: {
          authorizationCode: {
            "!doc": "The authorization code obtained from PSN, as described here https://ps4.scedev.net/resources/documents/SDK/latest/NpAuth-Reference/0008.html<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          redirectUri: {
            "!doc": "When using the authorization code obtained from PlayStation4/PlayStationVita/PlayStation3, this is not required.<br/>When using the authorization code obtained with the PC authentication gateway, set the URI issued from the Developer Network website.<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      PsnBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes an update of entitlement in PlayStation network.<br/>The GameSparks platform will update the 'use_count' for an entitlement (by default 'use_count' is 1).<br/>The request will be rejected if entitlement 'use_limit' is 0<br/>GampSparks platform by default will use internally saved PSN user access token<br/>",
        "!proto": "SparkRequests._PsnBuyGoodsRequest",
        prototype: {
          authorizationCode: {
            "!doc": "The authorization code obtained from PSN, as described here https://ps4.scedev.net/resources/documents/SDK/latest/NpAuth-Reference/0008.html<br/>",
            "!type": "string"
          },
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          entitlementLabel: {
            "!doc": "Specify the entitlement label of the entitlement to update. (Not an entitlement ID).<br/>",
            "!type": "string"
          },
          redirectUri: {
            "!doc": "When using the authorization code obtained from PlayStation4/PlayStationVita/PlayStation3, this is not required.<br/>When using the authorization code obtained with the PC authentication gateway, set the URI issued from the Developer Network website.<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          useCount: {
            "!doc": "Optional - specify the quantity of the entitlement to use. Default = 1<br/>",
            "!type": "number"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      PushRegistrationRequest: {
        "!type": "fn()",
        "!doc": "Registers the current device for push notifications. Currently GameSparks supports iOS, Android (GCM), FCM, Kindle, Viber & Microsoft Push notifications.<br/>Supply the device type, and the push notification identifier for the device.<br/>",
        "!proto": "SparkRequests._PushRegistrationRequest",
        prototype: {
          deviceOS: {
            "!doc": "The type of id, valid values are ios, android, fcm, wp8, w8, kindle or viber<br/>",
            "!type": "string"
          },
          pushId: {
            "!doc": "The push notification identifier for the device<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._PushRegistrationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._PushRegistrationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._PushRegistrationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._PushRegistrationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      QQConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a QQ access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the QQ platform and store them within GameSparks.<br/>If the QQ user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the QQ user is not already registered with the game, the QQ user will be linked to the current player.<br/>If the current player has not authenticated and the QQ user is not known, a new player will be created using the QQ details and the session will be authenticated against the new player.<br/>If the QQ user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._QQConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained using the refresh token.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      RegistrationRequest: {
        "!type": "fn()",
        "!doc": "Allows a new player to be created using a username, password display name.<br/>",
        "!proto": "SparkRequests._RegistrationRequest",
        prototype: {
          displayName: {
            "!doc": "A display name to use<br/>",
            "!type": "string"
          },
          password: {
            "!doc": "The previously registered password<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          userName: {
            "!doc": "The previously registered player name<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._RegistrationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._RegistrationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._RegistrationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._RegistrationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      RevokePurchaseGoodsRequest: {
        "!type": "fn()",
        "!doc": "Revokes the purchase of a good. The items aquired will be removed from remaining items of the player.<br/>",
        "!proto": "SparkRequests._RevokePurchaseGoodsRequest",
        prototype: {
          playerId: {
            "!doc": "The playerId for which to revoke the transaction<br/>",
            "!type": "string"
          },
          storeType: {
            "!doc": "The store type for which to revoke these transactions<br/>",
            "!type": "string"
          },
          transactionIds: {
            "!doc": "The list of transactionIds to revoke<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._RevokePurchaseGoodsResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._RevokePurchaseGoodsResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._RevokePurchaseGoodsResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._RevokePurchaseGoodsResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ScheduleBulkJobAdminRequest: {
        "!type": "fn()",
        "!doc": "Schedules a bulk job to be run against multiple players.<br/>",
        "!proto": "SparkRequests._ScheduleBulkJobAdminRequest",
        prototype: {
          data: {
            "!doc": "Optional data to be passed into the script<br/>",
            "!type": "_DBObject"
          },
          moduleShortCode: {
            "!doc": "The short code of the cloud code module to be executed against each player<br/>",
            "!type": "string"
          },
          playerQuery: {
            "!doc": "The query to be run against the player collection to identify which players to execute the cloud code for<br/>",
            "!type": "_DBObject"
          },
          scheduledTime: {
            "!doc": "An optional date and time for this job to be run<br/>",
            "!type": "date"
          },
          script: {
            "!doc": "The script to be executed against each player<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._ScheduleBulkJobAdminResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._ScheduleBulkJobAdminResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._ScheduleBulkJobAdminResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._ScheduleBulkJobAdminResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      SendFriendMessageRequest: {
        "!type": "fn()",
        "!doc": "Sends a message to one or more game friend(s). A game friend is someone in the players social network who also plays the game.<br/>",
        "!proto": "SparkRequests._SendFriendMessageRequest",
        prototype: {
          friendIds: {
            "!doc": "One or more friend ID's. This can be supplied as a single string, or a JSON array<br/>",
            "!type": "[string]"
          },
          message: {
            "!doc": "The message to send<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._SendFriendMessageResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._SendFriendMessageResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._SendFriendMessageResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._SendFriendMessageResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      SendTeamChatMessageRequest: {
        "!type": "fn()",
        "!doc": "Send a message to all the players who are member of the given team<br/>",
        "!proto": "SparkRequests._SendTeamChatMessageRequest",
        prototype: {
          message: {
            "!doc": "The message to send<br/>",
            "!type": "string"
          },
          ownerId: {
            "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
            "!type": "string"
          },
          teamId: {
            "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._SendTeamChatMessageResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._SendTeamChatMessageResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._SendTeamChatMessageResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._SendTeamChatMessageResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      SocialDisconnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a player's internal profile to be disconnected from an external system to which it is linked. Any friends linked as result of this connection will be removed.<br/>",
        "!proto": "SparkRequests._SocialDisconnectRequest",
        prototype: {
          systemId: {
            "!doc": "The external system from which to disconnect this profile, supplied as a two letter ID. The options are: {FACEBOOK:FB, AMAZON:AM, GAME_CENTER:GC<br/>GOOGLE_PLAY:GY , GOOGLE_PLUS:GP, KONGREGATE:KO, PSN:PS, QQ:QQ, STEAM:ST, TWITCH:TC, TWITTER:TW, VIBER:VB, WECHAT:WC, XBOX:XB<br/>XBOXONE:X1, NINTENDO:NX}<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._SocialDisconnectResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._SocialDisconnectResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._SocialDisconnectResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._SocialDisconnectResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      SocialLeaderboardDataRequest: {
        "!type": "fn()",
        "!doc": "Returns leaderboard data that only contains entries of players that are game friends with the current player.<br/>The GameSparks platform will attempt to return players both ahead and behind the current player, where data is available.<br/>The entry count defines how many player should be returned both ahead and behind. The numer of results may vary if there are not enough friends either ahead or behind.<br/>",
        "!proto": "SparkRequests._SocialLeaderboardDataRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The challenge instance to get the leaderboard data for<br/>",
            "!type": "string"
          },
          dontErrorOnNotSocial: {
            "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
            "!type": "bool"
          },
          entryCount: {
            "!doc": "The number of items to return in a page (default=50)<br/>",
            "!type": "number"
          },
          friendIds: {
            "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
            "!type": "[string]"
          },
          includeFirst: {
            "!doc": "Number of entries to include from head of the list<br/>",
            "!type": "number"
          },
          includeLast: {
            "!doc": "Number of entries to include from tail of the list<br/>",
            "!type": "number"
          },
          inverseSocial: {
            "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
            "!type": "bool"
          },
          leaderboardShortCode: {
            "!doc": "The short code of the leaderboard<br/>",
            "!type": "string"
          },
          offset: {
            "!doc": "The offset into the set of leaderboards returned<br/>",
            "!type": "number"
          },
          social: {
            "!doc": "If True returns a leaderboard of the player's social friends<br/>",
            "!type": "bool"
          },
          teamIds: {
            "!doc": "The IDs of the teams you are interested in<br/>",
            "!type": "[string]"
          },
          teamTypes: {
            "!doc": "The type of team you are interested in<br/>",
            "!type": "[string]"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._LeaderboardDataResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._LeaderboardDataResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._LeaderboardDataResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._LeaderboardDataResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      SocialStatusRequest: {
        "!type": "fn()",
        "!doc": "Returns detials of the current social connections of this player. Each connection .<br/>",
        "!proto": "SparkRequests._SocialStatusRequest",
        prototype: {
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._SocialStatusResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._SocialStatusResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._SocialStatusResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._SocialStatusResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      SteamBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes a 'orderid' from a Steam.<br/>The GameSparks platform will validate the 'orderid' with Steam and process the response. The 'orderid' from the response will be recorded and the request will be rejected, if the 'orderid' has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the 'itemid' in the response with the 'Steam Product ID' configured against the virtual good.<br/>",
        "!proto": "SparkRequests._SteamBuyGoodsRequest",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          orderId: {
            "!doc": "Unique 64-bit ID for order<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      SteamConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Steam sessionTicket to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Steam platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Steam user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Steam user is not already registered with the game, the Steam user will be linked to the current player.<br/>If the current player has not authenticated and the Steam user is not known, a new player will be created using the Steam details and the session will be authenticated against the new player.<br/>If the Steam user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._SteamConnectRequest",
        prototype: {
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          sessionTicket: {
            "!doc": "The hex encoded UTF-8 string representation of the ticket acquired calling the Steam SDKs GetAuthSessionTicket.<br/>",
            "!type": "string"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      TwitchConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Twitch account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Twitch platform and store them within GameSparks.<br/>If the Twitch user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Twitch user is not already registered with the game, the Twitch user will be linked to the current player.<br/>If the current player has not authenticated and the Twitch user is not known, a new player will be created using the Twitch details and the session will be authenticated against the new player.<br/>If the Twitch user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._TwitchConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      TwitterConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Twitter account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Twitter platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Twitter user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Twitter user is not already registered with the game, the Twitter user will be linked to the current player.<br/>If the current player has not authenticated and the Twitter user is not known, a new player will be created using the Twitter details and the session will be authenticated against the new player.<br/>If the Twitter user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._TwitterConnectRequest",
        prototype: {
          accessSecret: {
            "!doc": "The accessSecret is obtained at the same time as the accessToken, and is required to sign requests to Twitter's services that require the accessToken.<br/>",
            "!type": "string"
          },
          accessToken: {
            "!doc": "The accessToken represents a player's permission to share access to their account with your application.<br/>To obtain an accessToken for the player see https://dev.twitter.com/docs/auth/obtaining-access-tokens.<br/>Currently, Twitter accessTokens do not expire but they can be revoked by the player.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      UpdateMessageRequest: {
        "!type": "fn()",
        "!doc": "Allows a message status to be updated.<br/>",
        "!proto": "SparkRequests._UpdateMessageRequest",
        prototype: {
          messageId: {
            "!doc": "The messageId of the message to update<br/>",
            "!type": "string"
          },
          status: {
            "!doc": "The status to set on the message<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._UpdateMessageResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._UpdateMessageResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._UpdateMessageResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._UpdateMessageResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      ViberConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a Viber account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Viber platform and store them within GameSparks.<br/>A successful authentication will also register the player to receive Viber push notifications.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Viber user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Viber user is not already registered with the game, the Viber user will be linked to the current player.<br/>If the current player has not authenticated and the Viber user is not known, a new player will be created using the Viber details and the session will be authenticated against the new player.<br/>If the Viber user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._ViberConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The accessToken represents a player's permission to share access to their account with your application.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          doNotRegisterForPush: {
            "!doc": "Does not automatocally register this user for push notifications. Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      WeChatConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows a WeChat access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the WeChat platform and store them within GameSparks.<br/>If the WeChat user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the WeChat user is not already registered with the game, the WeChat user will be linked to the current player.<br/>If the current player has not authenticated and the WeChat user is not known, a new player will be created using the WeChat details and the session will be authenticated against the new player.<br/>If the WeChat user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._WeChatConnectRequest",
        prototype: {
          accessToken: {
            "!doc": "The access token sould be obtained from WeChat<br/>It is used by the client to make authenticated requests on behalf of the end user.<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          openId: {
            "!doc": "The open ID corresponding to the WeChat user<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      WindowsBuyGoodsRequest: {
        "!type": "fn()",
        "!doc": "Processes a transaction receipt from a windows store purchase.<br/>The GameSparks platform will validate the receipt using the signature embedded in the xml. The Id in the xml will be recorded and the request will be rejected if the Id has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the xml with the 'WP8 Product ID' configured against the virtual good.<br/>",
        "!proto": "SparkRequests._WindowsBuyGoodsRequest",
        prototype: {
          currencyCode: {
            "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
            "!type": "string"
          },
          platform: {
            "!doc": "Allows you to specify the platform<br/>",
            "!type": "string"
          },
          receipt: {
            "!doc": "The xml reciept returned from the windows phone 8 store<br/>",
            "!type": "string"
          },
          subUnitPrice: {
            "!doc": "The price of this purchase<br/>",
            "!type": "number"
          },
          uniqueTransactionByPlayer: {
            "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._BuyVirtualGoodResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._BuyVirtualGoodResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      WithdrawChallengeRequest: {
        "!type": "fn()",
        "!doc": "Withdraws a challenge previously issued by the current player.<br/>This can only be done while the challenge is in the ISSUED state. Once it's been accepted the challenge can not be withdrawn.<br/>",
        "!proto": "SparkRequests._WithdrawChallengeRequest",
        prototype: {
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "An optional message to send with the challenge<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._WithdrawChallengeResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._WithdrawChallengeResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._WithdrawChallengeResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._WithdrawChallengeResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      XBOXLiveConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Xbox Live Shared Token String to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Xbox Live and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Xbox user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Xbox user is not already registered with the game, the Xbox user will be linked to the current player.<br/>If the current player has not authenticated and the Xbox user is not known, a new player will be created using the Xbox details and the session will be authenticated against the new player.<br/>If the Xbox user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._XBOXLiveConnectRequest",
        prototype: {
          displayName: {
            "!doc": "The displayName to set for the player in GameSparks<br/>",
            "!type": "string"
          },
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          stsTokenString: {
            "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>It has a longer lifetime than the authorization code, typically on the order of minutes or hours.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained via a refresh token.<br/>",
            "!type": "string"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      XboxOneConnectRequest: {
        "!type": "fn()",
        "!doc": "Allows an Xbox One XSTS token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from Xbox Live and store them within GameSparks.<br/>If the Xbox One user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Xbox One user is not already registered with the game, the Xbox One user will be linked to the current player.<br/>If the current player has not authenticated and the Xbox One user is not known, a new player will be created using the Xbox Live details and the session will be authenticated against the new player.<br/>If the Xbox One user is already known, the session will switch to being the previously created user.<br/>",
        "!proto": "SparkRequests._XboxOneConnectRequest",
        prototype: {
          doNotLinkToCurrentPlayer: {
            "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
            "!type": "bool"
          },
          errorOnSwitch: {
            "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
            "!type": "bool"
          },
          sandbox: {
            "!doc": "The Xbox Live sandbox to use. If not specified, the sandbox from the decoded token will be used.<br/>",
            "!type": "string"
          },
          segments: {
            "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
            "!type": "?"
          },
          switchIfPossible: {
            "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
            "!type": "bool"
          },
          syncDisplayName: {
            "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
            "!type": "bool"
          },
          token: {
            "!doc": "The Xbox One authentication token<br/>",
            "!type": "string"
          },
          Send: {
            "!doc": "Sends the request <b>without executing the associated scripts</b>",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          SendAs: {
            "!doc": "<b>Sends the request as the specified player without executing the associated scripts</b>",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          Execute: {
            "!doc": "Sends the request and executes the associated scripts",
            "!type": "fn() -> SparkRequests._AuthenticationResponse"
          },
          ExecuteAs: {
            "!doc": "Sends the request as the specified player and executes the associated scripts",
            "!type": "fn(playerId) -> SparkRequests._AuthenticationResponse"
          },
          scriptData: {
            "!doc": "Custom data that can be read by javascript"
          }
        }
      },
      _BulkJob: {
        "!doc": "A nested object that represents the bulk job.<br/>",
        actualCount: {
          "!doc": "The actual count of players affected by the bulk job (calculated when the job started to run)<br/>",
          "!type": "number"
        },
        completed: {
          "!doc": "The time at which the bulk job completed execution<br/>",
          "!type": "date"
        },
        created: {
          "!doc": "The time at which the bulk job was created<br/>",
          "!type": "date"
        },
        data: {
          "!doc": "Data to be passed into the Module or Script<br/>",
          "!type": "_DBObject"
        },
        doneCount: {
          "!doc": "The number of players processed by the bulk job so far<br/>",
          "!type": "number"
        },
        errorCount: {
          "!doc": "The number of errors encountered whilst running the Module or Script for players<br/>",
          "!type": "number"
        },
        estimatedCount: {
          "!doc": "The estimated count of players affected by the bulk job (estimated when the job was submitted)<br/>",
          "!type": "number"
        },
        id: {
          "!doc": "The ID for the bulk job<br/>",
          "!type": "string"
        },
        moduleShortCode: {
          "!doc": "The Cloud Code Module to run for each player<br/>",
          "!type": "string"
        },
        playerQuery: {
          "!doc": "The query to identify players to perform the bulk job on<br/>",
          "!type": "_DBObject"
        },
        scheduledTime: {
          "!doc": "The time at which the job was scheduled to run<br/>",
          "!type": "date"
        },
        script: {
          "!doc": "The Cloud Code script to run for each player<br/>",
          "!type": "string"
        },
        started: {
          "!doc": "The time at which the bulk job started to execute<br/>",
          "!type": "date"
        },
        state: {
          "!doc": "The current state of the bulk job<br/>",
          "!type": "string"
        }
      },
      _InvitableFriend: {
        "!doc": "A nested object that represents the invitable friend.<br/>",
        displayName: {
          "!doc": "The display name of the External Friend<br/>",
          "!type": "string"
        },
        id: {
          "!doc": "The ID of the External Friend<br/>",
          "!type": "string"
        },
        profilePic: {
          "!doc": "The profile picture URL of the External Friend<br/>",
          "!type": "string"
        }
      },
      _Achievement: {
        "!doc": "A nested object that represents the achievement data.<br/>",
        description: {
          "!doc": "The desciption of the Achievement<br/>",
          "!type": "string"
        },
        earned: {
          "!doc": "Whether to current player has earned the achievement<br/>",
          "!type": "bool"
        },
        name: {
          "!doc": "The name of the Achievement<br/>",
          "!type": "string"
        },
        propertySet: {
          "!doc": "The custom property set configured on this Achievement<br/>",
          "!type": "?"
        },
        shortCode: {
          "!doc": "The shortCode of the Achievement<br/>",
          "!type": "string"
        }
      },
      _BundledGood: {
        "!doc": "A collection of arbitrary data that can be added to a message via a Cloud Code script.<br/>",
        qty: {
          "!doc": "The number of items bundled<br/>",
          "!type": "number"
        },
        shortCode: {
          "!doc": "The shortCode of the bundled good<br/>",
          "!type": "string"
        }
      },
      _VirtualGood: {
        "!doc": "A nested object that represents the virtual good.<br/>",
        WP8StoreProductId: {
          "!doc": "The Windows Phone 8 productId of the item.<br/>",
          "!type": "string"
        },
        amazonStoreProductId: {
          "!doc": "The Amazon Store productId of the item.<br/>",
          "!type": "string"
        },
        baseCurrency1Cost: {
          "!doc": "The Base Currency1 cost of the Virtual Good, before segmentation<br/>",
          "!type": "number"
        },
        baseCurrency2Cost: {
          "!doc": "The Base Currency2 cost of the Virtual Good, before segmentation<br/>",
          "!type": "number"
        },
        baseCurrency3Cost: {
          "!doc": "The Base Currency3 cost of the Virtual Good, before segmentation<br/>",
          "!type": "number"
        },
        baseCurrency4Cost: {
          "!doc": "The Base Currency4 cost of the Virtual Good, before segmentation<br/>",
          "!type": "number"
        },
        baseCurrency5Cost: {
          "!doc": "The Base Currency5 cost of the Virtual Good, before segmentation<br/>",
          "!type": "number"
        },
        baseCurrency6Cost: {
          "!doc": "The Base Currency6 cost of the Virtual Good, before segmentation<br/>",
          "!type": "number"
        },
        baseCurrencyCosts: {
          "!doc": "The Base currency costs of the Virtual Good, before experiments<br/>",
          "!type": "?"
        },
        bundledGoods: {
          "!doc": "Returns the bundle goods of the virtual good<br/>",
          "!type": "[_BundledGood]"
        },
        currency1Cost: {
          "!doc": "The Currency1 cost of the Virtual Good<br/>",
          "!type": "number"
        },
        currency2Cost: {
          "!doc": "The Currency2 cost of the Virtual Good<br/>",
          "!type": "number"
        },
        currency3Cost: {
          "!doc": "The Currency3 cost of the Virtual Good<br/>",
          "!type": "number"
        },
        currency4Cost: {
          "!doc": "The Currency4 cost of the Virtual Good<br/>",
          "!type": "number"
        },
        currency5Cost: {
          "!doc": "The Currency5 cost of the Virtual Good<br/>",
          "!type": "number"
        },
        currency6Cost: {
          "!doc": "The Currency6 cost of the Virtual Good<br/>",
          "!type": "number"
        },
        currencyCosts: {
          "!doc": "The currency costs of the Virtual Good<br/>",
          "!type": "?"
        },
        description: {
          "!doc": "The description of the Virtual Good<br/>",
          "!type": "string"
        },
        disabled: {
          "!doc": "Whether the item is disabled.<br/>",
          "!type": "bool"
        },
        googlePlayProductId: {
          "!doc": "The google play productId of the item.<br/>",
          "!type": "string"
        },
        iosAppStoreProductId: {
          "!doc": "The iOS AppStore productId of the item.<br/>",
          "!type": "string"
        },
        maxQuantity: {
          "!doc": "The maximum number of the Virtual Good that can be owned at one time<br/>",
          "!type": "number"
        },
        name: {
          "!doc": "The name of the Virtual Good<br/>",
          "!type": "string"
        },
        propertySet: {
          "!doc": "The custom property set configured on the item.<br/>",
          "!type": "?"
        },
        psnStoreProductId: {
          "!doc": "The PSN Store productId of the item.<br/>",
          "!type": "string"
        },
        segmentedCurrency1Cost: {
          "!doc": "The Segmented Currency1 cost of the Virtual Good, before experiments<br/>",
          "!type": "number"
        },
        segmentedCurrency2Cost: {
          "!doc": "The Segmented Currency2 cost of the Virtual Good, before experiments<br/>",
          "!type": "number"
        },
        segmentedCurrency3Cost: {
          "!doc": "The Segmented Currency3 cost of the Virtual Good, before experiments<br/>",
          "!type": "number"
        },
        segmentedCurrency4Cost: {
          "!doc": "The Segmented Currency4 cost of the Virtual Good, before experiments<br/>",
          "!type": "number"
        },
        segmentedCurrency5Cost: {
          "!doc": "The Segmented Currency5 cost of the Virtual Good, before experiments<br/>",
          "!type": "number"
        },
        segmentedCurrency6Cost: {
          "!doc": "The Segmented Currency6 cost of the Virtual Good, before experiments<br/>",
          "!type": "number"
        },
        segmentedCurrencyCosts: {
          "!doc": "The segmented currency costs of the Virtual Good, before experiments<br/>",
          "!type": "?"
        },
        shortCode: {
          "!doc": "The short code of the Virtual Good<br/>",
          "!type": "string"
        },
        steamStoreProductId: {
          "!doc": "The Steam Store productId of the item.<br/>",
          "!type": "string"
        },
        tags: {
          "!doc": "The tags of the Virtual Good<br/>",
          "!type": "string"
        },
        type: {
          "!doc": 'The type of the virtual good, "VGOOD" or "CURRENCY"<br/>',
          "!type": "string"
        },
        w8StoreProductId: {
          "!doc": "The Windows 8 productId of the item.<br/>",
          "!type": "string"
        }
      },
      _Player: {
        "!doc": "A nested object that represents a player.<br/>",
        achievements: {
          "!doc": "The achievements of the Player<br/>",
          "!type": "[string]"
        },
        displayName: {
          "!doc": "The display name of the Player<br/>",
          "!type": "string"
        },
        externalIds: {
          "!doc": "The external Id's of the Player<br/>",
          "!type": "?"
        },
        id: {
          "!doc": "The Id of the Player<br/>",
          "!type": "string"
        },
        online: {
          "!doc": "The online status of the Player<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "The script data of the Player<br/>",
          "!type": "?"
        },
        virtualGoods: {
          "!doc": "The virtual goods of the Player<br/>",
          "!type": "[string]"
        }
      },
      _Team: {
        "!doc": "A nested object that represents the team.<br/>",
        members: {
          "!doc": "The team members<br/>",
          "!type": "[_Player]"
        },
        owner: {
          "!doc": "A summary of the owner<br/>",
          "!type": "_Player"
        },
        teamId: {
          "!doc": "The Id of the team<br/>",
          "!type": "string"
        },
        teamName: {
          "!doc": "The team name<br/>",
          "!type": "string"
        },
        teamType: {
          "!doc": "The team type<br/>",
          "!type": "string"
        }
      },
      _Leaderboard: {
        "!doc": "A nested object that represents the leaderboard configuration data.<br/>",
        description: {
          "!doc": "The leaderboard's description.<br/>",
          "!type": "string"
        },
        name: {
          "!doc": "The leaderboard's name.<br/>",
          "!type": "string"
        },
        propertySet: {
          "!doc": "The custom property set configured on this Leaderboard<br/>",
          "!type": "?"
        },
        shortCode: {
          "!doc": "The leaderboard's short code.<br/>",
          "!type": "string"
        }
      },
      _ChatMessage: {
        "!doc": "A message from a group chat<br/>",
        fromId: {
          "!doc": "The id of the player who sent this message<br/>",
          "!type": "string"
        },
        id: {
          "!doc": "The id of this chat message<br/>",
          "!type": "string"
        },
        message: {
          "!doc": "The text sent in this message<br/>",
          "!type": "string"
        },
        when: {
          "!doc": "A date representing the time this message was sent<br/>",
          "!type": "date"
        },
        who: {
          "!doc": "The displayName of the player who sent this message<br/>",
          "!type": "string"
        }
      },
      _PlayerDetail: {
        "!doc": "An object representing a player's id and name<br/>",
        externalIds: {
          "!doc": "A player's external identifiers<br/>",
          "!type": "?"
        },
        id: {
          "!doc": "A player's id<br/>",
          "!type": "string"
        },
        name: {
          "!doc": "A player's name<br/>",
          "!type": "string"
        }
      },
      _UploadData: {
        "!doc": "This object represents the result of uploading a file to the GameSparks platform.<br/>",
        fileName: {
          "!doc": "The filename of the file that was uploaded.<br/>",
          "!type": "string"
        },
        playerId: {
          "!doc": "The unique player id of the player that uploaded the file.<br/>",
          "!type": "string"
        }
      },
      _ScriptData: {
        "!doc": "A collection of arbitrary data that can be added to a message via a Cloud Code script.<br/>",
        myKey: {
          "!doc": "An arbitrary data key<br/>",
          "!type": "string"
        },
        myValue: {
          "!doc": "An arbitrary data value.<br/>",
          "!type": "?"
        }
      },
      _ChallengeType: {
        "!doc": "<br/>",
        challengeShortCode: {
          "!doc": "The shortCode for this challenge.<br/>",
          "!type": "string"
        },
        description: {
          "!doc": "The description of this challenge.<br/>",
          "!type": "string"
        },
        getleaderboardName: {
          "!doc": "The name of the leaderboard for this challenge.<br/>",
          "!type": "string"
        },
        name: {
          "!doc": "The name of this challenge.<br/>",
          "!type": "string"
        },
        tags: {
          "!doc": "The tags for this challenge.<br/>",
          "!type": "string"
        }
      },
      _Boughtitem: {
        "!doc": "A nested object that represents a bought item.<br/>",
        quantity: {
          "!doc": "The quantity of the bought item<br/>",
          "!type": "number"
        },
        shortCode: {
          "!doc": "The short code of the bought item<br/>",
          "!type": "string"
        }
      },
      _PlayerMessage: {
        "!doc": "A nested object that represents a player message.<br/>",
        id: {
          "!doc": "The id of the message<br/>",
          "!type": "string"
        },
        message: {
          "!doc": "The message content<br/>",
          "!type": "?"
        },
        seen: {
          "!doc": "Whether the message has been delivered to the client<br/>",
          "!type": "bool"
        },
        status: {
          "!doc": "The status of the message<br/>",
          "!type": "string"
        },
        when: {
          "!doc": "The date of the message<br/>",
          "!type": "date"
        }
      },
      _MatchedPlayer: {
        "!doc": "An object that represents a player in a pending match.<br/>",
        location: {
          "!doc": "The Location of the player<br/>",
          "!type": "_DBObject"
        },
        participantData: {
          "!doc": "A JSON Map of any data that was associated to this user<br/>",
          "!type": "?"
        },
        playerId: {
          "!doc": "The ID for player<br/>",
          "!type": "string"
        },
        skill: {
          "!doc": "The skill of the player in this match<br/>",
          "!type": "number"
        }
      },
      _PendingMatch: {
        "!doc": "An object that represents a pending match.<br/>",
        id: {
          "!doc": "The ID for the pending match<br/>",
          "!type": "string"
        },
        matchData: {
          "!doc": "A JSON Map of the matchData associated to this pending match<br/>",
          "!type": "?"
        },
        matchGroup: {
          "!doc": "The match group for the pending match<br/>",
          "!type": "string"
        },
        matchShortCode: {
          "!doc": "The match shortCode for the pending match<br/>",
          "!type": "string"
        },
        matchedPlayers: {
          "!doc": "The players already part of this pending match<br/>",
          "!type": "[_MatchedPlayer]"
        },
        skill: {
          "!doc": "The average skill of players in this pending match<br/>",
          "!type": "number"
        }
      },
      _Participant: {
        "!doc": "A nested object that represents a participant in a match.<br/>",
        achievements: {
          "!doc": "The achievements of the Player<br/>",
          "!type": "[string]"
        },
        displayName: {
          "!doc": "The display name of the Player<br/>",
          "!type": "string"
        },
        externalIds: {
          "!doc": "The external Id's of the Player<br/>",
          "!type": "?"
        },
        id: {
          "!doc": "The Id of the Player<br/>",
          "!type": "string"
        },
        online: {
          "!doc": "The online status of the Player<br/>",
          "!type": "bool"
        },
        participantData: {
          "!doc": "A JSON Map of any data that was associated to this user<br/>",
          "!type": "?"
        },
        peerId: {
          "!doc": "The peerId of this participant within the match<br/>",
          "!type": "number"
        },
        scriptData: {
          "!doc": "The script data of the Player<br/>",
          "!type": "?"
        },
        virtualGoods: {
          "!doc": "The virtual goods of the Player<br/>",
          "!type": "[string]"
        }
      },
      _PlayerTransactionItem: {
        "!doc": "A nested object that represents a single item in a transaction.<br/>",
        amount: {
          "!doc": "The amount of this item given to the player in the transaction<br/>",
          "!type": "number"
        },
        newValue: {
          "!doc": "The quantity the player possesses after the transaction completed<br/>",
          "!type": "number"
        },
        type: {
          "!doc": "The type of item<br/>",
          "!type": "string"
        }
      },
      _PlayerTransaction: {
        "!doc": "A nested object that represents a player transaction.<br/>",
        items: {
          "!doc": "The items (currency or virtual goods) involved in this transaction<br/>",
          "!type": "[_PlayerTransactionItem]"
        },
        originalRequestId: {
          "!doc": "The original request ID for this transaction<br/>",
          "!type": "string"
        },
        playerId: {
          "!doc": "The player ID<br/>",
          "!type": "string"
        },
        reason: {
          "!doc": "The reason for the transaction<br/>",
          "!type": "string"
        },
        revokeDate: {
          "!doc": "Gets the date when this transaction was revoked, if applicable<br/>",
          "!type": "date"
        },
        revoked: {
          "!doc": "Is true if the transaction was revoked<br/>",
          "!type": "bool"
        },
        script: {
          "!doc": "The specific script in which this transaction occurred<br/>",
          "!type": "string"
        },
        scriptType: {
          "!doc": "The script type in which this transaction occurred (e.g. event)<br/>",
          "!type": "string"
        },
        transactionId: {
          "!doc": "The transaction ID of this purchase, if applicable<br/>",
          "!type": "string"
        },
        when: {
          "!doc": "The date of the transaction<br/>",
          "!type": "date"
        }
      },
      _PlayerTurnCount: {
        "!doc": "Represents the number of turns a player has taken in a turn based challenge.<br/>",
        count: {
          "!doc": "The number of turns that the player has taken so far during this challenge.<br/>",
          "!type": "string"
        },
        playerId: {
          "!doc": "The unique player id.<br/>",
          "!type": "string"
        }
      },
      _Challenge: {
        "!doc": "A nested object that represents the challenge data.<br/>",
        accepted: {
          "!doc": "A list of PlayerDetail objects that represents the players that have accepted this challenge.<br/>",
          "!type": "[_PlayerDetail]"
        },
        challengeId: {
          "!doc": "A unique identifier for this challenge.<br/>",
          "!type": "string"
        },
        challengeMessage: {
          "!doc": "The message included in the challenge by the challenging player who created the challenge.<br/>",
          "!type": "string"
        },
        challengeName: {
          "!doc": "The name of the challenge that this message relates to.<br/>",
          "!type": "string"
        },
        challenged: {
          "!doc": "A list of PlayerDetail objects that represents the players that were challenged in this challenge.<br/>",
          "!type": "[_PlayerDetail]"
        },
        challenger: {
          "!doc": "Details of the player who issued this challenge.<br/>",
          "!type": "_PlayerDetail"
        },
        currency1Wager: {
          "!doc": "The amount of type 1 currency that has been wagered on this challenge.<br/>",
          "!type": "number"
        },
        currency2Wager: {
          "!doc": "The amount of type 2 currency that has been wagered on this challenge.<br/>",
          "!type": "number"
        },
        currency3Wager: {
          "!doc": "The amount of type 3 currency that has been wagered on this challenge.<br/>",
          "!type": "number"
        },
        currency4Wager: {
          "!doc": "The amount of type 4 currency that has been wagered on this challenge.<br/>",
          "!type": "number"
        },
        currency5Wager: {
          "!doc": "The amount of type 5 currency that has been wagered on this challenge.<br/>",
          "!type": "number"
        },
        currency6Wager: {
          "!doc": "The amount of type 6 currency that has been wagered on this challenge.<br/>",
          "!type": "number"
        },
        currencyWagers: {
          "!doc": "An object representing the currencies that have been wagered on this challenge.<br/>",
          "!type": "?"
        },
        declined: {
          "!doc": "A list of PlayerDetail objects that represents the players that have declined this challenge.<br/>",
          "!type": "[_PlayerDetail]"
        },
        endDate: {
          "!doc": "The date when the challenge ends.<br/>",
          "!type": "date"
        },
        expiryDate: {
          "!doc": "The latest date that a player can accept the challenge.<br/>",
          "!type": "date"
        },
        maxTurns: {
          "!doc": "The maximum number of turns that this challenge is configured for.<br/>",
          "!type": "number"
        },
        nextPlayer: {
          "!doc": "In a turn based challenge this fields contains the player's id whose turn it is next.<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a challenge instance by a Cloud Code script.<br/>",
          "!type": "?"
        },
        shortCode: {
          "!doc": "The challenge's short code.<br/>",
          "!type": "string"
        },
        startDate: {
          "!doc": "The date when the challenge starts.<br/>",
          "!type": "date"
        },
        state: {
          "!doc": "One of these possible state values: ISSUED, EXPIRED, ACCEPTED, DECLINED, COMPLETE, WITHDRAWN, RUNNING, WAITING, RECEIVED<br/>",
          "!type": "string"
        },
        turnCount: {
          "!doc": "A collection containing the number of turns taken by each player that has accepted the challenge.<br/>Each turn count is a Long keyed on a String that represents the player's id<br/>",
          "!type": "[_PlayerTurnCount]"
        }
      },
      _SocialStatus: {
        "!doc": "A the details of a social connection<br/>",
        active: {
          "!doc": "When the token is still active.<br/>",
          "!type": "bool"
        },
        expires: {
          "!doc": "When the token expires (if available).<br/>",
          "!type": "date"
        },
        systemId: {
          "!doc": "The identifier of the external platform.<br/>",
          "!type": "string"
        }
      },
      _LeaderboardData: {
        "!doc": "Leaderboard entry data<br/>As well as the parameters below there may be others depending on your game's configuration.<br/>",
        city: {
          "!doc": "The city where the player was located when they logged this leaderboard entry.<br/>",
          "!type": "string"
        },
        country: {
          "!doc": "The country code where the player was located when they logged this leaderboard entry.<br/>",
          "!type": "string"
        },
        externalIds: {
          "!doc": "The players rank.<br/>",
          "!type": "?"
        },
        rank: {
          "!doc": "The players rank.<br/>",
          "!type": "number"
        },
        userId: {
          "!doc": "The unique player id for this leaderboard entry.<br/>",
          "!type": "string"
        },
        userName: {
          "!doc": "The players display name.<br/>",
          "!type": "string"
        },
        when: {
          "!doc": "The date when this leaderboard entry was created.<br/>",
          "!type": "string"
        }
      },
      _LeaderboardRankDetails: {
        "!doc": "Ranking information.<br/>",
        friendsPassed: {
          "!doc": "The leaderboard entries of the players friends that were beaten as part of this score submission.<br/>",
          "!type": "[_LeaderboardData]"
        },
        globalCount: {
          "!doc": "The number of entries in this leaderboard.<br/>",
          "!type": "number"
        },
        globalFrom: {
          "!doc": "The Global Rank of the player in this leaderboard before the score was submitted.<br/>",
          "!type": "number"
        },
        globalFromPercent: {
          "!doc": "The old global rank of the player as a percentage of the total number of scores in this leaderboard .<br/>",
          "!type": "number"
        },
        globalTo: {
          "!doc": "The Global Rank of the player in this leaderboard after the score was submitted.<br/>",
          "!type": "number"
        },
        globalToPercent: {
          "!doc": "The new global rank of the player as a percentage of the total number of scores in this leaderboard .<br/>",
          "!type": "number"
        },
        socialCount: {
          "!doc": "The number of friend entries the player has in this leaderboard.<br/>",
          "!type": "number"
        },
        socialFrom: {
          "!doc": "The Social Rank of the player in this leaderboard before the score was submitted.<br/>",
          "!type": "number"
        },
        socialFromPercent: {
          "!doc": "The old social rank of the player as a percentage of the total number of friend scores in this leaderboard.<br/>",
          "!type": "number"
        },
        socialTo: {
          "!doc": "The Social Rank of the player in this leaderboard after the score was submitted.<br/>",
          "!type": "number"
        },
        socialToPercent: {
          "!doc": "The old global rank of the player as a percentage of the total number of friend scores in this leaderboard.<br/>",
          "!type": "number"
        },
        topNPassed: {
          "!doc": "The leaderboard entries of the global players that were beaten as part of this score submission. Requires Top N to be configured on the leaderboard<br/>",
          "!type": "[_LeaderboardData]"
        }
      },
      _Location: {
        "!doc": "Location details.<br/>",
        city: {
          "!doc": "The city<br/>",
          "!type": "string"
        },
        country: {
          "!doc": "The country<br/>",
          "!type": "string"
        },
        latitide: {
          "!doc": "The latitude<br/>",
          "!type": "number"
        },
        longditute: {
          "!doc": "The longditute<br/>",
          "!type": "number"
        }
      },
      _AcceptChallengeResponse: {
        "!doc": "A response containing the challenge instance id that was accepted.<br/>",
        challengeInstanceId: {
          "!doc": "The ID of the challenge<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _AccountDetailsResponse: {
        "!doc": "A response containing the player's data.<br/>",
        achievements: {
          "!doc": "A JSON object containing the player's achievments<br/>",
          "!type": "[string]"
        },
        currencies: {
          "!doc": "A JSON object containing the player's currency balances<br/>",
          "!type": "?"
        },
        currency1: {
          "!doc": "The amount of type 1 currency that the player holds<br/>",
          "!type": "number"
        },
        currency2: {
          "!doc": "The amount of type 2 currency that the player holds<br/>",
          "!type": "number"
        },
        currency3: {
          "!doc": "The amount of type 3 currency that the player holds<br/>",
          "!type": "number"
        },
        currency4: {
          "!doc": "The amount of type 4 currency that the player holds<br/>",
          "!type": "number"
        },
        currency5: {
          "!doc": "The amount of type 5 currency that the player holds<br/>",
          "!type": "number"
        },
        currency6: {
          "!doc": "The amount of type 6 currency that the player holds<br/>",
          "!type": "number"
        },
        displayName: {
          "!doc": "The player's display name<br/>",
          "!type": "string"
        },
        externalIds: {
          "!doc": "A JSON object containing the player's external account details<br/>",
          "!type": "?"
        },
        location: {
          "!doc": "A JSON object containing the player's location<br/>",
          "!type": "_Location"
        },
        reservedCurrencies: {
          "!doc": "A JSON object containing the player's currency balances<br/>",
          "!type": "?"
        },
        reservedCurrency1: {
          "!doc": "The amount of type 1 currency that the player holds which is currently reserved<br/>",
          "!type": "?"
        },
        reservedCurrency2: {
          "!doc": "The amount of type 2 currency that the player holds which is currently reserved<br/>",
          "!type": "?"
        },
        reservedCurrency3: {
          "!doc": "The amount of type 3 currency that the player holds which is currently reserved<br/>",
          "!type": "?"
        },
        reservedCurrency4: {
          "!doc": "The amount of type 4 currency that the player holds which is currently reserved<br/>",
          "!type": "?"
        },
        reservedCurrency5: {
          "!doc": "The amount of type 5 currency that the player holds which is currently reserved<br/>",
          "!type": "?"
        },
        reservedCurrency6: {
          "!doc": "The amount of type 6 currency that the player holds which is currently reserved<br/>",
          "!type": "?"
        },
        userId: {
          "!doc": "The player's id<br/>",
          "!type": "string"
        },
        virtualGoods: {
          "!doc": "A JSON object containing the virtual goods that the player owns<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _AnalyticsResponse: {
        "!doc": "A response to an analytics request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _AroundMeLeaderboardResponse: {
        "!doc": "A response containing leaderboard data around the current player<br/>",
        challengeInstanceId: {
          "!doc": "The leaderboard's challenge id<br/>",
          "!type": "string"
        },
        data: {
          "!doc": "The leaderboard data<br/>",
          "!type": "[_LeaderboardData]"
        },
        first: {
          "!doc": "The first item in the leaderboard data<br/>",
          "!type": "[_LeaderboardData]"
        },
        last: {
          "!doc": "The last item in the leaderboard data<br/>",
          "!type": "[_LeaderboardData]"
        },
        leaderboardShortCode: {
          "!doc": "The leaderboard short code<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        social: {
          "!doc": "True if the response contains a social leaderboard's data<br/>",
          "!type": "bool"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _AuthenticationResponse: {
        "!doc": "A response containing the auth token<br/>",
        authToken: {
          "!doc": "44b297a8-162a-4220-8c14-dad9a1946ad2<br/>",
          "!type": "string"
        },
        displayName: {
          "!doc": "The player's display name<br/>",
          "!type": "string"
        },
        newPlayer: {
          "!doc": "Indicates whether the player was created as part of this request<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        switchSummary: {
          "!doc": "A summary of the player that would be switched to.  Only returned as part of an error response for a request where automatic switching is disabled.<br/>",
          "!type": "_Player"
        },
        userId: {
          "!doc": "The player's id<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _BatchAdminResponse: {
        "!doc": "A response containing the individual responses for requests performed via a BatchAdminRequest<br/>",
        responses: {
          "!doc": "A map of responses by player ID<br/>",
          "!type": "?"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _BuyVirtualGoodResponse: {
        "!doc": "A response containing details of the bought items<br/>",
        boughtItems: {
          "!doc": "A JSON object containing details of the bought items<br/>",
          "!type": "[_Boughtitem]"
        },
        currenciesAdded: {
          "!doc": "An object containing the short code and amount added for each currency<br/>",
          "!type": "?"
        },
        currency1Added: {
          "!doc": "How much currency type 1 was added<br/>",
          "!type": "number"
        },
        currency2Added: {
          "!doc": "How much currency type 2 was added<br/>",
          "!type": "number"
        },
        currency3Added: {
          "!doc": "How much currency type 3 was added<br/>",
          "!type": "number"
        },
        currency4Added: {
          "!doc": "How much currency type 4 was added<br/>",
          "!type": "number"
        },
        currency5Added: {
          "!doc": "How much currency type 5 was added<br/>",
          "!type": "number"
        },
        currency6Added: {
          "!doc": "How much currency type 6 was added<br/>",
          "!type": "number"
        },
        currencyConsumed: {
          "!doc": "For a buy with currency request, how much currency was used<br/>",
          "!type": "number"
        },
        currencyShortCode: {
          "!doc": "For a buy with currency request, the short code of the currency used<br/>",
          "!type": "string"
        },
        currencyType: {
          "!doc": "For a buy with currency request, which currency type was used<br/>",
          "!type": "number"
        },
        invalidItems: {
          "!doc": "A list of invalid items for this purchase (if any). This field is populated only for store buys<br/>",
          "!type": "[string]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        transactionIds: {
          "!doc": "The list of transactionIds, for this purchase, if they exist. This field is populated only for store buys<br/>",
          "!type": "[string]"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _CancelBulkJobAdminResponse: {
        "!doc": "A response listing cancelled bulk jobs<br/>",
        bulkJobs: {
          "!doc": "A list of JSON objects containing bulk jobs<br/>",
          "!type": "[_BulkJob]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChangeUserDetailsResponse: {
        "!doc": "A response to a change user details request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChatOnChallengeResponse: {
        "!doc": "A response to a chat on challenge request<br/>",
        challengeInstanceId: {
          "!doc": "The challenge instance id<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ConsumeVirtualGoodResponse: {
        "!doc": "A response to a consume virtual goods response<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _CreateChallengeResponse: {
        "!doc": "A response to a create challenge response<br/>",
        challengeInstanceId: {
          "!doc": "The challenge instance id<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _CreateTeamResponse: {
        "!doc": "A response containing the details of the team that was created<br/>",
        members: {
          "!doc": "The team members<br/>",
          "!type": "[_Player]"
        },
        owner: {
          "!doc": "A summary of the owner<br/>",
          "!type": "_Player"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        teamId: {
          "!doc": "The Id of the team<br/>",
          "!type": "string"
        },
        teamName: {
          "!doc": "The team name<br/>",
          "!type": "string"
        },
        teamType: {
          "!doc": "The team type<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _DeclineChallengeResponse: {
        "!doc": "A response containing the challenge instance id of the challenge that was declined<br/>",
        challengeInstanceId: {
          "!doc": "The challenge instance id<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _DismissMessageResponse: {
        "!doc": "A response to a dismiss message request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _DismissMultipleMessagesResponse: {
        "!doc": "A response to a dismiss message request<br/>",
        failedDismissals: {
          "!doc": "A list of the messageId values that were not dismissed<br/>",
          "!type": "[string]"
        },
        messagesDismissed: {
          "!doc": "An integer describing how many messages were dismissed<br/>",
          "!type": "number"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _DropTeamResponse: {
        "!doc": "A response to a drop team request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _EndSessionResponse: {
        "!doc": "A response to an end session request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        sessionDuration: {
          "!doc": "The length of this session<br/>",
          "!type": "number"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _FindChallengeResponse: {
        "!doc": "A response to a find challenge request<br/>",
        challengeInstances: {
          "!doc": "A list of JSON objects representing the challenges.<br/>",
          "!type": "[_Challenge]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _FindMatchResponse: {
        "!doc": "A response to a find match request<br/>",
        accessToken: {
          "!doc": "The accessToken used to authenticate this player for this match<br/>",
          "!type": "string"
        },
        host: {
          "!doc": "The host to connect to for this match<br/>",
          "!type": "string"
        },
        matchData: {
          "!doc": "MatchData is arbitrary data that can be stored in a Match instance by a Cloud Code script.<br/>",
          "!type": "?"
        },
        matchId: {
          "!doc": "The id for this match instance<br/>",
          "!type": "string"
        },
        opponents: {
          "!doc": "The opponents this player has been matched against<br/>",
          "!type": "[_Player]"
        },
        peerId: {
          "!doc": "The peerId of this player within the match<br/>",
          "!type": "number"
        },
        playerId: {
          "!doc": "The id of the current player<br/>",
          "!type": "string"
        },
        port: {
          "!doc": "The port to connect to for this match<br/>",
          "!type": "number"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _FindPendingMatchesResponse: {
        "!doc": "A response to a FindPendingMatchesRequest<br/>",
        pendingMatches: {
          "!doc": "A list of JSON objects containing pending matches<br/>",
          "!type": "[_PendingMatch]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GameSparksErrorResponse: {
        "!doc": "A response containing the details of an error<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetChallengeResponse: {
        "!doc": "A response containing the details of a challenge<br/>",
        challenge: {
          "!doc": "A JSON object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetDownloadableResponse: {
        "!doc": "A response containing the download URL for a downloadable item<br/>",
        lastModified: {
          "!doc": "The date when the downloadable item was last modified<br/>",
          "!type": "date"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        shortCode: {
          "!doc": "The short code of the item<br/>",
          "!type": "string"
        },
        size: {
          "!doc": "The size of the item in bytes<br/>",
          "!type": "number"
        },
        url: {
          "!doc": "The download URL<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetLeaderboardEntriesResponse: {
        "!doc": 'A response containing leaderboard entry data for a given player. Example response: {"HS": {"userId":"537f08e1e4b01fdedfa52c49","SCORE": 123,"city":"York","country":"GB","userName":"","when":"2014-07-17T12:18Z","rank": 1 }<br/>',
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetMessageResponse: {
        "!doc": "A response containing the message data for a given message<br/>",
        message: {
          "!doc": "The message data<br/>",
          "!type": "?"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        status: {
          "!doc": "The message status<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetMyTeamsResponse: {
        "!doc": "A response containing team data for teams that a player belong to<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        teams: {
          "!doc": "The team data<br/>",
          "!type": "[_Team]"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetPropertyResponse: {
        "!doc": "A response containing the requested property<br/>",
        property: {
          "!doc": "The property value<br/>",
          "!type": "?"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetPropertySetResponse: {
        "!doc": "A response containing the requested property set<br/>",
        propertySet: {
          "!doc": "The property set<br/>",
          "!type": "?"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetTeamResponse: {
        "!doc": "A response containing the details of the requested teams<br/>",
        members: {
          "!doc": "The team members<br/>",
          "!type": "[_Player]"
        },
        owner: {
          "!doc": "A summary of the owner<br/>",
          "!type": "_Player"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        teamId: {
          "!doc": "The Id of the team<br/>",
          "!type": "string"
        },
        teamName: {
          "!doc": "The team name<br/>",
          "!type": "string"
        },
        teamType: {
          "!doc": "The team type<br/>",
          "!type": "string"
        },
        teams: {
          "!doc": "A JSON array of teams.<br/>",
          "!type": "[_Team]"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetUploadUrlResponse: {
        "!doc": "A response containing a time sensitive URL to allow the game to upload a piece of player content to the GameSparks platform<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        url: {
          "!doc": "The time sensitive upload URL<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GetUploadedResponse: {
        "!doc": "A reponse containing a time sensitive URL to a piece of content that was previously uploaded to the GameSparks platform by a player.<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        size: {
          "!doc": "The size of the file in bytes<br/>",
          "!type": "number"
        },
        url: {
          "!doc": "A time sensitive URL to a piece of content<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _JoinChallengeResponse: {
        "!doc": "A response to a player joining a challenge<br/>",
        joined: {
          "!doc": "Whether the player successfully joined the challenge<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _JoinPendingMatchResponse: {
        "!doc": "A response to a JoinPendingMatchRequest<br/>",
        pendingMatch: {
          "!doc": "A JSON object containing the new pending match<br/>",
          "!type": "_PendingMatch"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _JoinTeamResponse: {
        "!doc": "A response to a player joining a team or a request for team data<br/>",
        members: {
          "!doc": "The team members<br/>",
          "!type": "[_Player]"
        },
        owner: {
          "!doc": "A summary of the owner<br/>",
          "!type": "_Player"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        teamId: {
          "!doc": "The Id of the team<br/>",
          "!type": "string"
        },
        teamName: {
          "!doc": "The team name<br/>",
          "!type": "string"
        },
        teamType: {
          "!doc": "The team type<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _LeaderboardDataResponse: {
        "!doc": "A response containing leaderboard data<br/>",
        challengeInstanceId: {
          "!doc": "The leaderboard's challenge id<br/>",
          "!type": "string"
        },
        data: {
          "!doc": "The leaderboard data<br/>",
          "!type": "[_LeaderboardData]"
        },
        first: {
          "!doc": "The first item in the leaderboard data<br/>",
          "!type": "[_LeaderboardData]"
        },
        last: {
          "!doc": "The last item in the leaderboard data<br/>",
          "!type": "[_LeaderboardData]"
        },
        leaderboardShortCode: {
          "!doc": "The leaderboard short code<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _LeaderboardsEntriesResponse: {
        "!doc": 'A response containing leaderboard entry data for a given player. The response will contain one key for every leaderboard in the result. Example response: {"HS": [{"userId":"537f08e1e4b01fdedfa52c49","SCORE": 123,"city":"York","country":"GB","userName":"","when":"2014-07-17T12:18Z","rank": 1  }]}<br/>',
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _LeaveTeamResponse: {
        "!doc": "A response to a player leaving a team<br/>",
        members: {
          "!doc": "The team members<br/>",
          "!type": "[_Player]"
        },
        owner: {
          "!doc": "A summary of the owner<br/>",
          "!type": "_Player"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        teamId: {
          "!doc": "The Id of the team<br/>",
          "!type": "string"
        },
        teamName: {
          "!doc": "The team name<br/>",
          "!type": "string"
        },
        teamType: {
          "!doc": "The team type<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListAchievementsResponse: {
        "!doc": "A reponse containing the game's achievments and an indication of whether the player has earned it<br/>",
        achievements: {
          "!doc": "A list of JSON achievment objects<br/>",
          "!type": "[_Achievement]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListBulkJobsAdminResponse: {
        "!doc": "A response listing existing bulk jobs<br/>",
        bulkJobs: {
          "!doc": "A list of JSON objects containing bulk jobs<br/>",
          "!type": "[_BulkJob]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListChallengeResponse: {
        "!doc": "A response containing challenges that are in the state that was specified in the request<br/>",
        challengeInstances: {
          "!doc": "A list of JSON objects representing the challenges.<br/>",
          "!type": "[_Challenge]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListChallengeTypeResponse: {
        "!doc": "A response containing the list of configured challenge types in the game<br/>",
        challengeTemplates: {
          "!doc": "A list of JSON objects containing the challenge templates for the game<br/>",
          "!type": "[_ChallengeType]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListGameFriendsResponse: {
        "!doc": "A response containing the list of the current players game friends.<br/>",
        friends: {
          "!doc": "A list of JSON objects containing game friend data<br/>",
          "!type": "[_Player]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListInviteFriendsResponse: {
        "!doc": "A response containing a list of non game friends.<br/>",
        friends: {
          "!doc": "A list of JSON objects containing game friend data<br/>",
          "!type": "[_InvitableFriend]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListLeaderboardsResponse: {
        "!doc": "A response containing a list of all leaderboards configured in the game.<br/>",
        leaderboards: {
          "!doc": "A list of JSON object containing leaderboard meta data<br/>",
          "!type": "[_Leaderboard]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListMessageDetailResponse: {
        "!doc": "A response containing the list of the current players messages / notifications.<br/>",
        messageList: {
          "!doc": "A list of JSON objects containing player messages<br/>",
          "!type": "[_PlayerMessage]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListMessageResponse: {
        "!doc": "A response containing the list of the current players messages / notifications.<br/>",
        messageList: {
          "!doc": "A list of JSON objects containing player messages<br/>",
          "!type": "[?]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListMessageSummaryResponse: {
        "!doc": "A response containing a summary of the list of the current players messages / notifications.<br/>",
        messageList: {
          "!doc": "A list of JSON objects containing player message summaries<br/>",
          "!type": "[?]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListTeamChatResponse: {
        "!doc": "A response to a list team messages request.<br/>",
        messages: {
          "!doc": "The collection of team chat messages<br/>",
          "!type": "[_ChatMessage]"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListTeamsResponse: {
        "!doc": "A response containing the list of teams for a game.<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        teams: {
          "!doc": "A list of JSON objects containing team information<br/>",
          "!type": "[_Team]"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListTransactionsResponse: {
        "!doc": "A response listing transactions for the player<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        transactionList: {
          "!doc": "A list of JSON objects containing player transactions<br/>",
          "!type": "[_PlayerTransaction]"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ListVirtualGoodsResponse: {
        "!doc": "A response containing the list of configured virtual goods.<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        virtualGoods: {
          "!doc": "A list of JSON objects containing virtual goods data<br/>",
          "!type": "[_VirtualGood]"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _LogChallengeEventResponse: {
        "!doc": "A response to a log challenge event request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _LogEventResponse: {
        "!doc": "A response to a log event request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _MatchDetailsResponse: {
        "!doc": "A response to a match details request<br/>",
        accessToken: {
          "!doc": "The accessToken used to authenticate this player for this match<br/>",
          "!type": "string"
        },
        host: {
          "!doc": "The host to connect to for this match<br/>",
          "!type": "string"
        },
        matchData: {
          "!doc": "MatchData is arbitrary data that can be stored in a Match instance by a Cloud Code script.<br/>",
          "!type": "?"
        },
        matchId: {
          "!doc": "The id for this match instance<br/>",
          "!type": "string"
        },
        opponents: {
          "!doc": "The opponents this player has been matched against<br/>",
          "!type": "[_Player]"
        },
        peerId: {
          "!doc": "The peerId of this player within the match<br/>",
          "!type": "number"
        },
        playerId: {
          "!doc": "The id of the current player<br/>",
          "!type": "string"
        },
        port: {
          "!doc": "The port to connect to for this match<br/>",
          "!type": "number"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _MatchmakingResponse: {
        "!doc": "A response to a matchmaking request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _PushRegistrationResponse: {
        "!doc": "A response to a push registration request<br/>",
        registrationId: {
          "!doc": "An identifier for the successful registration.  Clients should store this value to be used in the event the player no longer wants to receive push notifications to this device.<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _RegistrationResponse: {
        "!doc": "A response to a registration request<br/>",
        authToken: {
          "!doc": "44b297a8-162a-4220-8c14-dad9a1946ad2<br/>",
          "!type": "string"
        },
        displayName: {
          "!doc": "The player's display name<br/>",
          "!type": "string"
        },
        newPlayer: {
          "!doc": "Indicates whether the player was created as part of this request<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        switchSummary: {
          "!doc": "A summary of the player that would be switched to.  Only returned as part of an error response for a request where automatic switching is disabled.<br/>",
          "!type": "_Player"
        },
        userId: {
          "!doc": "The player's id<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _RevokePurchaseGoodsResponse: {
        "!doc": "A response containing details of the revoked items<br/>",
        revokedGoods: {
          "!doc": "The map of revoked goods<br/>",
          "!type": "?"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ScheduleBulkJobAdminResponse: {
        "!doc": "A response acknowledging the scheduling of a bulk job<br/>",
        estimatedCount: {
          "!doc": "The count of players who would be affected by this job if it ran at the time it was submitted<br/>",
          "!type": "number"
        },
        jobId: {
          "!doc": "The unique job ID, used to identify this job in future requests<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _SendFriendMessageResponse: {
        "!doc": "A response to a send friend message request.<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _SendTeamChatMessageResponse: {
        "!doc": "A response to a send team message request.<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _SocialDisconnectResponse: {
        "!doc": "A response to a SocialDisconnectRequest<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _SocialStatusResponse: {
        "!doc": "A response containing the details of a the players social connections<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        statuses: {
          "!doc": "A list of social statuses.<br/>",
          "!type": "[_SocialStatus]"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _UpdateMessageResponse: {
        "!doc": "A response to an update message request<br/>",
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _WithdrawChallengeResponse: {
        "!doc": "A response containing the challenge instance id that was withdrawn by a player<br/>",
        challengeInstanceId: {
          "!doc": "A challenge instance id<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
          "!type": "?"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _AchievementEarnedMessage: {
        "!doc": "Message sent to a player when they have been awarded an achievement within the game.<br/>This message may be triggered by a leaderboard or a script.<br/>The player may have gained a virtual good or virtual currency as a result of gaining the award.<br/>",
        achievementName: {
          "!doc": "The name of achievement.<br/>",
          "!type": "string"
        },
        achievementShortCode: {
          "!doc": "The short code of the achievement.<br/>",
          "!type": "string"
        },
        currency1Earned: {
          "!doc": "The amount of type 1 currency earned.<br/>",
          "!type": "string"
        },
        currency2Earned: {
          "!doc": "The amount of type 2 currency earned.<br/>",
          "!type": "string"
        },
        currency3Earned: {
          "!doc": "The amount of type 3 currency earned.<br/>",
          "!type": "string"
        },
        currency4Earned: {
          "!doc": "The amount of type 4 currency earned.<br/>",
          "!type": "string"
        },
        currency5Earned: {
          "!doc": "The amount of type 5 currency earned.<br/>",
          "!type": "string"
        },
        currency6Earned: {
          "!doc": "The amount of type 6 currency earned.<br/>",
          "!type": "string"
        },
        currencyAwards: {
          "!doc": "An object containing the short codes and amounts of the currencies credited to the player<br/>",
          "!type": "?"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        virtualGoodEarned: {
          "!doc": "The name of the virtual good that was earned.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeAcceptedMessage: {
        "!doc": "A message indicating that the challenge has been accepted.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        message: {
          "!doc": "A player message included in this message.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player whose actions generated this message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeChangedMessage: {
        "!doc": "A message indicating that a player has posted a score in to the challenge's leaderboard.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        leaderboardData: {
          "!doc": "The leaderboard data associated with this challenge.<br/>",
          "!type": "_LeaderboardData"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "Indicates which player has changed the challenge<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeChatMessage: {
        "!doc": "A message containing general chat between players involved in the challenge.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        message: {
          "!doc": "A player message included in this message.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player whose actions generated this message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeDeclinedMessage: {
        "!doc": "A message indicating that a player has declined the challenge.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        message: {
          "!doc": "A player message included in this message.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player whose actions generated this message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeDrawnMessage: {
        "!doc": "A message indicating that the challenge result is a draw.<br/>This message is sent to all the players who have drawn in the current challenge<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        leaderboardData: {
          "!doc": "The leaderboard data associated with this challenge.<br/>",
          "!type": "_LeaderboardData"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeExpiredMessage: {
        "!doc": "A message indicating that the challenge expiry date has passed.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeIssuedMessage: {
        "!doc": "A message indicating that a challenge has been issued.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        message: {
          "!doc": "A player message included in this message.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player whose actions generated this message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeJoinedMessage: {
        "!doc": "A message indicating that the challenge has been joined.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        message: {
          "!doc": "A player message included in this message.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player whose actions generated this message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeLapsedMessage: {
        "!doc": "@Deprecated<br/>A message indicating that the challenge has reached its end time but was not yet started.<br/>This message is no longer used. Instead, a ChallengeExpiredMessage will be triggered.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeLostMessage: {
        "!doc": "A message indicating that the challenge has been lost.<br/>This message is sent to all the players in the challenge who have lost<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        leaderboardData: {
          "!doc": "The leaderboard data associated with this challenge.<br/>",
          "!type": "_LeaderboardData"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        winnerName: {
          "!doc": "The winning players name<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeStartedMessage: {
        "!doc": "A message indicating that the challenge has started<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeTurnTakenMessage: {
        "!doc": "A message indicating that the current player has taken a turn with this challenge.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player whoe has taken their turn.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeWaitingMessage: {
        "!doc": "A message indicating that there is a challenge waiting for the player.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeWithdrawnMessage: {
        "!doc": "A message indicating that the challenging player has withdrawn this challenge.<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        message: {
          "!doc": "A player message included in this message.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player whose actions generated this message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ChallengeWonMessage: {
        "!doc": "A message indicating that the challenge has been won.<br/>This message is only sent to the individual player who has won the challenge<br/>",
        challenge: {
          "!doc": "An object representing the challenge.<br/>",
          "!type": "_Challenge"
        },
        currency1Won: {
          "!doc": "The amount of type 1 currency the player has won.<br/>",
          "!type": "number"
        },
        currency2Won: {
          "!doc": "The amount of type 2 currency the player has won.<br/>",
          "!type": "number"
        },
        currency3Won: {
          "!doc": "The amount of type 3 currency the player has won.<br/>",
          "!type": "number"
        },
        currency4Won: {
          "!doc": "The amount of type 4 currency the player has won.<br/>",
          "!type": "number"
        },
        currency5Won: {
          "!doc": "The amount of type 5 currency the player has won.<br/>",
          "!type": "number"
        },
        currency6Won: {
          "!doc": "The amount of type 6 currency the player has won.<br/>",
          "!type": "number"
        },
        currencyWinnings: {
          "!doc": "An object containing the short codes and amounts of the currencies the player has won<br/>",
          "!type": "?"
        },
        leaderboardData: {
          "!doc": "The leaderboard data associated with this challenge.<br/>",
          "!type": "_LeaderboardData"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        winnerName: {
          "!doc": "The winning player's name.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _FriendMessage: {
        "!doc": "A message sent from a player to one of his social network friends.<br/>",
        fromId: {
          "!doc": "The player's id who is sending the message.<br/>",
          "!type": "string"
        },
        message: {
          "!doc": "The player's message.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player who is sending the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _GlobalRankChangedMessage: {
        "!doc": "This message is sent to players when their rank in a global leaderboard changes such that they are knocked out of the configured 'Top N'.<br/>",
        gameId: {
          "!doc": "The game id that this message relates to.<br/>",
          "!type": "number"
        },
        leaderboardName: {
          "!doc": "The leaderboard's name.<br/>",
          "!type": "string"
        },
        leaderboardShortCode: {
          "!doc": "The leaderboard shortcode.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        them: {
          "!doc": "The score details of the player whose score the receiving player has passed.<br/>",
          "!type": "_LeaderboardData"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        you: {
          "!doc": "The score details of the receiving player.<br/>",
          "!type": "_LeaderboardData"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _MatchFoundMessage: {
        "!doc": "A message indicating that a match has been found<br/>",
        accessToken: {
          "!doc": "The accessToken used to authenticate this player for this match<br/>",
          "!type": "string"
        },
        host: {
          "!doc": "The host to connect to for this match<br/>",
          "!type": "string"
        },
        matchData: {
          "!doc": "MatchData is arbitrary data that can be stored in a Match instance by a Cloud Code script.<br/>",
          "!type": "?"
        },
        matchGroup: {
          "!doc": "The group the player was assigned in the matchmaking request<br/>",
          "!type": "string"
        },
        matchId: {
          "!doc": "The id for this match instance<br/>",
          "!type": "string"
        },
        matchShortCode: {
          "!doc": "The shortCode of the match type this message for<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        participants: {
          "!doc": "The participants in this match<br/>",
          "!type": "[_Participant]"
        },
        port: {
          "!doc": "The port to connect to for this match<br/>",
          "!type": "number"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _MatchNotFoundMessage: {
        "!doc": "A message indicating that no suitable match was found during the configured time<br/>",
        matchData: {
          "!doc": "MatchData is arbitrary data that can be stored in a Match instance by a Cloud Code script.<br/>",
          "!type": "?"
        },
        matchGroup: {
          "!doc": "The group the player was assigned in the matchmaking request<br/>",
          "!type": "string"
        },
        matchShortCode: {
          "!doc": "The shortCode of the match type this message for<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        participantData: {
          "!doc": "A JSON Map of any data that was associated to this user<br/>",
          "!type": "?"
        },
        participants: {
          "!doc": "The participants in this match<br/>",
          "!type": "[_Participant]"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _MatchUpdatedMessage: {
        "!doc": "A message indicating that there has been an update to a pending match request, but it is not yet complete<br/>",
        addedPlayers: {
          "!doc": "The players that joined this match<br/>",
          "!type": "[string]"
        },
        matchData: {
          "!doc": "MatchData is arbitrary data that can be stored in a Match instance by a Cloud Code script.<br/>",
          "!type": "?"
        },
        matchGroup: {
          "!doc": "The group the player was assigned in the matchmaking request<br/>",
          "!type": "string"
        },
        matchId: {
          "!doc": "The id for this match instance<br/>",
          "!type": "string"
        },
        matchShortCode: {
          "!doc": "The shortCode of the match type this message for<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        participants: {
          "!doc": "The participants in this match<br/>",
          "!type": "[_Participant]"
        },
        removedPlayers: {
          "!doc": "The players that left this match<br/>",
          "!type": "[string]"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _NewHighScoreMessage: {
        "!doc": "A message indicating that the player has achieved a new high score in the game.<br/>",
        leaderboardData: {
          "!doc": "The new leaderboard data associated with this message.<br/>",
          "!type": "_LeaderboardData"
        },
        leaderboardName: {
          "!doc": "The leaderboard's name.<br/>",
          "!type": "string"
        },
        leaderboardShortCode: {
          "!doc": "The leaderboard shortcode.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        rankDetails: {
          "!doc": "The ranking information for the new score.<br/>",
          "!type": "_LeaderboardRankDetails"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _NewTeamScoreMessage: {
        "!doc": "A message indicating that the player's team has achieved a new high score in the game.<br/>",
        leaderboardData: {
          "!doc": "The new leaderboard data associated with this message.<br/>",
          "!type": "_LeaderboardData"
        },
        leaderboardName: {
          "!doc": "The leaderboard's name.<br/>",
          "!type": "string"
        },
        leaderboardShortCode: {
          "!doc": "The leaderboard shortcode.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        rankDetails: {
          "!doc": "The ranking information for the new score.<br/>",
          "!type": "_LeaderboardRankDetails"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _ScriptMessage: {
        "!doc": "A message sent from a Cloud Code script to one or more players.<br/>See the Spark.sendMessage function in the Cloud Code - Java Script API documentation.<br/>",
        data: {
          "!doc": "JSON data sent from a Cloud Code script.<br/>",
          "!type": "?"
        },
        extCode: {
          "!doc": "The extension code used when creating this script message<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _SessionTerminatedMessage: {
        "!doc": "A message sent to sockets when disconnectOthers() has been called.<br/>",
        authToken: {
          "!doc": "Used to automatically re-authenticate a client during socket connect.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _SocialRankChangedMessage: {
        "!doc": "This message is sent to players when their rank in a leaderboard changes with respect to the rank of their social network friends.<br/>",
        gameId: {
          "!doc": "The game id that this message relates to.<br/>",
          "!type": "number"
        },
        leaderboardName: {
          "!doc": "The leaderboard's name.<br/>",
          "!type": "string"
        },
        leaderboardShortCode: {
          "!doc": "The leaderboard shortcode.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        them: {
          "!doc": "The score details of the player whose score the receiving player has passed.<br/>",
          "!type": "_LeaderboardData"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        you: {
          "!doc": "The score details of the receiving player.<br/>",
          "!type": "_LeaderboardData"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _TeamChatMessage: {
        "!doc": "A message sent from a player to an entire team.<br/>",
        chatMessageId: {
          "!doc": "The identifier for this message as it appears in the chat history.<br/>",
          "!type": "string"
        },
        fromId: {
          "!doc": "The player's id who is sending the message.<br/>",
          "!type": "string"
        },
        message: {
          "!doc": "The message to send to the team.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        ownerId: {
          "!doc": "The id of the owner<br/>",
          "!type": "string"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        teamId: {
          "!doc": "The id of the team<br/>",
          "!type": "string"
        },
        teamType: {
          "!doc": "The team type<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        who: {
          "!doc": "The name of the player who is sending the message.<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _TeamRankChangedMessage: {
        "!doc": "This message is sent to players when their rank in a global leaderboard changes such that they are knocked out of the configured 'Top N'.<br/>",
        gameId: {
          "!doc": "The game id that this message relates to.<br/>",
          "!type": "number"
        },
        leaderboardName: {
          "!doc": "The leaderboard's name.<br/>",
          "!type": "string"
        },
        leaderboardShortCode: {
          "!doc": "The leaderboard shortcode.<br/>",
          "!type": "string"
        },
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        them: {
          "!doc": "The score details of the team whose score the receiving team's players have passed.<br/>",
          "!type": "_LeaderboardData"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        you: {
          "!doc": "The score details of the receiving team.<br/>",
          "!type": "_LeaderboardData"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      },
      _UploadCompleteMessage: {
        "!doc": "A message indicating that the asynchronous upload task trigger by the player is now complete.<br/>",
        messageId: {
          "!doc": "A unique identifier for this message.<br/>",
          "!type": "string"
        },
        notification: {
          "!doc": "Flag indicating whether this message could be sent as a push notification or not.<br/>",
          "!type": "bool"
        },
        scriptData: {
          "!doc": "ScriptData is arbitrary data that can be stored in a message by a Cloud Code script.<br/>",
          "!type": "?"
        },
        subTitle: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        summary: {
          "!doc": "A textual summary describing the message's purpose.<br/>",
          "!type": "string"
        },
        title: {
          "!doc": "A textual title for the message.<br/>",
          "!type": "string"
        },
        uploadData: {
          "!doc": "The upload data (if supplied as part of GetUploadUrlRequest) of UploadData objects<br/>",
          "!type": "_UploadData"
        },
        uploadId: {
          "!doc": "The id of the upload<br/>",
          "!type": "string"
        },
        error: {
          "!doc": "The errors returned from the API",
          "!type": "JSON"
        }
      }
    }
  },
  {
    "!name": "GSRT",
    RTSession: {
      "!doc": "The main entry point into the GameSparksRT API<br/>",
      clearInterval: {
        "!doc": "Clears an interval using the id returned from a previous setInterval call<br/>",
        "!type": "fn(intervalId: number)"
      },
      clearTimeout: {
        "!doc": "Clears a timeout using the id returned from a previous setTimeout call<br/>",
        "!type": "fn(timeoutId: number)"
      },
      getLogger: {
        "!doc": 'Gets the logger object. Log records are written to the GameSparks collection " realtime.log"<br/>',
        "!type": "fn() -> RTSession.RTLogger"
      },
      newData: {
        "!doc": "Creates a new builder object to construct RTData objects<br/>",
        "!type": "fn() -> RTSession.RTDataBuilder"
      },
      newPacket: {
        "!doc": "Creates a new builder object to construct RTPacket objects<br/>",
        "!type": "fn() -> RTSession.RTPacketBuilder"
      },
      onPacket: {
        "!doc": "Register a callback to be invoked when a packet with the given opCode is recieved. If this function does not return the supplied packet, the packet will not be sent to any players<br/>",
        "!type": "fn(opCode: number, callback: fn(packet: RTSession.RTPacket))"
      },
      onPlayerConnect: {
        "!doc": "Register a callback to be invoked when a player connects to the session<br/>",
        "!type": "fn(callback: fn(player: RTSession.RTPlayer))"
      },
      onPlayerDisconnect: {
        "!doc": "Register a callback to be invoked when a player disconnects from the session<br/>",
        "!type": "fn(callback: fn(player: RTSession.RTPlayer))"
      },
      onSessionShutdown: {
        "!doc": "Register a callback to be invoked when the session is shutdown.<br/>This is 60 seconds after the last player disconnects.<br/>",
        "!type": "fn(callback: fn())"
      },
      getPlayer: {
        "!doc": "Gets a player by peerId<br/>",
        "!type": "fn(peerId: number) -> RTSession.RTPlayer"
      },
      getPlayers: {
        "!doc": "Gets all connected players<br/>",
        "!type": "fn() -> [RTSession.RTPlayer]"
      },
      getSessionId: {
        "!doc": "Gets the current sessionId<br/>",
        "!type": "fn() -> string"
      },
      setInterval: {
        "!doc": "The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds).<br/>The setInterval() method will continue calling the function until clearInterval() is called, or the window is closed<br/>The ID value returned by setInterval() is used as the parameter for the clearInterval() method.<br/>",
        "!type": "fn(callback: fn(), ms: number) -> number"
      },
      setTimeout: {
        "!doc": "Calls a function or evaluates an expression after a specified number of milliseconds.<br/>",
        "!type": "fn(callback: fn(), ms: number) -> number"
      },
      newRequest: {
        "!doc": "A builder for GameSparks requests",
        "!type": "fn() -> +RTSession.newRequest",
        prototype: {
          createAcceptChallengeRequest: {
            "!doc": "Creates a new AcceptChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.AcceptChallengeRequest"
          },
          createAccountDetailsRequest: {
            "!doc": "Creates a new AccountDetailsRequest",
            "!type": "fn() -> +RTSession.newRequest.AccountDetailsRequest"
          },
          createAmazonBuyGoodsRequest: {
            "!doc": "Creates a new AmazonBuyGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.AmazonBuyGoodsRequest"
          },
          createAmazonConnectRequest: {
            "!doc": "Creates a new AmazonConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.AmazonConnectRequest"
          },
          createAnalyticsRequest: {
            "!doc": "Creates a new AnalyticsRequest",
            "!type": "fn() -> +RTSession.newRequest.AnalyticsRequest"
          },
          createAroundMeLeaderboardRequest: {
            "!doc": "Creates a new AroundMeLeaderboardRequest",
            "!type": "fn() -> +RTSession.newRequest.AroundMeLeaderboardRequest"
          },
          createAuthenticationRequest: {
            "!doc": "Creates a new AuthenticationRequest",
            "!type": "fn() -> +RTSession.newRequest.AuthenticationRequest"
          },
          createBatchAdminRequest: {
            "!doc": "Creates a new BatchAdminRequest",
            "!type": "fn() -> +RTSession.newRequest.BatchAdminRequest"
          },
          createBuyVirtualGoodsRequest: {
            "!doc": "Creates a new BuyVirtualGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.BuyVirtualGoodsRequest"
          },
          createCancelBulkJobAdminRequest: {
            "!doc": "Creates a new CancelBulkJobAdminRequest",
            "!type": "fn() -> +RTSession.newRequest.CancelBulkJobAdminRequest"
          },
          createChangeUserDetailsRequest: {
            "!doc": "Creates a new ChangeUserDetailsRequest",
            "!type": "fn() -> +RTSession.newRequest.ChangeUserDetailsRequest"
          },
          createChatOnChallengeRequest: {
            "!doc": "Creates a new ChatOnChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.ChatOnChallengeRequest"
          },
          createConsumeVirtualGoodRequest: {
            "!doc": "Creates a new ConsumeVirtualGoodRequest",
            "!type": "fn() -> +RTSession.newRequest.ConsumeVirtualGoodRequest"
          },
          createCreateChallengeRequest: {
            "!doc": "Creates a new CreateChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.CreateChallengeRequest"
          },
          createCreateTeamRequest: {
            "!doc": "Creates a new CreateTeamRequest",
            "!type": "fn() -> +RTSession.newRequest.CreateTeamRequest"
          },
          createDeclineChallengeRequest: {
            "!doc": "Creates a new DeclineChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.DeclineChallengeRequest"
          },
          createDeviceAuthenticationRequest: {
            "!doc": "Creates a new DeviceAuthenticationRequest",
            "!type": "fn() -> +RTSession.newRequest.DeviceAuthenticationRequest"
          },
          createDismissMessageRequest: {
            "!doc": "Creates a new DismissMessageRequest",
            "!type": "fn() -> +RTSession.newRequest.DismissMessageRequest"
          },
          createDismissMultipleMessagesRequest: {
            "!doc": "Creates a new DismissMultipleMessagesRequest",
            "!type": "fn() -> +RTSession.newRequest.DismissMultipleMessagesRequest"
          },
          createDropTeamRequest: {
            "!doc": "Creates a new DropTeamRequest",
            "!type": "fn() -> +RTSession.newRequest.DropTeamRequest"
          },
          createEndSessionRequest: {
            "!doc": "Creates a new EndSessionRequest",
            "!type": "fn() -> +RTSession.newRequest.EndSessionRequest"
          },
          createFacebookConnectRequest: {
            "!doc": "Creates a new FacebookConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.FacebookConnectRequest"
          },
          createFindChallengeRequest: {
            "!doc": "Creates a new FindChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.FindChallengeRequest"
          },
          createFindPendingMatchesRequest: {
            "!doc": "Creates a new FindPendingMatchesRequest",
            "!type": "fn() -> +RTSession.newRequest.FindPendingMatchesRequest"
          },
          createGameCenterConnectRequest: {
            "!doc": "Creates a new GameCenterConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.GameCenterConnectRequest"
          },
          createGetChallengeRequest: {
            "!doc": "Creates a new GetChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.GetChallengeRequest"
          },
          createGetDownloadableRequest: {
            "!doc": "Creates a new GetDownloadableRequest",
            "!type": "fn() -> +RTSession.newRequest.GetDownloadableRequest"
          },
          createGetLeaderboardEntriesRequest: {
            "!doc": "Creates a new GetLeaderboardEntriesRequest",
            "!type": "fn() -> +RTSession.newRequest.GetLeaderboardEntriesRequest"
          },
          createGetMessageRequest: {
            "!doc": "Creates a new GetMessageRequest",
            "!type": "fn() -> +RTSession.newRequest.GetMessageRequest"
          },
          createGetMyTeamsRequest: {
            "!doc": "Creates a new GetMyTeamsRequest",
            "!type": "fn() -> +RTSession.newRequest.GetMyTeamsRequest"
          },
          createGetPropertyRequest: {
            "!doc": "Creates a new GetPropertyRequest",
            "!type": "fn() -> +RTSession.newRequest.GetPropertyRequest"
          },
          createGetPropertySetRequest: {
            "!doc": "Creates a new GetPropertySetRequest",
            "!type": "fn() -> +RTSession.newRequest.GetPropertySetRequest"
          },
          createGetTeamRequest: {
            "!doc": "Creates a new GetTeamRequest",
            "!type": "fn() -> +RTSession.newRequest.GetTeamRequest"
          },
          createGetUploadUrlRequest: {
            "!doc": "Creates a new GetUploadUrlRequest",
            "!type": "fn() -> +RTSession.newRequest.GetUploadUrlRequest"
          },
          createGetUploadedRequest: {
            "!doc": "Creates a new GetUploadedRequest",
            "!type": "fn() -> +RTSession.newRequest.GetUploadedRequest"
          },
          createGooglePlayBuyGoodsRequest: {
            "!doc": "Creates a new GooglePlayBuyGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.GooglePlayBuyGoodsRequest"
          },
          createGooglePlayConnectRequest: {
            "!doc": "Creates a new GooglePlayConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.GooglePlayConnectRequest"
          },
          createGooglePlusConnectRequest: {
            "!doc": "Creates a new GooglePlusConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.GooglePlusConnectRequest"
          },
          createIOSBuyGoodsRequest: {
            "!doc": "Creates a new IOSBuyGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.IOSBuyGoodsRequest"
          },
          createJoinChallengeRequest: {
            "!doc": "Creates a new JoinChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.JoinChallengeRequest"
          },
          createJoinPendingMatchRequest: {
            "!doc": "Creates a new JoinPendingMatchRequest",
            "!type": "fn() -> +RTSession.newRequest.JoinPendingMatchRequest"
          },
          createJoinTeamRequest: {
            "!doc": "Creates a new JoinTeamRequest",
            "!type": "fn() -> +RTSession.newRequest.JoinTeamRequest"
          },
          createKongregateConnectRequest: {
            "!doc": "Creates a new KongregateConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.KongregateConnectRequest"
          },
          createLeaderboardDataRequest: {
            "!doc": "Creates a new LeaderboardDataRequest",
            "!type": "fn() -> +RTSession.newRequest.LeaderboardDataRequest"
          },
          createLeaderboardsEntriesRequest: {
            "!doc": "Creates a new LeaderboardsEntriesRequest",
            "!type": "fn() -> +RTSession.newRequest.LeaderboardsEntriesRequest"
          },
          createLeaveTeamRequest: {
            "!doc": "Creates a new LeaveTeamRequest",
            "!type": "fn() -> +RTSession.newRequest.LeaveTeamRequest"
          },
          createListAchievementsRequest: {
            "!doc": "Creates a new ListAchievementsRequest",
            "!type": "fn() -> +RTSession.newRequest.ListAchievementsRequest"
          },
          createListBulkJobsAdminRequest: {
            "!doc": "Creates a new ListBulkJobsAdminRequest",
            "!type": "fn() -> +RTSession.newRequest.ListBulkJobsAdminRequest"
          },
          createListChallengeRequest: {
            "!doc": "Creates a new ListChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.ListChallengeRequest"
          },
          createListChallengeTypeRequest: {
            "!doc": "Creates a new ListChallengeTypeRequest",
            "!type": "fn() -> +RTSession.newRequest.ListChallengeTypeRequest"
          },
          createListGameFriendsRequest: {
            "!doc": "Creates a new ListGameFriendsRequest",
            "!type": "fn() -> +RTSession.newRequest.ListGameFriendsRequest"
          },
          createListInviteFriendsRequest: {
            "!doc": "Creates a new ListInviteFriendsRequest",
            "!type": "fn() -> +RTSession.newRequest.ListInviteFriendsRequest"
          },
          createListLeaderboardsRequest: {
            "!doc": "Creates a new ListLeaderboardsRequest",
            "!type": "fn() -> +RTSession.newRequest.ListLeaderboardsRequest"
          },
          createListMessageDetailRequest: {
            "!doc": "Creates a new ListMessageDetailRequest",
            "!type": "fn() -> +RTSession.newRequest.ListMessageDetailRequest"
          },
          createListMessageRequest: {
            "!doc": "Creates a new ListMessageRequest",
            "!type": "fn() -> +RTSession.newRequest.ListMessageRequest"
          },
          createListMessageSummaryRequest: {
            "!doc": "Creates a new ListMessageSummaryRequest",
            "!type": "fn() -> +RTSession.newRequest.ListMessageSummaryRequest"
          },
          createListTeamChatRequest: {
            "!doc": "Creates a new ListTeamChatRequest",
            "!type": "fn() -> +RTSession.newRequest.ListTeamChatRequest"
          },
          createListTeamsRequest: {
            "!doc": "Creates a new ListTeamsRequest",
            "!type": "fn() -> +RTSession.newRequest.ListTeamsRequest"
          },
          createListTransactionsRequest: {
            "!doc": "Creates a new ListTransactionsRequest",
            "!type": "fn() -> +RTSession.newRequest.ListTransactionsRequest"
          },
          createListVirtualGoodsRequest: {
            "!doc": "Creates a new ListVirtualGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.ListVirtualGoodsRequest"
          },
          createLogChallengeEventRequest: {
            "!doc": "Creates a new LogChallengeEventRequest",
            "!type": "fn() -> +RTSession.newRequest.LogChallengeEventRequest"
          },
          createLogEventRequest: {
            "!doc": "Creates a new LogEventRequest",
            "!type": "fn() -> +RTSession.newRequest.LogEventRequest"
          },
          createMatchDetailsRequest: {
            "!doc": "Creates a new MatchDetailsRequest",
            "!type": "fn() -> +RTSession.newRequest.MatchDetailsRequest"
          },
          createMatchmakingRequest: {
            "!doc": "Creates a new MatchmakingRequest",
            "!type": "fn() -> +RTSession.newRequest.MatchmakingRequest"
          },
          createNXConnectRequest: {
            "!doc": "Creates a new NXConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.NXConnectRequest"
          },
          createPSNConnectRequest: {
            "!doc": "Creates a new PSNConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.PSNConnectRequest"
          },
          createPsnBuyGoodsRequest: {
            "!doc": "Creates a new PsnBuyGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.PsnBuyGoodsRequest"
          },
          createPushRegistrationRequest: {
            "!doc": "Creates a new PushRegistrationRequest",
            "!type": "fn() -> +RTSession.newRequest.PushRegistrationRequest"
          },
          createQQConnectRequest: {
            "!doc": "Creates a new QQConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.QQConnectRequest"
          },
          createRegistrationRequest: {
            "!doc": "Creates a new RegistrationRequest",
            "!type": "fn() -> +RTSession.newRequest.RegistrationRequest"
          },
          createRevokePurchaseGoodsRequest: {
            "!doc": "Creates a new RevokePurchaseGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.RevokePurchaseGoodsRequest"
          },
          createScheduleBulkJobAdminRequest: {
            "!doc": "Creates a new ScheduleBulkJobAdminRequest",
            "!type": "fn() -> +RTSession.newRequest.ScheduleBulkJobAdminRequest"
          },
          createSendFriendMessageRequest: {
            "!doc": "Creates a new SendFriendMessageRequest",
            "!type": "fn() -> +RTSession.newRequest.SendFriendMessageRequest"
          },
          createSendTeamChatMessageRequest: {
            "!doc": "Creates a new SendTeamChatMessageRequest",
            "!type": "fn() -> +RTSession.newRequest.SendTeamChatMessageRequest"
          },
          createSocialDisconnectRequest: {
            "!doc": "Creates a new SocialDisconnectRequest",
            "!type": "fn() -> +RTSession.newRequest.SocialDisconnectRequest"
          },
          createSocialLeaderboardDataRequest: {
            "!doc": "Creates a new SocialLeaderboardDataRequest",
            "!type": "fn() -> +RTSession.newRequest.SocialLeaderboardDataRequest"
          },
          createSocialStatusRequest: {
            "!doc": "Creates a new SocialStatusRequest",
            "!type": "fn() -> +RTSession.newRequest.SocialStatusRequest"
          },
          createSteamBuyGoodsRequest: {
            "!doc": "Creates a new SteamBuyGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.SteamBuyGoodsRequest"
          },
          createSteamConnectRequest: {
            "!doc": "Creates a new SteamConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.SteamConnectRequest"
          },
          createTwitchConnectRequest: {
            "!doc": "Creates a new TwitchConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.TwitchConnectRequest"
          },
          createTwitterConnectRequest: {
            "!doc": "Creates a new TwitterConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.TwitterConnectRequest"
          },
          createUpdateMessageRequest: {
            "!doc": "Creates a new UpdateMessageRequest",
            "!type": "fn() -> +RTSession.newRequest.UpdateMessageRequest"
          },
          createViberConnectRequest: {
            "!doc": "Creates a new ViberConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.ViberConnectRequest"
          },
          createWeChatConnectRequest: {
            "!doc": "Creates a new WeChatConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.WeChatConnectRequest"
          },
          createWindowsBuyGoodsRequest: {
            "!doc": "Creates a new WindowsBuyGoodsRequest",
            "!type": "fn() -> +RTSession.newRequest.WindowsBuyGoodsRequest"
          },
          createWithdrawChallengeRequest: {
            "!doc": "Creates a new WithdrawChallengeRequest",
            "!type": "fn() -> +RTSession.newRequest.WithdrawChallengeRequest"
          },
          createXBOXLiveConnectRequest: {
            "!doc": "Creates a new XBOXLiveConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.XBOXLiveConnectRequest"
          },
          createXboxOneConnectRequest: {
            "!doc": "Creates a new XboxOneConnectRequest",
            "!type": "fn() -> +RTSession.newRequest.XboxOneConnectRequest"
          }
        },
        AcceptChallengeRequest: {
          "!doc": "Accepts a challenge that has been issued to the current player.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The ID of the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setMessage: {
              "!doc": "An optional message to send with the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AcceptChallengeResponse))"
            }
          }
        },
        AccountDetailsRequest: {
          "!doc": "Retrieves the details of the current authenticated player.<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AccountDetailsResponse))"
            }
          }
        },
        AmazonBuyGoodsRequest: {
          "!doc": "Processes the receipt from an Amazon in app purchase.<br/>The GameSparks platform will validate the amazonUserId and receiptId with Amazon using the Amazon Purchase Secret configured against the game.<br/>The receiptId in the data will be recorded and the request will be rejected if the receiptId has previously been processed, this prevents replay attacks.<br/>Once verfied, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the receipt with the 'Amazon Product Id' configured against the virtual good.<br/>",
          prototype: {
            setAmazonUserId: {
              "!doc": "The userId obtained from the UserData within a PurchaseResponse<br/>",
              "!type": "fn(string) -> !this"
            },
            setCurrencyCode: {
              "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
              "!type": "fn(string) -> !this"
            },
            setReceiptId: {
              "!doc": "The receiptId obtained from the Receipt within a PurchaseResponse<br/>",
              "!type": "fn(string) -> !this"
            },
            setSubUnitPrice: {
              "!doc": "The price of this purchase<br/>",
              "!type": "fn(number) -> !this"
            },
            setUniqueTransactionByPlayer: {
              "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BuyVirtualGoodResponse))"
            }
          }
        },
        AmazonConnectRequest: {
          "!doc": "Allows an Amazon access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Amazon platform and store them within GameSparks.<br/>If the Amazon user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Amazon user is not already registered with the game, the Amazon user will be linked to the current player.<br/>If the current player has not authenticated and the Amazon user is not known, a new player will be created using the Amazon details and the session will be authenticated against the new player.<br/>If the Amazon user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        AnalyticsRequest: {
          "!doc": "Records some custom analytical data.<br/>Simple analytics, where you just need to track the number of times something happened, just take a key parameter. We'll record the players id against the data to allow you to report on averages per user<br/>Timed analytics allow you to send start and end timer requests, and with this data GameSparks can track the length of time something takes.<br/>If an end request is sent without a matching start timer the request will fail silently and your analytics data might not contain what you expect.<br/>If both start and end are supplied, the request will be treated as a start timer.<br/>An additional data payload can be attached to the event for advanced reporting. This data can be a string, number or JSON object.<br/>If a second start timer is created using a key that has already had a start timer created without an end, the previous one will be marked as abandoned.<br/>",
          prototype: {
            setData: {
              "!doc": "Custom data payload<br/>",
              "!type": "fn(?) -> !this"
            },
            setEnd: {
              "!doc": "Use the value true to indicate it's an end timer<br/>",
              "!type": "fn(bool) -> !this"
            },
            setKey: {
              "!doc": "The key you want to track this analysis with.<br/>",
              "!type": "fn(string) -> !this"
            },
            setStart: {
              "!doc": "Use the value true to indicate it's a start timer<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AnalyticsResponse))"
            }
          }
        },
        AroundMeLeaderboardRequest: {
          "!doc": "Returns leaderboard data that is adjacent to the currently signed in player's position within the given leaderboard.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The challenge instance to get the leaderboard data for<br/>",
              "!type": "fn(string) -> !this"
            },
            setCustomIdFilter: {
              "!doc": "An optional filter on the customIds.<br/>If this request does not contain a custonIdFilter or if it is a partial filter, <br/>the leaderboard entries around the highest score for the given constraints will be returned.<br/>",
              "!type": "fn(?) -> !this"
            },
            setDontErrorOnNotSocial: {
              "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setFriendIds: {
              "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
              "!type": "fn([string]) -> !this"
            },
            setIncludeFirst: {
              "!doc": "Number of entries to include from head of the list<br/>",
              "!type": "fn(number) -> !this"
            },
            setIncludeLast: {
              "!doc": "Number of entries to include from tail of the list<br/>",
              "!type": "fn(number) -> !this"
            },
            setInverseSocial: {
              "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setLeaderboardShortCode: {
              "!doc": "The short code of the leaderboard<br/>",
              "!type": "fn(string) -> !this"
            },
            setSocial: {
              "!doc": "If True returns a leaderboard of the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTeamIds: {
              "!doc": "The IDs of the teams you are interested in<br/>",
              "!type": "fn([string]) -> !this"
            },
            setTeamTypes: {
              "!doc": "The type of team you are interested in<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AroundMeLeaderboardResponse))"
            }
          }
        },
        AuthenticationRequest: {
          "!doc": "Provides authentication using a username/password combination.<br/>The username will have been previously created using a RegistrationRequest.<br/>",
          prototype: {
            setPassword: {
              "!doc": "The previously registered password<br/>",
              "!type": "fn(string) -> !this"
            },
            setUserName: {
              "!doc": "The previously registered player name<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        BatchAdminRequest: {
          "!doc": "Performs a request for multiple players.<br/>",
          prototype: {
            setPlayerIds: {
              "!doc": "The players to run the request for.<br/>",
              "!type": "fn([string]) -> !this"
            },
            setRequest: {
              "!doc": "The request to be run for each player.<br/>",
              "!type": "fn(RTSession.newRequest.DBObject) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BatchAdminResponse))"
            }
          }
        },
        BuyVirtualGoodsRequest: {
          "!doc": "Purchases a virtual good with an in game currency. Once purchased the virtual good will be added to the players account.<br/>",
          prototype: {
            setCurrencyShortCode: {
              "!doc": "The short code of the currency to use<br/>",
              "!type": "fn(string) -> !this"
            },
            setCurrencyType: {
              "!doc": "Which virtual currency to use. (1 to 6)<br/>",
              "!type": "fn(number) -> !this"
            },
            setQuantity: {
              "!doc": "The number of items to purchase<br/>",
              "!type": "fn(number) -> !this"
            },
            setShortCode: {
              "!doc": "The short code of the virtual good to be purchased<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BuyVirtualGoodResponse))"
            }
          }
        },
        CancelBulkJobAdminRequest: {
          "!doc": "Cancel one or more bulk jobs.<br/>",
          prototype: {
            setBulkJobIds: {
              "!doc": "The IDs of existing bulk jobs to cancel<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.CancelBulkJobAdminResponse))"
            }
          }
        },
        ChangeUserDetailsRequest: {
          "!doc": "Change the details of the currently signed in Player.<br/>",
          prototype: {
            setDisplayName: {
              "!doc": "The new display name to set in the player data.<br/>",
              "!type": "fn(string) -> !this"
            },
            setLanguage: {
              "!doc": "The new language code to set in the player data.<br/>",
              "!type": "fn(string) -> !this"
            },
            setNewPassword: {
              "!doc": "The new password to set in the player data.<br/>",
              "!type": "fn(string) -> !this"
            },
            setOldPassword: {
              "!doc": "The player's existing password. If supplied it will be checked against the password stored in the player data. This allows you re-authenticate the player making the change.<br/>",
              "!type": "fn(string) -> !this"
            },
            setUserName: {
              "!doc": "The new userName with which this player will sign in.  If the player currently authenticates using device authentication this will upgrade their account and require them to use username and password authentication from now on.<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ChangeUserDetailsResponse))"
            }
          }
        },
        ChatOnChallengeRequest: {
          "!doc": "Sends a message to all players involved in the challenge. The current player must be involved in the challenge for the message to be sent.<br/>As the message is sent to all players, the current player will also see details of the message in the response. Read the section on response message aggregation for a description of this.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The ID of the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setMessage: {
              "!doc": "An optional message to send with the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ChatOnChallengeResponse))"
            }
          }
        },
        ConsumeVirtualGoodRequest: {
          "!doc": "Consumes a given amount of the specified virtual good.<br/>",
          prototype: {
            setQuantity: {
              "!doc": "The amount of virtual goods to be consumed<br/>",
              "!type": "fn(number) -> !this"
            },
            setShortCode: {
              "!doc": "The short code of the virtual good to be consumed<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ConsumeVirtualGoodResponse))"
            }
          }
        },
        CreateChallengeRequest: {
          "!doc": "Issues a challenge to a group of players from the currently signed in player.<br/>The endTime field must be present unless the challenge template has an achievement set in the 'First to Achievement' field.<br/>The usersToChallenge field must be present for this request if the acessType is PRIVATE (which is the default).<br/>",
          prototype: {
            setAccessType: {
              "!doc": "Who can join this challenge. Either PUBLIC, PRIVATE or FRIENDS<br/>",
              "!type": "fn(string) -> !this"
            },
            setAutoStartJoinedChallengeOnMaxPlayers: {
              "!doc": "Whether this challenge should automatically start when a new player joins and maxPlayers is reached<br/>",
              "!type": "fn(bool) -> !this"
            },
            setChallengeMessage: {
              "!doc": "An optional message to include with the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setChallengeShortCode: {
              "!doc": "The short code of the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setCurrency1Wager: {
              "!doc": "The ammount of currency type 1 that the player is wagering on this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setCurrency2Wager: {
              "!doc": "The amount of currency type 2 that the player is wagering on this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setCurrency3Wager: {
              "!doc": "The amount of currency type 3 that the player is wagering on this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setCurrency4Wager: {
              "!doc": "The amount of currency type 4 that the player is wagering on this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setCurrency5Wager: {
              "!doc": "The amount of currency type 5 that the player is wagering on this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setCurrency6Wager: {
              "!doc": "The amount of currency type 6 that the player is wagering on this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setCurrencyWagers: {
              "!doc": "A JSON object containing the amounts of named currencies that the player is wagering on this challenge<br/>",
              "!type": "fn(?) -> !this"
            },
            setEligibilityCriteria: {
              "!doc": "Criteria for who can and cannot find and join this challenge (when the accessType is PUBLIC or FRIENDS).<br/>Currently supports a field <i>segments</i> that contains segment type against single (where that segment value is required) or multiple (where one of the specified values is required) segment values.<br/>For each segment type a player must have one of the specified values in order to be considered eligible.<br/>",
              "!type": "fn(?) -> !this"
            },
            setEndTime: {
              "!doc": "The time at which this challenge will end. This is required when the challenge is not linked to an achievement<br/>",
              "!type": "fn(date) -> !this"
            },
            setExpiryTime: {
              "!doc": "The latest time that players can join this challenge<br/>",
              "!type": "fn(date) -> !this"
            },
            setMaxAttempts: {
              "!doc": "The maximum number of attempts <br/>",
              "!type": "fn(number) -> !this"
            },
            setMaxPlayers: {
              "!doc": "The maximum number of players that are allowed to join this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setMinPlayers: {
              "!doc": "The minimum number of players that are allowed to join this challenge<br/>",
              "!type": "fn(number) -> !this"
            },
            setSilent: {
              "!doc": "If True  no messaging is triggered<br/>",
              "!type": "fn(bool) -> !this"
            },
            setStartTime: {
              "!doc": "The time at which this challenge will begin<br/>",
              "!type": "fn(date) -> !this"
            },
            setUsersToChallenge: {
              "!doc": "A player id or an array of player ids who will recieve this challenge<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.CreateChallengeResponse))"
            }
          }
        },
        CreateTeamRequest: {
          "!doc": "Allows a new team to be created.<br/>",
          prototype: {
            setTeamId: {
              "!doc": "An optional teamId to use<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamName: {
              "!doc": "A display name to use<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamType: {
              "!doc": "The type of team to be created<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.CreateTeamResponse))"
            }
          }
        },
        DeclineChallengeRequest: {
          "!doc": "Declines a challenge that has been issued to the current player.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The ID of the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setMessage: {
              "!doc": "An optional message to send with the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.DeclineChallengeResponse))"
            }
          }
        },
        DeviceAuthenticationRequest: {
          "!doc": "Allows a device id to be used to create an anonymous profile in the game.<br/>This allows the player to be tracked and have data stored against them before using FacebookConnectRequest to create a full profile.<br/>DeviceAuthenticationRequest should not be used in conjunction with RegistrationRequest as the two accounts will not be merged.<br/>",
          prototype: {
            setDeviceId: {
              "!doc": "A unique device identifier. Each platform has it's own method for getting a unique id<br/>",
              "!type": "fn(string) -> !this"
            },
            setDeviceModel: {
              "!doc": "The device model<br/>",
              "!type": "fn(string) -> !this"
            },
            setDeviceName: {
              "!doc": "The device name<br/>",
              "!type": "fn(string) -> !this"
            },
            setDeviceOS: {
              "!doc": "An indicator of the device platform, should be IOS, ANDROID, WP8 or W8<br/>",
              "!type": "fn(string) -> !this"
            },
            setDeviceType: {
              "!doc": "The device type<br/>",
              "!type": "fn(string) -> !this"
            },
            setDisplayName: {
              "!doc": "An optional displayname for the player<br/>",
              "!type": "fn(string) -> !this"
            },
            setOperatingSystem: {
              "!doc": "The device type<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request reates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        DismissMessageRequest: {
          "!doc": "Allows a message to be dismissed. Once dismissed the message will no longer appear in either ListMessageResponse or ListMessageSummaryResponse.<br/>",
          prototype: {
            setMessageId: {
              "!doc": "The messageId of the message to dismiss<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.DismissMessageResponse))"
            }
          }
        },
        DismissMultipleMessagesRequest: {
          "!doc": "Allows multiple messages to be dismissed. Once dismissed the messages will no longer appear in either ListMessageResponse or ListMessageSummaryResponse.<br/>",
          prototype: {
            setMessageIds: {
              "!doc": "The list of the messageIds to dismiss<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.DismissMultipleMessagesResponse))"
            }
          }
        },
        DropTeamRequest: {
          "!doc": "Allows a player to drop a team.<br/>",
          prototype: {
            setOwnerId: {
              "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamId: {
              "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamType: {
              "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.DropTeamResponse))"
            }
          }
        },
        EndSessionRequest: {
          "!doc": "Records the end of the current player's active session.<br/>The SDK will automatically create a new session ID when the application is started, this method can be useful to call when the app goes into the background to allow reporting on player session length.<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.EndSessionResponse))"
            }
          }
        },
        FacebookConnectRequest: {
          "!doc": "Allows either a Facebook access token, or a Facebook authorization code to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Facebook platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Facebook user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the Facebook user is not already registered with the game, the Facebook user will be linked to the current player.<br/>If the current player has not authenticated and the Facebook user is not known, a new player will be created using the Facebook details and the session will be authenticated against the new player.<br/>If the Facebook user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>It has a longer lifetime than the authorization code, typically on the order of minutes or hours.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained via a refresh token.<br/>",
              "!type": "fn(string) -> !this"
            },
            setCode: {
              "!doc": "An authorization code is a short-lived token representing the user's access grant, created by the authorization server and passed to the client application via the browser.<br/>The client application sends the authorization code to the authorization server to obtain an access token and, optionally, a refresh token.<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        FindChallengeRequest: {
          "!doc": "Allows a player to find challenges that they are eligible to join.<br/>",
          prototype: {
            setAccessType: {
              "!doc": "The type of challenge to find, either PUBLIC or FRIENDS.  Defaults to FRIENDS<br/>",
              "!type": "fn(string) -> !this"
            },
            setCount: {
              "!doc": "The number of challenges to return (MAX=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setEligibility: {
              "!doc": "Optional.  Allows the current player's eligibility to be overridden by what is provided here.<br/>",
              "!type": "fn(?) -> !this"
            },
            setOffset: {
              "!doc": "The offset to start from when returning challenges (used for paging)<br/>",
              "!type": "fn(number) -> !this"
            },
            setShortCode: {
              "!doc": "Optional shortCodes to filter the results by challenge type<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.FindChallengeResponse))"
            }
          }
        },
        FindPendingMatchesRequest: {
          "!doc": "Find other pending matches that will match this player's previously submitted MatchmakingRequest.<br/>Used for manual matching of players, where you want control over which pending match should be chosen.<br/>Each player must match the other for the pending match to be found.<br/>",
          prototype: {
            setMatchGroup: {
              "!doc": "Optional. The matchGroup of the match this player previously registeredfor<br/>",
              "!type": "fn(string) -> !this"
            },
            setMatchShortCode: {
              "!doc": "The shortCode of the match this player previously registered for<br/>",
              "!type": "fn(string) -> !this"
            },
            setMaxMatchesToFind: {
              "!doc": "Optional. The maximum number of pending matches to return (default=10)<br/>",
              "!type": "fn(number) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.FindPendingMatchesResponse))"
            }
          }
        },
        GameCenterConnectRequest: {
          "!doc": "Allows an Apple account that has GameCenter to be used as an authentication mechanism.<br/>The request must supply the GameCenter user details, such as the player id and username.<br/>If the GameCenter user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the GameCenter user is not already registered with the game, the GameCenter user will be linked to the current player.<br/>If the current player has not authenticated and the GameCenter user is not known, a new player will be created using the GameCenter details and the session will be authenticated against the new player.<br/>If the GameCenter user is already known, the session will switch to being the previously created user.<br/>This API call requires the output details from GKLocalPlayer.generateIdentityVerificationSignatureWithCompletionHandler on your iOS device<br/>",
          prototype: {
            setDisplayName: {
              "!doc": "The display of the current player from GameCenter. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setExternalPlayerId: {
              "!doc": "The game center id of the current player. This value obtained be obtained from GKLocalPlayer playerID<br/>",
              "!type": "fn(string) -> !this"
            },
            setPublicKeyUrl: {
              "!doc": "The url from where we will download the public key. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler. <br/>",
              "!type": "fn(string) -> !this"
            },
            setSalt: {
              "!doc": "The salt is needed in order to prevent request forgery. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler and should be base64 encoded using [salt base64Encoding]<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSignature: {
              "!doc": "The signature is needed to validate that the request is genuine and that we can save the player. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler and should be base64 encoded using [signature base64Encoding]<br/>",
              "!type": "fn(string) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTimestamp: {
              "!doc": "The timestamp is needed to validate the request signature. This value should be obtained from generateIdentityVerificationSignatureWithCompletionHandler<br/>",
              "!type": "fn(number) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        GetChallengeRequest: {
          "!doc": "Gets the details of a challenge. The current player must be involved in the challenge for the request to succeed.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The ID of the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setMessage: {
              "!doc": "An optional message to send with the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetChallengeResponse))"
            }
          }
        },
        GetDownloadableRequest: {
          "!doc": "Returns a secure, time sensitive url to allow the game to download a piece of downloadable content stored in the GameSparks platform.<br/>",
          prototype: {
            setShortCode: {
              "!doc": "The short code of the Downloadable item<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetDownloadableResponse))"
            }
          }
        },
        GetLeaderboardEntriesRequest: {
          "!doc": "Get the leaderboard entry data for the current player or a given player.<br/>For each leaderboard it returns the hichest score the player has<br/>",
          prototype: {
            setChallenges: {
              "!doc": "The challenge leaderboards to return entries for<br/>",
              "!type": "fn([string]) -> !this"
            },
            setInverseSocial: {
              "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setLeaderboards: {
              "!doc": "The list of leaderboards shortcodes<br/>",
              "!type": "fn([string]) -> !this"
            },
            setPlayer: {
              "!doc": "The player id. Leave out to use the current player id<br/>",
              "!type": "fn(string) -> !this"
            },
            setSocial: {
              "!doc": "Set to true to include the player's game friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTeamTypes: {
              "!doc": "The types of team to apply this request to<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetLeaderboardEntriesResponse))"
            }
          }
        },
        GetMessageRequest: {
          "!doc": "Returns the full details of a message.<br/>",
          prototype: {
            setMessageId: {
              "!doc": "The messageId of the message retreive<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetMessageResponse))"
            }
          }
        },
        GetMyTeamsRequest: {
          "!doc": "Get the teams that the player is in. Can be filtered on team type and also on those teams that the player owns.<br/>",
          prototype: {
            setOwnedOnly: {
              "!doc": "Set to true to only get teams owned by the player<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTeamTypes: {
              "!doc": "The type of teams to get<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetMyTeamsResponse))"
            }
          }
        },
        GetPropertyRequest: {
          "!doc": "Get the property for the given short Code.<br/>",
          prototype: {
            setPropertyShortCode: {
              "!doc": "The shortCode of the property to return.<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetPropertyResponse))"
            }
          }
        },
        GetPropertySetRequest: {
          "!doc": "Get the property set for the given short Code.<br/>",
          prototype: {
            setPropertySetShortCode: {
              "!doc": "The shortCode of the property set to return.<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetPropertySetResponse))"
            }
          }
        },
        GetTeamRequest: {
          "!doc": "Allows the details of a team to be retrieved.<br/>",
          prototype: {
            setOwnerId: {
              "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamId: {
              "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamType: {
              "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetTeamResponse))"
            }
          }
        },
        GetUploadUrlRequest: {
          "!doc": "Returns a secure, time sensitive URL to allow the game to upload a piece of player content to the GameSparks platform.<br/>",
          prototype: {
            setUploadData: {
              "!doc": "Optional meta data which is stored against the player's uploaded content<br/>",
              "!type": "fn([?]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetUploadUrlResponse))"
            }
          }
        },
        GetUploadedRequest: {
          "!doc": "Returns a secure, time sensitive URL to a piece of content that was previously uploaded to the GameSparks platform by a player.<br/>",
          prototype: {
            setUploadId: {
              "!doc": "The system generated id of the uploaded item<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.GetUploadedResponse))"
            }
          }
        },
        GooglePlayBuyGoodsRequest: {
          "!doc": "Processes the response from a Google Play in app purchase flow.<br/>The GameSparks platform will validate the signature and signed data with the Google Play Public Key configured against the game.<br/>The orderId in the data will be recorded and the request will be rejected if the orderId has previously been processed, this prevents replay attacks.<br/>Once verfied, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the signed data with the 'Google Product ID' configured against the virtual good.<br/>It is critical that the signedData is sent exactly as it is returned form google, including any whitespace. Any modification of the signedData will cause the verification process to fail.<br/>",
          prototype: {
            setCurrencyCode: {
              "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
              "!type": "fn(string) -> !this"
            },
            setSignature: {
              "!doc": 'The value obtained from data.getStringExtra("INAPP_DATA_SIGNATURE");<br/>',
              "!type": "fn(string) -> !this"
            },
            setSignedData: {
              "!doc": 'The value obtained from data.getStringExtra("INAPP_PURCHASE_DATA")<br/>',
              "!type": "fn(string) -> !this"
            },
            setSubUnitPrice: {
              "!doc": "The price of this purchase<br/>",
              "!type": "fn(number) -> !this"
            },
            setUniqueTransactionByPlayer: {
              "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BuyVirtualGoodResponse))"
            }
          }
        },
        GooglePlayConnectRequest: {
          "!doc": "Allows either a Google Play access code or an access token to be used as an authentication mechanism.<br/>The access code needs to have at least the https://www.googleapis.com/auth/games scope.<br/>For more details about Google OAuth 2.0 scopes refer to this: https://developers.google.com/identity/protocols/googlescopes#gamesConfigurationv1configuration<br/>If the Google Play user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Google Play user is not already registered with the game, the Google Play user will be linked to the current player.<br/>If the current player has not authenticated and the Google Play user is not known, a new player will be created using the Google Play details and the session will be authenticated against the new player.<br/>If the Google Play user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The access token is used when using the service id and certificate.<br/>",
              "!type": "fn(string) -> !this"
            },
            setCode: {
              "!doc": "The access code is used by the client to make authenticated requests on behalf of the end user. Requires clientId and clientsecret to be set<br/>",
              "!type": "fn(string) -> !this"
            },
            setDisplayName: {
              "!doc": "The display of the current player from Google Play. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setGooglePlusScope: {
              "!doc": "Did you request the plus.login scope when you got the access code or authorisation token from Google? If this is true, we will fetch the user's google+ account and friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setProfileScope: {
              "!doc": "Did you request the profile scope when you got the access code or authorisation token from Google? If this is true, we will fetch the user info by calling https://www.googleapis.com/oauth2/v1/userinfo?alt=json <br/>",
              "!type": "fn(bool) -> !this"
            },
            setRedirectUri: {
              "!doc": "Only required when the access code has been granted using an explicit redirectUri, for example when using the mechanism described in https://developers.google.com/+/web/signin/server-side-flow<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        GooglePlusConnectRequest: {
          "!doc": "Allows either a Google Plus access code or an authentication token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Google Plus platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Google Plus user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Google Plus user is not already registered with the game, the Google Plus user will be linked to the current player.<br/>If the current player has not authenticated and the Google Plus user is not known, a new player will be created using the Google Plus details and the session will be authenticated against the new player.<br/>If the Google Plus user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The access token is used when using the service id and certificate.<br/>",
              "!type": "fn(string) -> !this"
            },
            setCode: {
              "!doc": "The access code is used by the client to make authenticated requests on behalf of the end user. Requires clientId and clientsecret to be set<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setRedirectUri: {
              "!doc": "Only required when the access code has been granted using an explicit redirectUri, for example when using the mechanism described in https://developers.google.com/+/web/signin/server-side-flow<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        IOSBuyGoodsRequest: {
          "!doc": "Processes a transaction receipt from an App Store in app purchase.<br/>The GameSparks platform will validate the receipt with Apple and process the response. The transaction_id in the response will be recorded and the request will be rejected if the transaction_id has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the product_id in the response with the 'IOS Product ID' configured against the virtual good.<br/>",
          prototype: {
            setCurrencyCode: {
              "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
              "!type": "fn(string) -> !this"
            },
            setReceipt: {
              "!doc": "The receipt obtained from SKPaymentTransaction. transactionReceipt<br/>",
              "!type": "fn(string) -> !this"
            },
            setSandbox: {
              "!doc": "Should the sandbox account be used<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSubUnitPrice: {
              "!doc": "The price of this purchase<br/>",
              "!type": "fn(number) -> !this"
            },
            setUniqueTransactionByPlayer: {
              "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BuyVirtualGoodResponse))"
            }
          }
        },
        JoinChallengeRequest: {
          "!doc": "Allows a player to join an open challenge.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The ID of the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setEligibility: {
              "!doc": "Optional.  Allows the current player's eligibility to be overridden by what is provided here.<br/>",
              "!type": "fn(?) -> !this"
            },
            setMessage: {
              "!doc": "An optional message to send with the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.JoinChallengeResponse))"
            }
          }
        },
        JoinPendingMatchRequest: {
          "!doc": "Requests to join a pending match (found via FindPendingMatchesRequest).<br/>",
          prototype: {
            setMatchGroup: {
              "!doc": "Optional. The matchGroup of the match this player previously registeredfor<br/>",
              "!type": "fn(string) -> !this"
            },
            setMatchShortCode: {
              "!doc": "The shortCode of the match this player previously registered for<br/>",
              "!type": "fn(string) -> !this"
            },
            setPendingMatchId: {
              "!doc": "The pending match ID to join<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.JoinPendingMatchResponse))"
            }
          }
        },
        JoinTeamRequest: {
          "!doc": "Allows a player to join a team or a team to be retrieved.<br/>",
          prototype: {
            setOwnerId: {
              "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamId: {
              "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamType: {
              "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.JoinTeamResponse))"
            }
          }
        },
        KongregateConnectRequest: {
          "!doc": "Allows a Kongregate account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Kongregate platform and store them within GameSparks.<br/>If the Kongregate user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Kongregate user is not already registered with the game, the Kongregate user will be linked to the current player.<br/>If the current player has not authenticated and the Kongregate user is not known, a new player will be created using the Kongregate details and the session will be authenticated against the new player.<br/>If the Kongregate user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setGameAuthToken: {
              "!doc": "The gameAuthToken, together with the userID are used by the client to make authenticated requests on behalf of the end user.<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setUserId: {
              "!doc": "The userID, together with the gameAuthToken are used by the client to make authenticated requests on behalf of the end user.<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        LeaderboardDataRequest: {
          "!doc": "Returns the top data for either the specified global leaderboard or the specified challenges leaderboard. The data is sorted as defined in the rules specified in the leaderboard configuration.<br/>The response contains the top of the leaderboard, and returns the number of entries as defined in the entryCount parameter.<br/>If a shortCode is supplied, the response will contain the global leaderboard data. If a challengeInstanceId is supplied, the response will contain the leaderboard data for the challenge.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The challenge instance to get the leaderboard data for<br/>",
              "!type": "fn(string) -> !this"
            },
            setDontErrorOnNotSocial: {
              "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setFriendIds: {
              "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
              "!type": "fn([string]) -> !this"
            },
            setIncludeFirst: {
              "!doc": "Number of entries to include from head of the list<br/>",
              "!type": "fn(number) -> !this"
            },
            setIncludeLast: {
              "!doc": "Number of entries to include from tail of the list<br/>",
              "!type": "fn(number) -> !this"
            },
            setInverseSocial: {
              "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setLeaderboardShortCode: {
              "!doc": "The short code of the leaderboard<br/>",
              "!type": "fn(string) -> !this"
            },
            setOffset: {
              "!doc": "The offset into the set of leaderboards returned<br/>",
              "!type": "fn(number) -> !this"
            },
            setSocial: {
              "!doc": "If True returns a leaderboard of the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTeamIds: {
              "!doc": "The IDs of the teams you are interested in<br/>",
              "!type": "fn([string]) -> !this"
            },
            setTeamTypes: {
              "!doc": "The type of team you are interested in<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.LeaderboardDataResponse))"
            }
          }
        },
        LeaderboardsEntriesRequest: {
          "!doc": "Get the leaderboard entry data for the current player or a given player.<br/>For each leaderboard it returns the array of leaderboard entries that the player has.<br/>",
          prototype: {
            setChallenges: {
              "!doc": "The challenge leaderboards to return entries for<br/>",
              "!type": "fn([string]) -> !this"
            },
            setInverseSocial: {
              "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setLeaderboards: {
              "!doc": "The list of leaderboards shortcodes<br/>",
              "!type": "fn([string]) -> !this"
            },
            setPlayer: {
              "!doc": "The player id. Leave out to use the current player id<br/>",
              "!type": "fn(string) -> !this"
            },
            setSocial: {
              "!doc": "Set to true to include the player's game friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTeamTypes: {
              "!doc": "The types of team to apply this request to<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.LeaderboardsEntriesResponse))"
            }
          }
        },
        LeaveTeamRequest: {
          "!doc": "Allows a player to leave a team.<br/>",
          prototype: {
            setOwnerId: {
              "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamId: {
              "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamType: {
              "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.LeaveTeamResponse))"
            }
          }
        },
        ListAchievementsRequest: {
          "!doc": "Retrieves a list of the configured achievements in the game, along with whether the current player has earned the achievement.<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListAchievementsResponse))"
            }
          }
        },
        ListBulkJobsAdminRequest: {
          "!doc": "Lists existing bulk jobs.<br/>",
          prototype: {
            setBulkJobIds: {
              "!doc": "The IDs of existing bulk jobs to get details for<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListBulkJobsAdminResponse))"
            }
          }
        },
        ListChallengeRequest: {
          "!doc": "Returns a list of challenges in the state defined in the 'state' field.<br/>The response can be further filtered by passing a shortCode field which will limit the returned lists to challenges of that short code.<br/>Valid states are:<br/>WAITING : The challenge has been issued and accepted and is waiting for the start date.<br/>RUNNING : The challenge is active.<br/>ISSUED : The challenge has been issued by the current player and is waiting to be accepted.<br/>RECEIVED : The challenge has been issued to the current player and is waiting to be accepted.<br/>COMPLETE : The challenge has completed.<br/>DECLINED : The challenge has been issued by the current player and has been declined.<br/>",
          prototype: {
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setOffset: {
              "!doc": "The offset (page number) to start from (default=0)<br/>",
              "!type": "fn(number) -> !this"
            },
            setShortCode: {
              "!doc": "The type of challenge to return<br/>",
              "!type": "fn(string) -> !this"
            },
            setState: {
              "!doc": "The state of the challenged to be returned<br/>",
              "!type": "fn(string) -> !this"
            },
            setStates: {
              "!doc": "The states of the challenges to be returned<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListChallengeResponse))"
            }
          }
        },
        ListChallengeTypeRequest: {
          "!doc": "Returns the list of configured challenge types.<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListChallengeTypeResponse))"
            }
          }
        },
        ListGameFriendsRequest: {
          "!doc": "Returns the list of the current players game friends.<br/>A Game friend is someone in their social network who also plays the game.<br/>Against each friend, an indicator is supplied to show whether the friend is currently connected to the GameSparks service<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListGameFriendsResponse))"
            }
          }
        },
        ListInviteFriendsRequest: {
          "!doc": "Returns the list of the current players friends in their social network, who are not yet playing this game.<br/>This is dependent on the security and privacy policies of the social network.<br/>For example, Facebook's policies prevent this friend list being provided, whereas Twitter will supply a list of users who are not playing the game.<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListInviteFriendsResponse))"
            }
          }
        },
        ListLeaderboardsRequest: {
          "!doc": "Returns a list of all leaderboards configured in the game.<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListLeaderboardsResponse))"
            }
          }
        },
        ListMessageDetailRequest: {
          "!doc": "Returns the list of the current player's messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest Read the section on Messages to see the complete list of messages and their meaning.<br/>",
          prototype: {
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setInclude: {
              "!doc": "An optional filter that limits the message types returned<br/>",
              "!type": "fn(string) -> !this"
            },
            setOffset: {
              "!doc": "The offset (page number) to start from (default=0)<br/>",
              "!type": "fn(number) -> !this"
            },
            setStatus: {
              "!doc": "The status of messages to be retrieved. If omitted, messages of all statuses will be retrieved<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListMessageDetailResponse))"
            }
          }
        },
        ListMessageRequest: {
          "!doc": "Returns the list of the current player's messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest Read the section on Messages to see the complete list of messages and their meaning.<br/>",
          prototype: {
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setInclude: {
              "!doc": "An optional filter that limits the message types returned<br/>",
              "!type": "fn(string) -> !this"
            },
            setOffset: {
              "!doc": "The offset (page number) to start from (default=0)<br/>",
              "!type": "fn(number) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListMessageResponse))"
            }
          }
        },
        ListMessageSummaryRequest: {
          "!doc": "Returns a summary of the list of the current players messages / notifications.<br/>The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest.<br/>The full message can be retrieved using GetMessageRequest Read the section on Messages to see the complete list of messages and their meanings.<br/>",
          prototype: {
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setOffset: {
              "!doc": "The offset (page number) to start from (default=0)<br/>",
              "!type": "fn(number) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListMessageSummaryResponse))"
            }
          }
        },
        ListTeamChatRequest: {
          "!doc": "Get a list of the messages sent to the team (by players using SendTeamChatMessageRequest).<br/>",
          prototype: {
            setEntryCount: {
              "!doc": "The number of messages to return (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setOffset: {
              "!doc": "The offset (nth message) to start from (default=0)<br/>",
              "!type": "fn(number) -> !this"
            },
            setOwnerId: {
              "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamId: {
              "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamType: {
              "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListTeamChatResponse))"
            }
          }
        },
        ListTeamsRequest: {
          "!doc": "Returns a list of teams. Can be filtered on team name or team type.<br/>",
          prototype: {
            setEntryCount: {
              "!doc": "The number of teams to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setOffset: {
              "!doc": "The offset (page number) to start from (default=0)<br/>",
              "!type": "fn(number) -> !this"
            },
            setTeamNameFilter: {
              "!doc": "An optional filter to return teams with a matching name<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamTypeFilter: {
              "!doc": "An optional filter to return teams of a particular type<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListTeamsResponse))"
            }
          }
        },
        ListTransactionsRequest: {
          "!doc": "Returns a list of the current player's transaction history.<br/>",
          prototype: {
            setDateFrom: {
              "!doc": "Optional date constraint to list transactions from<br/>",
              "!type": "fn(date) -> !this"
            },
            setDateTo: {
              "!doc": "Optional date constraint to list transactions to<br/>",
              "!type": "fn(date) -> !this"
            },
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setInclude: {
              "!doc": "An optional filter that limits the transaction types returned<br/>",
              "!type": "fn(string) -> !this"
            },
            setOffset: {
              "!doc": "The offset (page number) to start from (default=0)<br/>",
              "!type": "fn(number) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListTransactionsResponse))"
            }
          }
        },
        ListVirtualGoodsRequest: {
          "!doc": "Returns the list of configured virtual goods.<br/>",
          prototype: {
            setIncludeDisabled: {
              "!doc": "If true, the returned list will include disabled VirtualVoods<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTags: {
              "!doc": "A filter to only include goods with the given tags. Each good must have all the provided tags.<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ListVirtualGoodsResponse))"
            }
          }
        },
        LogChallengeEventRequest: {
          "!doc": "Allows a user defined event to be triggered. The event will be posted to the challenge specified.<br/>This call differs from most as it does not have a fixed format. The @class, challengeInstanceId and eventKey attributes are common, but the rest of the attributes are as defined in the Event object configured in the dev portal.<br/>The example below shows a request to en event with a short code of HS with 2 attributes, 'HS' & 'GL'.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The ID challenge instance to target<br/>",
              "!type": "fn(string) -> !this"
            },
            setEventKey: {
              "!doc": "The short code of the event to trigger<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.LogChallengeEventResponse))"
            }
          }
        },
        LogEventRequest: {
          "!doc": "Allows a user defined event to be triggered.<br/>This call differs from most as it does not have a fixed format. The @class and eventKey attributes are common, but the rest of the attributes are as defined in the Event object configured in the dev portal.<br/>The example below shows a request to an event with a short code of HS with 2 attributes, 'HS' & 'GL'.<br/>",
          prototype: {
            setEventKey: {
              "!doc": "The short code of the event to trigger<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.LogEventResponse))"
            }
          }
        },
        MatchDetailsRequest: {
          "!doc": "Find the details of an existing match this player belongs to, using the matchId<br/>",
          prototype: {
            setMatchId: {
              "!doc": "The matchId to find the details of<br/>",
              "!type": "fn(string) -> !this"
            },
            setRealtimeEnabled: {
              "!doc": "Adds realtime server details if the match has been created using Cloud Code and it has not been realtime enabled<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.MatchDetailsResponse))"
            }
          }
        },
        MatchmakingRequest: {
          "!doc": "Register this player for matchmaking, using the given skill and matchShortCode.<br/>Players looking for a match using the same matchShortCode will be considered for a match, based on the matchConfig.<br/>Each player must match the other for the match to be found.<br/>If the matchShortCode points to a match with realtime enabled, in order to minimise latency, the location of Players and their proximity to one another takes precedence over their reciprocal skill values.<br/>",
          prototype: {
            setAction: {
              "!doc": "The action to take on the already in-flight request for this match. Currently supported actions are: 'cancel'<br/>",
              "!type": "fn(string) -> !this"
            },
            setCustomQuery: {
              "!doc": "The query that will be applied to the PendingMatch collection<br/>",
              "!type": "fn(?) -> !this"
            },
            setMatchData: {
              "!doc": "A JSON Map of any data that will be associated to the pending match<br/>",
              "!type": "fn(?) -> !this"
            },
            setMatchGroup: {
              "!doc": "Optional. Players will be grouped based on the distinct value passed in here, only players in the same group can be matched together<br/>",
              "!type": "fn(string) -> !this"
            },
            setMatchShortCode: {
              "!doc": "The shortCode of the match type this player is registering for<br/>",
              "!type": "fn(string) -> !this"
            },
            setParticipantData: {
              "!doc": "A JSON Map of any data that will be associated to this user in a pending match<br/>",
              "!type": "fn(?) -> !this"
            },
            setSkill: {
              "!doc": "The skill of the player looking for a match<br/>",
              "!type": "fn(number) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.MatchmakingResponse))"
            }
          }
        },
        NXConnectRequest: {
          "!doc": "Allows an Nintendo Network Service Account (NSA) to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the NSA and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the NSA is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the NSA is not already registered with the game, the NSA will be linked to the current player.<br/>If the current player has not authenticated and the NSA is not known, a new player will be created using the NSA details and the session will be authenticated against the new player.<br/>If the NSA is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccountPerLoginId: {
              "!doc": "Whether to create one GameSparks player per console login ID<br/>",
              "!type": "fn(bool) -> !this"
            },
            setDisplayName: {
              "!doc": "The display name of the current player from NX. This will be used as the displayName of the gamesparks player if created (or syncDisplayname is true)<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setNsaIdToken: {
              "!doc": "The NSA ID token obtained from Nintendo<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        PSNConnectRequest: {
          "!doc": "Allows a PSN account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the PSN platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the PSN user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the PSN user is not already registered with the game, the PSN user will be linked to the current player.<br/>If the current player has not authenticated and the PSN user is not known, a new player will be created using the PSN details and the session will be authenticated against the new player.<br/>If the PSN user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAuthorizationCode: {
              "!doc": "The authorization code obtained from PSN, as described here https://ps4.scedev.net/resources/documents/SDK/latest/NpAuth-Reference/0008.html<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setRedirectUri: {
              "!doc": "When using the authorization code obtained from PlayStation4/PlayStationVita/PlayStation3, this is not required.<br/>When using the authorization code obtained with the PC authentication gateway, set the URI issued from the Developer Network website.<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        PsnBuyGoodsRequest: {
          "!doc": "Processes an update of entitlement in PlayStation network.<br/>The GameSparks platform will update the 'use_count' for an entitlement (by default 'use_count' is 1).<br/>The request will be rejected if entitlement 'use_limit' is 0<br/>GampSparks platform by default will use internally saved PSN user access token<br/>",
          prototype: {
            setAuthorizationCode: {
              "!doc": "The authorization code obtained from PSN, as described here https://ps4.scedev.net/resources/documents/SDK/latest/NpAuth-Reference/0008.html<br/>",
              "!type": "fn(string) -> !this"
            },
            setCurrencyCode: {
              "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
              "!type": "fn(string) -> !this"
            },
            setEntitlementLabel: {
              "!doc": "Specify the entitlement label of the entitlement to update. (Not an entitlement ID).<br/>",
              "!type": "fn(string) -> !this"
            },
            setRedirectUri: {
              "!doc": "When using the authorization code obtained from PlayStation4/PlayStationVita/PlayStation3, this is not required.<br/>When using the authorization code obtained with the PC authentication gateway, set the URI issued from the Developer Network website.<br/>",
              "!type": "fn(string) -> !this"
            },
            setSubUnitPrice: {
              "!doc": "The price of this purchase<br/>",
              "!type": "fn(number) -> !this"
            },
            setUniqueTransactionByPlayer: {
              "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setUseCount: {
              "!doc": "Optional - specify the quantity of the entitlement to use. Default = 1<br/>",
              "!type": "fn(number) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BuyVirtualGoodResponse))"
            }
          }
        },
        PushRegistrationRequest: {
          "!doc": "Registers the current device for push notifications. Currently GameSparks supports iOS, Android (GCM), FCM, Kindle, Viber & Microsoft Push notifications.<br/>Supply the device type, and the push notification identifier for the device.<br/>",
          prototype: {
            setDeviceOS: {
              "!doc": "The type of id, valid values are ios, android, fcm, wp8, w8, kindle or viber<br/>",
              "!type": "fn(string) -> !this"
            },
            setPushId: {
              "!doc": "The push notification identifier for the device<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.PushRegistrationResponse))"
            }
          }
        },
        QQConnectRequest: {
          "!doc": "Allows a QQ access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the QQ platform and store them within GameSparks.<br/>If the QQ user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the QQ user is not already registered with the game, the QQ user will be linked to the current player.<br/>If the current player has not authenticated and the QQ user is not known, a new player will be created using the QQ details and the session will be authenticated against the new player.<br/>If the QQ user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained using the refresh token.<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        RegistrationRequest: {
          "!doc": "Allows a new player to be created using a username, password display name.<br/>",
          prototype: {
            setDisplayName: {
              "!doc": "A display name to use<br/>",
              "!type": "fn(string) -> !this"
            },
            setPassword: {
              "!doc": "The previously registered password<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setUserName: {
              "!doc": "The previously registered player name<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.RegistrationResponse))"
            }
          }
        },
        RevokePurchaseGoodsRequest: {
          "!doc": "Revokes the purchase of a good. The items aquired will be removed from remaining items of the player.<br/>",
          prototype: {
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            setStoreType: {
              "!doc": "The store type for which to revoke these transactions<br/>",
              "!type": "fn(string) -> !this"
            },
            setTransactionIds: {
              "!doc": "The list of transactionIds to revoke<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.RevokePurchaseGoodsResponse))"
            }
          }
        },
        ScheduleBulkJobAdminRequest: {
          "!doc": "Schedules a bulk job to be run against multiple players.<br/>",
          prototype: {
            setData: {
              "!doc": "Optional data to be passed into the script<br/>",
              "!type": "fn(RTSession.newRequest.DBObject) -> !this"
            },
            setModuleShortCode: {
              "!doc": "The short code of the cloud code module to be executed against each player<br/>",
              "!type": "fn(string) -> !this"
            },
            setPlayerQuery: {
              "!doc": "The query to be run against the player collection to identify which players to execute the cloud code for<br/>",
              "!type": "fn(RTSession.newRequest.DBObject) -> !this"
            },
            setScheduledTime: {
              "!doc": "An optional date and time for this job to be run<br/>",
              "!type": "fn(date) -> !this"
            },
            setScript: {
              "!doc": "The script to be executed against each player<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.ScheduleBulkJobAdminResponse))"
            }
          }
        },
        SendFriendMessageRequest: {
          "!doc": "Sends a message to one or more game friend(s). A game friend is someone in the players social network who also plays the game.<br/>",
          prototype: {
            setFriendIds: {
              "!doc": "One or more friend ID's. This can be supplied as a single string, or a JSON array<br/>",
              "!type": "fn([string]) -> !this"
            },
            setMessage: {
              "!doc": "The message to send<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.SendFriendMessageResponse))"
            }
          }
        },
        SendTeamChatMessageRequest: {
          "!doc": "Send a message to all the players who are member of the given team<br/>",
          prototype: {
            setMessage: {
              "!doc": "The message to send<br/>",
              "!type": "fn(string) -> !this"
            },
            setOwnerId: {
              "!doc": "The team owner to find, used in combination with teamType. If not supplied the current players id will be used<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamId: {
              "!doc": "The teamId to find (may be null if teamType supplied)<br/>",
              "!type": "fn(string) -> !this"
            },
            setTeamType: {
              "!doc": "The teamType to find, used in combination with the current player, or the player defined by ownerId<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.SendTeamChatMessageResponse))"
            }
          }
        },
        SocialDisconnectRequest: {
          "!doc": "Allows a player's internal profile to be disconnected from an external system to which it is linked. Any friends linked as result of this connection will be removed.<br/>",
          prototype: {
            setSystemId: {
              "!doc": "The external system from which to disconnect this profile, supplied as a two letter ID. The options are: {FACEBOOK:FB, AMAZON:AM, GAME_CENTER:GC<br/>GOOGLE_PLAY:GY , GOOGLE_PLUS:GP, KONGREGATE:KO, PSN:PS, QQ:QQ, STEAM:ST, TWITCH:TC, TWITTER:TW, VIBER:VB, WECHAT:WC, XBOX:XB<br/>XBOXONE:X1, NINTENDO:NX}<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.SocialDisconnectResponse))"
            }
          }
        },
        SocialLeaderboardDataRequest: {
          "!doc": "Returns leaderboard data that only contains entries of players that are game friends with the current player.<br/>The GameSparks platform will attempt to return players both ahead and behind the current player, where data is available.<br/>The entry count defines how many player should be returned both ahead and behind. The numer of results may vary if there are not enough friends either ahead or behind.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The challenge instance to get the leaderboard data for<br/>",
              "!type": "fn(string) -> !this"
            },
            setDontErrorOnNotSocial: {
              "!doc": "The default behaviour on a social request is to error if the player has no friends (NOTSOCIAL).  Set this flag to suppress that error and return the player's leaderboard entry instead.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setEntryCount: {
              "!doc": "The number of items to return in a page (default=50)<br/>",
              "!type": "fn(number) -> !this"
            },
            setFriendIds: {
              "!doc": "A friend id or an array of friend ids to use instead of the player's social friends<br/>",
              "!type": "fn([string]) -> !this"
            },
            setIncludeFirst: {
              "!doc": "Number of entries to include from head of the list<br/>",
              "!type": "fn(number) -> !this"
            },
            setIncludeLast: {
              "!doc": "Number of entries to include from tail of the list<br/>",
              "!type": "fn(number) -> !this"
            },
            setInverseSocial: {
              "!doc": "Returns the leaderboard excluding the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setLeaderboardShortCode: {
              "!doc": "The short code of the leaderboard<br/>",
              "!type": "fn(string) -> !this"
            },
            setOffset: {
              "!doc": "The offset into the set of leaderboards returned<br/>",
              "!type": "fn(number) -> !this"
            },
            setSocial: {
              "!doc": "If True returns a leaderboard of the player's social friends<br/>",
              "!type": "fn(bool) -> !this"
            },
            setTeamIds: {
              "!doc": "The IDs of the teams you are interested in<br/>",
              "!type": "fn([string]) -> !this"
            },
            setTeamTypes: {
              "!doc": "The type of team you are interested in<br/>",
              "!type": "fn([string]) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.LeaderboardDataResponse))"
            }
          }
        },
        SocialStatusRequest: {
          "!doc": "Returns detials of the current social connections of this player. Each connection .<br/>",
          prototype: {
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.SocialStatusResponse))"
            }
          }
        },
        SteamBuyGoodsRequest: {
          "!doc": "Processes a 'orderid' from a Steam.<br/>The GameSparks platform will validate the 'orderid' with Steam and process the response. The 'orderid' from the response will be recorded and the request will be rejected, if the 'orderid' has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the 'itemid' in the response with the 'Steam Product ID' configured against the virtual good.<br/>",
          prototype: {
            setCurrencyCode: {
              "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
              "!type": "fn(string) -> !this"
            },
            setOrderId: {
              "!doc": "Unique 64-bit ID for order<br/>",
              "!type": "fn(string) -> !this"
            },
            setSubUnitPrice: {
              "!doc": "The price of this purchase<br/>",
              "!type": "fn(number) -> !this"
            },
            setUniqueTransactionByPlayer: {
              "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BuyVirtualGoodResponse))"
            }
          }
        },
        SteamConnectRequest: {
          "!doc": "Allows a Steam sessionTicket to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Steam platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Steam user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Steam user is not already registered with the game, the Steam user will be linked to the current player.<br/>If the current player has not authenticated and the Steam user is not known, a new player will be created using the Steam details and the session will be authenticated against the new player.<br/>If the Steam user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSessionTicket: {
              "!doc": "The hex encoded UTF-8 string representation of the ticket acquired calling the Steam SDKs GetAuthSessionTicket.<br/>",
              "!type": "fn(string) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        TwitchConnectRequest: {
          "!doc": "Allows a Twitch account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Twitch platform and store them within GameSparks.<br/>If the Twitch user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Twitch user is not already registered with the game, the Twitch user will be linked to the current player.<br/>If the current player has not authenticated and the Twitch user is not known, a new player will be created using the Twitch details and the session will be authenticated against the new player.<br/>If the Twitch user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        TwitterConnectRequest: {
          "!doc": "Allows a Twitter account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Twitter platform and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Twitter user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Twitter user is not already registered with the game, the Twitter user will be linked to the current player.<br/>If the current player has not authenticated and the Twitter user is not known, a new player will be created using the Twitter details and the session will be authenticated against the new player.<br/>If the Twitter user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessSecret: {
              "!doc": "The accessSecret is obtained at the same time as the accessToken, and is required to sign requests to Twitter's services that require the accessToken.<br/>",
              "!type": "fn(string) -> !this"
            },
            setAccessToken: {
              "!doc": "The accessToken represents a player's permission to share access to their account with your application.<br/>To obtain an accessToken for the player see https://dev.twitter.com/docs/auth/obtaining-access-tokens.<br/>Currently, Twitter accessTokens do not expire but they can be revoked by the player.<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        UpdateMessageRequest: {
          "!doc": "Allows a message status to be updated.<br/>",
          prototype: {
            setMessageId: {
              "!doc": "The messageId of the message to update<br/>",
              "!type": "fn(string) -> !this"
            },
            setStatus: {
              "!doc": "The status to set on the message<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.UpdateMessageResponse))"
            }
          }
        },
        ViberConnectRequest: {
          "!doc": "Allows a Viber account to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Viber platform and store them within GameSparks.<br/>A successful authentication will also register the player to receive Viber push notifications.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Viber user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Viber user is not already registered with the game, the Viber user will be linked to the current player.<br/>If the current player has not authenticated and the Viber user is not known, a new player will be created using the Viber details and the session will be authenticated against the new player.<br/>If the Viber user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The accessToken represents a player's permission to share access to their account with your application.<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setDoNotRegisterForPush: {
              "!doc": "Does not automatocally register this user for push notifications. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        WeChatConnectRequest: {
          "!doc": "Allows a WeChat access token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the WeChat platform and store them within GameSparks.<br/>If the WeChat user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthenticationRequest or RegistrationRequest AND the WeChat user is not already registered with the game, the WeChat user will be linked to the current player.<br/>If the current player has not authenticated and the WeChat user is not known, a new player will be created using the WeChat details and the session will be authenticated against the new player.<br/>If the WeChat user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setAccessToken: {
              "!doc": "The access token sould be obtained from WeChat<br/>It is used by the client to make authenticated requests on behalf of the end user.<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setOpenId: {
              "!doc": "The open ID corresponding to the WeChat user<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        WindowsBuyGoodsRequest: {
          "!doc": "Processes a transaction receipt from a windows store purchase.<br/>The GameSparks platform will validate the receipt using the signature embedded in the xml. The Id in the xml will be recorded and the request will be rejected if the Id has previously been processed, this prevents replay attacks.<br/>Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up by matching the productId in the xml with the 'WP8 Product ID' configured against the virtual good.<br/>",
          prototype: {
            setCurrencyCode: {
              "!doc": "The ISO 4217 currency code representing the real-world currency used for this transaction.<br/>",
              "!type": "fn(string) -> !this"
            },
            setPlatform: {
              "!doc": "Allows you to specify the platform<br/>",
              "!type": "fn(string) -> !this"
            },
            setReceipt: {
              "!doc": "The xml reciept returned from the windows phone 8 store<br/>",
              "!type": "fn(string) -> !this"
            },
            setSubUnitPrice: {
              "!doc": "The price of this purchase<br/>",
              "!type": "fn(number) -> !this"
            },
            setUniqueTransactionByPlayer: {
              "!doc": "If set to true, the transactionId from this receipt will not be globally valdidated, this will mean replays between players are possible.<br/>It will only validate the transactionId has not been used by this player before.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.BuyVirtualGoodResponse))"
            }
          }
        },
        WithdrawChallengeRequest: {
          "!doc": "Withdraws a challenge previously issued by the current player.<br/>This can only be done while the challenge is in the ISSUED state. Once it's been accepted the challenge can not be withdrawn.<br/>",
          prototype: {
            setChallengeInstanceId: {
              "!doc": "The ID of the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setMessage: {
              "!doc": "An optional message to send with the challenge<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.WithdrawChallengeResponse))"
            }
          }
        },
        XBOXLiveConnectRequest: {
          "!doc": "Allows an Xbox Live Shared Token String to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from the Xbox Live and store them within GameSparks.<br/>GameSparks will determine the player's friends and whether any of them are currently registered with the game.<br/>If the Xbox user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Xbox user is not already registered with the game, the Xbox user will be linked to the current player.<br/>If the current player has not authenticated and the Xbox user is not known, a new player will be created using the Xbox details and the session will be authenticated against the new player.<br/>If the Xbox user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setDisplayName: {
              "!doc": "The displayName to set for the player in GameSparks<br/>",
              "!type": "fn(string) -> !this"
            },
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setStsTokenString: {
              "!doc": "The access token is used by the client to make authenticated requests on behalf of the end user.<br/>It has a longer lifetime than the authorization code, typically on the order of minutes or hours.<br/>When the access token expires, attempts to use it will fail, and a new access token must be obtained via a refresh token.<br/>",
              "!type": "fn(string) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        XboxOneConnectRequest: {
          "!doc": "Allows an Xbox One XSTS token to be used as an authentication mechanism.<br/>Once authenticated the platform can determine the current players details from Xbox Live and store them within GameSparks.<br/>If the Xbox One user is already linked to a player, the current session will switch to the linked player.<br/>If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Xbox One user is not already registered with the game, the Xbox One user will be linked to the current player.<br/>If the current player has not authenticated and the Xbox One user is not known, a new player will be created using the Xbox Live details and the session will be authenticated against the new player.<br/>If the Xbox One user is already known, the session will switch to being the previously created user.<br/>",
          prototype: {
            setDoNotLinkToCurrentPlayer: {
              "!doc": "Indicates that the server should not try to link the external profile with the current player.  If false, links the external profile to the currently signed in player.  If true, creates a new player and links the external profile to them.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setErrorOnSwitch: {
              "!doc": "Indicates whether the server should return an error if an account switch would have occurred, rather than switching automatically.  Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSandbox: {
              "!doc": "The Xbox Live sandbox to use. If not specified, the sandbox from the decoded token will be used.<br/>",
              "!type": "fn(string) -> !this"
            },
            setSegments: {
              "!doc": "An optional segment configuration for this request.<br/>If this request creates a new player on the gamesparks platform, the segments of the new player will match the values provided<br/>",
              "!type": "fn(?) -> !this"
            },
            setSwitchIfPossible: {
              "!doc": "Indicates that the server should switch to the supplied profile if it isalready associated to a player. Defaults to false.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setSyncDisplayName: {
              "!doc": "Indicates that the associated players displayName should be kept in syn with this profile when it's updated by the external provider.<br/>",
              "!type": "fn(bool) -> !this"
            },
            setToken: {
              "!doc": "The Xbox One authentication token<br/>",
              "!type": "fn(string) -> !this"
            },
            setScriptData: {
              "!doc": "Custom data that can be read by javascript",
              "!type": "fn(scriptData: ?) -> !this"
            },
            setPlayerId: {
              "!doc": "The GameSparks PlayerId to send the request as",
              "!type": "fn(playerId: number) -> !this"
            },
            send: {
              "!doc": "Sends the request",
              "!type": "fn(callback: fn(response: +RTSession.newRequest.AuthenticationResponse))"
            }
          }
        },
        BulkJob: {
          "!doc": "A nested object that represents the bulk job.<br/>",
          actualCount: {
            "!doc": "The actual count of players affected by the bulk job (calculated when the job started to run)<br/>",
            "!type": "number"
          },
          completed: {
            "!doc": "The time at which the bulk job completed execution<br/>",
            "!type": "date"
          },
          created: {
            "!doc": "The time at which the bulk job was created<br/>",
            "!type": "date"
          },
          data: {
            "!doc": "Data to be passed into the Module or Script<br/>",
            "!type": "RTSession.newRequest.DBObject"
          },
          doneCount: {
            "!doc": "The number of players processed by the bulk job so far<br/>",
            "!type": "number"
          },
          errorCount: {
            "!doc": "The number of errors encountered whilst running the Module or Script for players<br/>",
            "!type": "number"
          },
          estimatedCount: {
            "!doc": "The estimated count of players affected by the bulk job (estimated when the job was submitted)<br/>",
            "!type": "number"
          },
          id: {
            "!doc": "The ID for the bulk job<br/>",
            "!type": "string"
          },
          moduleShortCode: {
            "!doc": "The Cloud Code Module to run for each player<br/>",
            "!type": "string"
          },
          playerQuery: {
            "!doc": "The query to identify players to perform the bulk job on<br/>",
            "!type": "RTSession.newRequest.DBObject"
          },
          scheduledTime: {
            "!doc": "The time at which the job was scheduled to run<br/>",
            "!type": "date"
          },
          script: {
            "!doc": "The Cloud Code script to run for each player<br/>",
            "!type": "string"
          },
          started: {
            "!doc": "The time at which the bulk job started to execute<br/>",
            "!type": "date"
          },
          state: {
            "!doc": "The current state of the bulk job<br/>",
            "!type": "string"
          }
        },
        InvitableFriend: {
          "!doc": "A nested object that represents the invitable friend.<br/>",
          displayName: {
            "!doc": "The display name of the External Friend<br/>",
            "!type": "string"
          },
          id: {
            "!doc": "The ID of the External Friend<br/>",
            "!type": "string"
          },
          profilePic: {
            "!doc": "The profile picture URL of the External Friend<br/>",
            "!type": "string"
          }
        },
        Achievement: {
          "!doc": "A nested object that represents the achievement data.<br/>",
          description: {
            "!doc": "The desciption of the Achievement<br/>",
            "!type": "string"
          },
          earned: {
            "!doc": "Whether to current player has earned the achievement<br/>",
            "!type": "bool"
          },
          name: {
            "!doc": "The name of the Achievement<br/>",
            "!type": "string"
          },
          propertySet: {
            "!doc": "The custom property set configured on this Achievement<br/>",
            "!type": "?"
          },
          shortCode: {
            "!doc": "The shortCode of the Achievement<br/>",
            "!type": "string"
          }
        },
        BundledGood: {
          "!doc": "A collection of arbitrary data that can be added to a message via a Cloud Code script.<br/>",
          qty: {
            "!doc": "The number of items bundled<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The shortCode of the bundled good<br/>",
            "!type": "string"
          }
        },
        VirtualGood: {
          "!doc": "A nested object that represents the virtual good.<br/>",
          WP8StoreProductId: {
            "!doc": "The Windows Phone 8 productId of the item.<br/>",
            "!type": "string"
          },
          amazonStoreProductId: {
            "!doc": "The Amazon Store productId of the item.<br/>",
            "!type": "string"
          },
          baseCurrency1Cost: {
            "!doc": "The Base Currency1 cost of the Virtual Good, before segmentation<br/>",
            "!type": "number"
          },
          baseCurrency2Cost: {
            "!doc": "The Base Currency2 cost of the Virtual Good, before segmentation<br/>",
            "!type": "number"
          },
          baseCurrency3Cost: {
            "!doc": "The Base Currency3 cost of the Virtual Good, before segmentation<br/>",
            "!type": "number"
          },
          baseCurrency4Cost: {
            "!doc": "The Base Currency4 cost of the Virtual Good, before segmentation<br/>",
            "!type": "number"
          },
          baseCurrency5Cost: {
            "!doc": "The Base Currency5 cost of the Virtual Good, before segmentation<br/>",
            "!type": "number"
          },
          baseCurrency6Cost: {
            "!doc": "The Base Currency6 cost of the Virtual Good, before segmentation<br/>",
            "!type": "number"
          },
          baseCurrencyCosts: {
            "!doc": "The Base currency costs of the Virtual Good, before experiments<br/>",
            "!type": "?"
          },
          bundledGoods: {
            "!doc": "Returns the bundle goods of the virtual good<br/>",
            "!type": "[RTSession.newRequest.BundledGood]"
          },
          currency1Cost: {
            "!doc": "The Currency1 cost of the Virtual Good<br/>",
            "!type": "number"
          },
          currency2Cost: {
            "!doc": "The Currency2 cost of the Virtual Good<br/>",
            "!type": "number"
          },
          currency3Cost: {
            "!doc": "The Currency3 cost of the Virtual Good<br/>",
            "!type": "number"
          },
          currency4Cost: {
            "!doc": "The Currency4 cost of the Virtual Good<br/>",
            "!type": "number"
          },
          currency5Cost: {
            "!doc": "The Currency5 cost of the Virtual Good<br/>",
            "!type": "number"
          },
          currency6Cost: {
            "!doc": "The Currency6 cost of the Virtual Good<br/>",
            "!type": "number"
          },
          currencyCosts: {
            "!doc": "The currency costs of the Virtual Good<br/>",
            "!type": "?"
          },
          description: {
            "!doc": "The description of the Virtual Good<br/>",
            "!type": "string"
          },
          disabled: {
            "!doc": "Whether the item is disabled.<br/>",
            "!type": "bool"
          },
          googlePlayProductId: {
            "!doc": "The google play productId of the item.<br/>",
            "!type": "string"
          },
          iosAppStoreProductId: {
            "!doc": "The iOS AppStore productId of the item.<br/>",
            "!type": "string"
          },
          maxQuantity: {
            "!doc": "The maximum number of the Virtual Good that can be owned at one time<br/>",
            "!type": "number"
          },
          name: {
            "!doc": "The name of the Virtual Good<br/>",
            "!type": "string"
          },
          propertySet: {
            "!doc": "The custom property set configured on the item.<br/>",
            "!type": "?"
          },
          psnStoreProductId: {
            "!doc": "The PSN Store productId of the item.<br/>",
            "!type": "string"
          },
          segmentedCurrency1Cost: {
            "!doc": "The Segmented Currency1 cost of the Virtual Good, before experiments<br/>",
            "!type": "number"
          },
          segmentedCurrency2Cost: {
            "!doc": "The Segmented Currency2 cost of the Virtual Good, before experiments<br/>",
            "!type": "number"
          },
          segmentedCurrency3Cost: {
            "!doc": "The Segmented Currency3 cost of the Virtual Good, before experiments<br/>",
            "!type": "number"
          },
          segmentedCurrency4Cost: {
            "!doc": "The Segmented Currency4 cost of the Virtual Good, before experiments<br/>",
            "!type": "number"
          },
          segmentedCurrency5Cost: {
            "!doc": "The Segmented Currency5 cost of the Virtual Good, before experiments<br/>",
            "!type": "number"
          },
          segmentedCurrency6Cost: {
            "!doc": "The Segmented Currency6 cost of the Virtual Good, before experiments<br/>",
            "!type": "number"
          },
          segmentedCurrencyCosts: {
            "!doc": "The segmented currency costs of the Virtual Good, before experiments<br/>",
            "!type": "?"
          },
          shortCode: {
            "!doc": "The short code of the Virtual Good<br/>",
            "!type": "string"
          },
          steamStoreProductId: {
            "!doc": "The Steam Store productId of the item.<br/>",
            "!type": "string"
          },
          tags: {
            "!doc": "The tags of the Virtual Good<br/>",
            "!type": "string"
          },
          type: {
            "!doc": 'The type of the virtual good, "VGOOD" or "CURRENCY"<br/>',
            "!type": "string"
          },
          w8StoreProductId: {
            "!doc": "The Windows 8 productId of the item.<br/>",
            "!type": "string"
          }
        },
        Player: {
          "!doc": "A nested object that represents a player.<br/>",
          achievements: {
            "!doc": "The achievements of the Player<br/>",
            "!type": "[string]"
          },
          displayName: {
            "!doc": "The display name of the Player<br/>",
            "!type": "string"
          },
          externalIds: {
            "!doc": "The external Id's of the Player<br/>",
            "!type": "?"
          },
          id: {
            "!doc": "The Id of the Player<br/>",
            "!type": "string"
          },
          online: {
            "!doc": "The online status of the Player<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "The script data of the Player<br/>",
            "!type": "?"
          },
          virtualGoods: {
            "!doc": "The virtual goods of the Player<br/>",
            "!type": "[string]"
          }
        },
        Team: {
          "!doc": "A nested object that represents the team.<br/>",
          members: {
            "!doc": "The team members<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          owner: {
            "!doc": "A summary of the owner<br/>",
            "!type": "RTSession.newRequest.Player"
          },
          teamId: {
            "!doc": "The Id of the team<br/>",
            "!type": "string"
          },
          teamName: {
            "!doc": "The team name<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The team type<br/>",
            "!type": "string"
          }
        },
        Leaderboard: {
          "!doc": "A nested object that represents the leaderboard configuration data.<br/>",
          description: {
            "!doc": "The leaderboard's description.<br/>",
            "!type": "string"
          },
          name: {
            "!doc": "The leaderboard's name.<br/>",
            "!type": "string"
          },
          propertySet: {
            "!doc": "The custom property set configured on this Leaderboard<br/>",
            "!type": "?"
          },
          shortCode: {
            "!doc": "The leaderboard's short code.<br/>",
            "!type": "string"
          }
        },
        ChatMessage: {
          "!doc": "A message from a group chat<br/>",
          fromId: {
            "!doc": "The id of the player who sent this message<br/>",
            "!type": "string"
          },
          id: {
            "!doc": "The id of this chat message<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "The text sent in this message<br/>",
            "!type": "string"
          },
          when: {
            "!doc": "A date representing the time this message was sent<br/>",
            "!type": "date"
          },
          who: {
            "!doc": "The displayName of the player who sent this message<br/>",
            "!type": "string"
          }
        },
        PlayerDetail: {
          "!doc": "An object representing a player's id and name<br/>",
          externalIds: {
            "!doc": "A player's external identifiers<br/>",
            "!type": "?"
          },
          id: {
            "!doc": "A player's id<br/>",
            "!type": "string"
          },
          name: {
            "!doc": "A player's name<br/>",
            "!type": "string"
          }
        },
        UploadData: {
          "!doc": "This object represents the result of uploading a file to the GameSparks platform.<br/>",
          fileName: {
            "!doc": "The filename of the file that was uploaded.<br/>",
            "!type": "string"
          },
          playerId: {
            "!doc": "The unique player id of the player that uploaded the file.<br/>",
            "!type": "string"
          }
        },
        ScriptData: {
          "!doc": "A collection of arbitrary data that can be added to a message via a Cloud Code script.<br/>",
          myKey: {
            "!doc": "An arbitrary data key<br/>",
            "!type": "string"
          },
          myValue: {
            "!doc": "An arbitrary data value.<br/>",
            "!type": "?"
          }
        },
        ChallengeType: {
          "!doc": "<br/>",
          challengeShortCode: {
            "!doc": "The shortCode for this challenge.<br/>",
            "!type": "string"
          },
          description: {
            "!doc": "The description of this challenge.<br/>",
            "!type": "string"
          },
          getleaderboardName: {
            "!doc": "The name of the leaderboard for this challenge.<br/>",
            "!type": "string"
          },
          name: {
            "!doc": "The name of this challenge.<br/>",
            "!type": "string"
          },
          tags: {
            "!doc": "The tags for this challenge.<br/>",
            "!type": "string"
          }
        },
        Boughtitem: {
          "!doc": "A nested object that represents a bought item.<br/>",
          quantity: {
            "!doc": "The quantity of the bought item<br/>",
            "!type": "number"
          },
          shortCode: {
            "!doc": "The short code of the bought item<br/>",
            "!type": "string"
          }
        },
        PlayerMessage: {
          "!doc": "A nested object that represents a player message.<br/>",
          id: {
            "!doc": "The id of the message<br/>",
            "!type": "string"
          },
          message: {
            "!doc": "The message content<br/>",
            "!type": "?"
          },
          seen: {
            "!doc": "Whether the message has been delivered to the client<br/>",
            "!type": "bool"
          },
          status: {
            "!doc": "The status of the message<br/>",
            "!type": "string"
          },
          when: {
            "!doc": "The date of the message<br/>",
            "!type": "date"
          }
        },
        MatchedPlayer: {
          "!doc": "An object that represents a player in a pending match.<br/>",
          location: {
            "!doc": "The Location of the player<br/>",
            "!type": "RTSession.newRequest.DBObject"
          },
          participantData: {
            "!doc": "A JSON Map of any data that was associated to this user<br/>",
            "!type": "?"
          },
          playerId: {
            "!doc": "The ID for player<br/>",
            "!type": "string"
          },
          skill: {
            "!doc": "The skill of the player in this match<br/>",
            "!type": "number"
          }
        },
        PendingMatch: {
          "!doc": "An object that represents a pending match.<br/>",
          id: {
            "!doc": "The ID for the pending match<br/>",
            "!type": "string"
          },
          matchData: {
            "!doc": "A JSON Map of the matchData associated to this pending match<br/>",
            "!type": "?"
          },
          matchGroup: {
            "!doc": "The match group for the pending match<br/>",
            "!type": "string"
          },
          matchShortCode: {
            "!doc": "The match shortCode for the pending match<br/>",
            "!type": "string"
          },
          matchedPlayers: {
            "!doc": "The players already part of this pending match<br/>",
            "!type": "[RTSession.newRequest.MatchedPlayer]"
          },
          skill: {
            "!doc": "The average skill of players in this pending match<br/>",
            "!type": "number"
          }
        },
        Participant: {
          "!doc": "A nested object that represents a participant in a match.<br/>",
          achievements: {
            "!doc": "The achievements of the Player<br/>",
            "!type": "[string]"
          },
          displayName: {
            "!doc": "The display name of the Player<br/>",
            "!type": "string"
          },
          externalIds: {
            "!doc": "The external Id's of the Player<br/>",
            "!type": "?"
          },
          id: {
            "!doc": "The Id of the Player<br/>",
            "!type": "string"
          },
          online: {
            "!doc": "The online status of the Player<br/>",
            "!type": "bool"
          },
          participantData: {
            "!doc": "A JSON Map of any data that was associated to this user<br/>",
            "!type": "?"
          },
          peerId: {
            "!doc": "The peerId of this participant within the match<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "The script data of the Player<br/>",
            "!type": "?"
          },
          virtualGoods: {
            "!doc": "The virtual goods of the Player<br/>",
            "!type": "[string]"
          }
        },
        PlayerTransactionItem: {
          "!doc": "A nested object that represents a single item in a transaction.<br/>",
          amount: {
            "!doc": "The amount of this item given to the player in the transaction<br/>",
            "!type": "number"
          },
          newValue: {
            "!doc": "The quantity the player possesses after the transaction completed<br/>",
            "!type": "number"
          },
          type: {
            "!doc": "The type of item<br/>",
            "!type": "string"
          }
        },
        PlayerTransaction: {
          "!doc": "A nested object that represents a player transaction.<br/>",
          items: {
            "!doc": "The items (currency or virtual goods) involved in this transaction<br/>",
            "!type": "[RTSession.newRequest.PlayerTransactionItem]"
          },
          originalRequestId: {
            "!doc": "The original request ID for this transaction<br/>",
            "!type": "string"
          },
          playerId: {
            "!doc": "The player ID<br/>",
            "!type": "string"
          },
          reason: {
            "!doc": "The reason for the transaction<br/>",
            "!type": "string"
          },
          revokeDate: {
            "!doc": "Gets the date when this transaction was revoked, if applicable<br/>",
            "!type": "date"
          },
          revoked: {
            "!doc": "Is true if the transaction was revoked<br/>",
            "!type": "bool"
          },
          script: {
            "!doc": "The specific script in which this transaction occurred<br/>",
            "!type": "string"
          },
          scriptType: {
            "!doc": "The script type in which this transaction occurred (e.g. event)<br/>",
            "!type": "string"
          },
          transactionId: {
            "!doc": "The transaction ID of this purchase, if applicable<br/>",
            "!type": "string"
          },
          when: {
            "!doc": "The date of the transaction<br/>",
            "!type": "date"
          }
        },
        PlayerTurnCount: {
          "!doc": "Represents the number of turns a player has taken in a turn based challenge.<br/>",
          count: {
            "!doc": "The number of turns that the player has taken so far during this challenge.<br/>",
            "!type": "string"
          },
          playerId: {
            "!doc": "The unique player id.<br/>",
            "!type": "string"
          }
        },
        Challenge: {
          "!doc": "A nested object that represents the challenge data.<br/>",
          accepted: {
            "!doc": "A list of PlayerDetail objects that represents the players that have accepted this challenge.<br/>",
            "!type": "[RTSession.newRequest.PlayerDetail]"
          },
          challengeId: {
            "!doc": "A unique identifier for this challenge.<br/>",
            "!type": "string"
          },
          challengeMessage: {
            "!doc": "The message included in the challenge by the challenging player who created the challenge.<br/>",
            "!type": "string"
          },
          challengeName: {
            "!doc": "The name of the challenge that this message relates to.<br/>",
            "!type": "string"
          },
          challenged: {
            "!doc": "A list of PlayerDetail objects that represents the players that were challenged in this challenge.<br/>",
            "!type": "[RTSession.newRequest.PlayerDetail]"
          },
          challenger: {
            "!doc": "Details of the player who issued this challenge.<br/>",
            "!type": "RTSession.newRequest.PlayerDetail"
          },
          currency1Wager: {
            "!doc": "The amount of type 1 currency that has been wagered on this challenge.<br/>",
            "!type": "number"
          },
          currency2Wager: {
            "!doc": "The amount of type 2 currency that has been wagered on this challenge.<br/>",
            "!type": "number"
          },
          currency3Wager: {
            "!doc": "The amount of type 3 currency that has been wagered on this challenge.<br/>",
            "!type": "number"
          },
          currency4Wager: {
            "!doc": "The amount of type 4 currency that has been wagered on this challenge.<br/>",
            "!type": "number"
          },
          currency5Wager: {
            "!doc": "The amount of type 5 currency that has been wagered on this challenge.<br/>",
            "!type": "number"
          },
          currency6Wager: {
            "!doc": "The amount of type 6 currency that has been wagered on this challenge.<br/>",
            "!type": "number"
          },
          currencyWagers: {
            "!doc": "An object representing the currencies that have been wagered on this challenge.<br/>",
            "!type": "?"
          },
          declined: {
            "!doc": "A list of PlayerDetail objects that represents the players that have declined this challenge.<br/>",
            "!type": "[RTSession.newRequest.PlayerDetail]"
          },
          endDate: {
            "!doc": "The date when the challenge ends.<br/>",
            "!type": "date"
          },
          expiryDate: {
            "!doc": "The latest date that a player can accept the challenge.<br/>",
            "!type": "date"
          },
          maxTurns: {
            "!doc": "The maximum number of turns that this challenge is configured for.<br/>",
            "!type": "number"
          },
          nextPlayer: {
            "!doc": "In a turn based challenge this fields contains the player's id whose turn it is next.<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "ScriptData is arbitrary data that can be stored in a challenge instance by a Cloud Code script.<br/>",
            "!type": "?"
          },
          shortCode: {
            "!doc": "The challenge's short code.<br/>",
            "!type": "string"
          },
          startDate: {
            "!doc": "The date when the challenge starts.<br/>",
            "!type": "date"
          },
          state: {
            "!doc": "One of these possible state values: ISSUED, EXPIRED, ACCEPTED, DECLINED, COMPLETE, WITHDRAWN, RUNNING, WAITING, RECEIVED<br/>",
            "!type": "string"
          },
          turnCount: {
            "!doc": "A collection containing the number of turns taken by each player that has accepted the challenge.<br/>Each turn count is a Long keyed on a String that represents the player's id<br/>",
            "!type": "[RTSession.newRequest.PlayerTurnCount]"
          }
        },
        SocialStatus: {
          "!doc": "A the details of a social connection<br/>",
          active: {
            "!doc": "When the token is still active.<br/>",
            "!type": "bool"
          },
          expires: {
            "!doc": "When the token expires (if available).<br/>",
            "!type": "date"
          },
          systemId: {
            "!doc": "The identifier of the external platform.<br/>",
            "!type": "string"
          }
        },
        LeaderboardData: {
          "!doc": "Leaderboard entry data<br/>As well as the parameters below there may be others depending on your game's configuration.<br/>",
          city: {
            "!doc": "The city where the player was located when they logged this leaderboard entry.<br/>",
            "!type": "string"
          },
          country: {
            "!doc": "The country code where the player was located when they logged this leaderboard entry.<br/>",
            "!type": "string"
          },
          externalIds: {
            "!doc": "The players rank.<br/>",
            "!type": "?"
          },
          rank: {
            "!doc": "The players rank.<br/>",
            "!type": "number"
          },
          userId: {
            "!doc": "The unique player id for this leaderboard entry.<br/>",
            "!type": "string"
          },
          userName: {
            "!doc": "The players display name.<br/>",
            "!type": "string"
          },
          when: {
            "!doc": "The date when this leaderboard entry was created.<br/>",
            "!type": "string"
          }
        },
        LeaderboardRankDetails: {
          "!doc": "Ranking information.<br/>",
          friendsPassed: {
            "!doc": "The leaderboard entries of the players friends that were beaten as part of this score submission.<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          },
          globalCount: {
            "!doc": "The number of entries in this leaderboard.<br/>",
            "!type": "number"
          },
          globalFrom: {
            "!doc": "The Global Rank of the player in this leaderboard before the score was submitted.<br/>",
            "!type": "number"
          },
          globalFromPercent: {
            "!doc": "The old global rank of the player as a percentage of the total number of scores in this leaderboard .<br/>",
            "!type": "number"
          },
          globalTo: {
            "!doc": "The Global Rank of the player in this leaderboard after the score was submitted.<br/>",
            "!type": "number"
          },
          globalToPercent: {
            "!doc": "The new global rank of the player as a percentage of the total number of scores in this leaderboard .<br/>",
            "!type": "number"
          },
          socialCount: {
            "!doc": "The number of friend entries the player has in this leaderboard.<br/>",
            "!type": "number"
          },
          socialFrom: {
            "!doc": "The Social Rank of the player in this leaderboard before the score was submitted.<br/>",
            "!type": "number"
          },
          socialFromPercent: {
            "!doc": "The old social rank of the player as a percentage of the total number of friend scores in this leaderboard.<br/>",
            "!type": "number"
          },
          socialTo: {
            "!doc": "The Social Rank of the player in this leaderboard after the score was submitted.<br/>",
            "!type": "number"
          },
          socialToPercent: {
            "!doc": "The old global rank of the player as a percentage of the total number of friend scores in this leaderboard.<br/>",
            "!type": "number"
          },
          topNPassed: {
            "!doc": "The leaderboard entries of the global players that were beaten as part of this score submission. Requires Top N to be configured on the leaderboard<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          }
        },
        Location: {
          "!doc": "Location details.<br/>",
          city: {
            "!doc": "The city<br/>",
            "!type": "string"
          },
          country: {
            "!doc": "The country<br/>",
            "!type": "string"
          },
          latitide: {
            "!doc": "The latitude<br/>",
            "!type": "number"
          },
          longditute: {
            "!doc": "The longditute<br/>",
            "!type": "number"
          }
        },
        AcceptChallengeResponse: {
          "!doc": "A response containing the challenge instance id that was accepted.<br/>",
          challengeInstanceId: {
            "!doc": "The ID of the challenge<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        AccountDetailsResponse: {
          "!doc": "A response containing the player's data.<br/>",
          achievements: {
            "!doc": "A JSON object containing the player's achievments<br/>",
            "!type": "[string]"
          },
          currencies: {
            "!doc": "A JSON object containing the player's currency balances<br/>",
            "!type": "?"
          },
          currency1: {
            "!doc": "The amount of type 1 currency that the player holds<br/>",
            "!type": "number"
          },
          currency2: {
            "!doc": "The amount of type 2 currency that the player holds<br/>",
            "!type": "number"
          },
          currency3: {
            "!doc": "The amount of type 3 currency that the player holds<br/>",
            "!type": "number"
          },
          currency4: {
            "!doc": "The amount of type 4 currency that the player holds<br/>",
            "!type": "number"
          },
          currency5: {
            "!doc": "The amount of type 5 currency that the player holds<br/>",
            "!type": "number"
          },
          currency6: {
            "!doc": "The amount of type 6 currency that the player holds<br/>",
            "!type": "number"
          },
          displayName: {
            "!doc": "The player's display name<br/>",
            "!type": "string"
          },
          externalIds: {
            "!doc": "A JSON object containing the player's external account details<br/>",
            "!type": "?"
          },
          location: {
            "!doc": "A JSON object containing the player's location<br/>",
            "!type": "RTSession.newRequest.Location"
          },
          reservedCurrencies: {
            "!doc": "A JSON object containing the player's currency balances<br/>",
            "!type": "?"
          },
          reservedCurrency1: {
            "!doc": "The amount of type 1 currency that the player holds which is currently reserved<br/>",
            "!type": "?"
          },
          reservedCurrency2: {
            "!doc": "The amount of type 2 currency that the player holds which is currently reserved<br/>",
            "!type": "?"
          },
          reservedCurrency3: {
            "!doc": "The amount of type 3 currency that the player holds which is currently reserved<br/>",
            "!type": "?"
          },
          reservedCurrency4: {
            "!doc": "The amount of type 4 currency that the player holds which is currently reserved<br/>",
            "!type": "?"
          },
          reservedCurrency5: {
            "!doc": "The amount of type 5 currency that the player holds which is currently reserved<br/>",
            "!type": "?"
          },
          reservedCurrency6: {
            "!doc": "The amount of type 6 currency that the player holds which is currently reserved<br/>",
            "!type": "?"
          },
          userId: {
            "!doc": "The player's id<br/>",
            "!type": "string"
          },
          virtualGoods: {
            "!doc": "A JSON object containing the virtual goods that the player owns<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        AnalyticsResponse: {
          "!doc": "A response to an analytics request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        AroundMeLeaderboardResponse: {
          "!doc": "A response containing leaderboard data around the current player<br/>",
          challengeInstanceId: {
            "!doc": "The leaderboard's challenge id<br/>",
            "!type": "string"
          },
          data: {
            "!doc": "The leaderboard data<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          },
          first: {
            "!doc": "The first item in the leaderboard data<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          },
          last: {
            "!doc": "The last item in the leaderboard data<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          },
          leaderboardShortCode: {
            "!doc": "The leaderboard short code<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          social: {
            "!doc": "True if the response contains a social leaderboard's data<br/>",
            "!type": "bool"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        AuthenticationResponse: {
          "!doc": "A response containing the auth token<br/>",
          authToken: {
            "!doc": "44b297a8-162a-4220-8c14-dad9a1946ad2<br/>",
            "!type": "string"
          },
          displayName: {
            "!doc": "The player's display name<br/>",
            "!type": "string"
          },
          newPlayer: {
            "!doc": "Indicates whether the player was created as part of this request<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          switchSummary: {
            "!doc": "A summary of the player that would be switched to.  Only returned as part of an error response for a request where automatic switching is disabled.<br/>",
            "!type": "RTSession.newRequest.Player"
          },
          userId: {
            "!doc": "The player's id<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        BatchAdminResponse: {
          "!doc": "A response containing the individual responses for requests performed via a BatchAdminRequest<br/>",
          responses: {
            "!doc": "A map of responses by player ID<br/>",
            "!type": "?"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        BuyVirtualGoodResponse: {
          "!doc": "A response containing details of the bought items<br/>",
          boughtItems: {
            "!doc": "A JSON object containing details of the bought items<br/>",
            "!type": "[RTSession.newRequest.Boughtitem]"
          },
          currenciesAdded: {
            "!doc": "An object containing the short code and amount added for each currency<br/>",
            "!type": "?"
          },
          currency1Added: {
            "!doc": "How much currency type 1 was added<br/>",
            "!type": "number"
          },
          currency2Added: {
            "!doc": "How much currency type 2 was added<br/>",
            "!type": "number"
          },
          currency3Added: {
            "!doc": "How much currency type 3 was added<br/>",
            "!type": "number"
          },
          currency4Added: {
            "!doc": "How much currency type 4 was added<br/>",
            "!type": "number"
          },
          currency5Added: {
            "!doc": "How much currency type 5 was added<br/>",
            "!type": "number"
          },
          currency6Added: {
            "!doc": "How much currency type 6 was added<br/>",
            "!type": "number"
          },
          currencyConsumed: {
            "!doc": "For a buy with currency request, how much currency was used<br/>",
            "!type": "number"
          },
          currencyShortCode: {
            "!doc": "For a buy with currency request, the short code of the currency used<br/>",
            "!type": "string"
          },
          currencyType: {
            "!doc": "For a buy with currency request, which currency type was used<br/>",
            "!type": "number"
          },
          invalidItems: {
            "!doc": "A list of invalid items for this purchase (if any). This field is populated only for store buys<br/>",
            "!type": "[string]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          transactionIds: {
            "!doc": "The list of transactionIds, for this purchase, if they exist. This field is populated only for store buys<br/>",
            "!type": "[string]"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        CancelBulkJobAdminResponse: {
          "!doc": "A response listing cancelled bulk jobs<br/>",
          bulkJobs: {
            "!doc": "A list of JSON objects containing bulk jobs<br/>",
            "!type": "[RTSession.newRequest.BulkJob]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ChangeUserDetailsResponse: {
          "!doc": "A response to a change user details request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ChatOnChallengeResponse: {
          "!doc": "A response to a chat on challenge request<br/>",
          challengeInstanceId: {
            "!doc": "The challenge instance id<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ConsumeVirtualGoodResponse: {
          "!doc": "A response to a consume virtual goods response<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        CreateChallengeResponse: {
          "!doc": "A response to a create challenge response<br/>",
          challengeInstanceId: {
            "!doc": "The challenge instance id<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        CreateTeamResponse: {
          "!doc": "A response containing the details of the team that was created<br/>",
          members: {
            "!doc": "The team members<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          owner: {
            "!doc": "A summary of the owner<br/>",
            "!type": "RTSession.newRequest.Player"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          teamId: {
            "!doc": "The Id of the team<br/>",
            "!type": "string"
          },
          teamName: {
            "!doc": "The team name<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The team type<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        DeclineChallengeResponse: {
          "!doc": "A response containing the challenge instance id of the challenge that was declined<br/>",
          challengeInstanceId: {
            "!doc": "The challenge instance id<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        DismissMessageResponse: {
          "!doc": "A response to a dismiss message request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        DismissMultipleMessagesResponse: {
          "!doc": "A response to a dismiss message request<br/>",
          failedDismissals: {
            "!doc": "A list of the messageId values that were not dismissed<br/>",
            "!type": "[string]"
          },
          messagesDismissed: {
            "!doc": "An integer describing how many messages were dismissed<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        DropTeamResponse: {
          "!doc": "A response to a drop team request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        EndSessionResponse: {
          "!doc": "A response to an end session request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          sessionDuration: {
            "!doc": "The length of this session<br/>",
            "!type": "number"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        FindChallengeResponse: {
          "!doc": "A response to a find challenge request<br/>",
          challengeInstances: {
            "!doc": "A list of JSON objects representing the challenges.<br/>",
            "!type": "[RTSession.newRequest.Challenge]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        FindMatchResponse: {
          "!doc": "A response to a find match request<br/>",
          accessToken: {
            "!doc": "The accessToken used to authenticate this player for this match<br/>",
            "!type": "string"
          },
          host: {
            "!doc": "The host to connect to for this match<br/>",
            "!type": "string"
          },
          matchData: {
            "!doc": "MatchData is arbitrary data that can be stored in a Match instance by a Cloud Code script.<br/>",
            "!type": "?"
          },
          matchId: {
            "!doc": "The id for this match instance<br/>",
            "!type": "string"
          },
          opponents: {
            "!doc": "The opponents this player has been matched against<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          peerId: {
            "!doc": "The peerId of this player within the match<br/>",
            "!type": "number"
          },
          playerId: {
            "!doc": "The id of the current player<br/>",
            "!type": "string"
          },
          port: {
            "!doc": "The port to connect to for this match<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        FindPendingMatchesResponse: {
          "!doc": "A response to a FindPendingMatchesRequest<br/>",
          pendingMatches: {
            "!doc": "A list of JSON objects containing pending matches<br/>",
            "!type": "[RTSession.newRequest.PendingMatch]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GameSparksErrorResponse: {
          "!doc": "A response containing the details of an error<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetChallengeResponse: {
          "!doc": "A response containing the details of a challenge<br/>",
          challenge: {
            "!doc": "A JSON object representing the challenge.<br/>",
            "!type": "RTSession.newRequest.Challenge"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetDownloadableResponse: {
          "!doc": "A response containing the download URL for a downloadable item<br/>",
          lastModified: {
            "!doc": "The date when the downloadable item was last modified<br/>",
            "!type": "date"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          shortCode: {
            "!doc": "The short code of the item<br/>",
            "!type": "string"
          },
          size: {
            "!doc": "The size of the item in bytes<br/>",
            "!type": "number"
          },
          url: {
            "!doc": "The download URL<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetLeaderboardEntriesResponse: {
          "!doc": 'A response containing leaderboard entry data for a given player. Example response: {"HS": {"userId":"537f08e1e4b01fdedfa52c49","SCORE": 123,"city":"York","country":"GB","userName":"","when":"2014-07-17T12:18Z","rank": 1 }<br/>',
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetMessageResponse: {
          "!doc": "A response containing the message data for a given message<br/>",
          message: {
            "!doc": "The message data<br/>",
            "!type": "?"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          status: {
            "!doc": "The message status<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetMyTeamsResponse: {
          "!doc": "A response containing team data for teams that a player belong to<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          teams: {
            "!doc": "The team data<br/>",
            "!type": "[RTSession.newRequest.Team]"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetPropertyResponse: {
          "!doc": "A response containing the requested property<br/>",
          property: {
            "!doc": "The property value<br/>",
            "!type": "?"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetPropertySetResponse: {
          "!doc": "A response containing the requested property set<br/>",
          propertySet: {
            "!doc": "The property set<br/>",
            "!type": "?"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetTeamResponse: {
          "!doc": "A response containing the details of the requested teams<br/>",
          members: {
            "!doc": "The team members<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          owner: {
            "!doc": "A summary of the owner<br/>",
            "!type": "RTSession.newRequest.Player"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          teamId: {
            "!doc": "The Id of the team<br/>",
            "!type": "string"
          },
          teamName: {
            "!doc": "The team name<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The team type<br/>",
            "!type": "string"
          },
          teams: {
            "!doc": "A JSON array of teams.<br/>",
            "!type": "[RTSession.newRequest.Team]"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetUploadUrlResponse: {
          "!doc": "A response containing a time sensitive URL to allow the game to upload a piece of player content to the GameSparks platform<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          url: {
            "!doc": "The time sensitive upload URL<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        GetUploadedResponse: {
          "!doc": "A reponse containing a time sensitive URL to a piece of content that was previously uploaded to the GameSparks platform by a player.<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          size: {
            "!doc": "The size of the file in bytes<br/>",
            "!type": "number"
          },
          url: {
            "!doc": "A time sensitive URL to a piece of content<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        JoinChallengeResponse: {
          "!doc": "A response to a player joining a challenge<br/>",
          joined: {
            "!doc": "Whether the player successfully joined the challenge<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        JoinPendingMatchResponse: {
          "!doc": "A response to a JoinPendingMatchRequest<br/>",
          pendingMatch: {
            "!doc": "A JSON object containing the new pending match<br/>",
            "!type": "RTSession.newRequest.PendingMatch"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        JoinTeamResponse: {
          "!doc": "A response to a player joining a team or a request for team data<br/>",
          members: {
            "!doc": "The team members<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          owner: {
            "!doc": "A summary of the owner<br/>",
            "!type": "RTSession.newRequest.Player"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          teamId: {
            "!doc": "The Id of the team<br/>",
            "!type": "string"
          },
          teamName: {
            "!doc": "The team name<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The team type<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        LeaderboardDataResponse: {
          "!doc": "A response containing leaderboard data<br/>",
          challengeInstanceId: {
            "!doc": "The leaderboard's challenge id<br/>",
            "!type": "string"
          },
          data: {
            "!doc": "The leaderboard data<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          },
          first: {
            "!doc": "The first item in the leaderboard data<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          },
          last: {
            "!doc": "The last item in the leaderboard data<br/>",
            "!type": "[RTSession.newRequest.LeaderboardData]"
          },
          leaderboardShortCode: {
            "!doc": "The leaderboard short code<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        LeaderboardsEntriesResponse: {
          "!doc": 'A response containing leaderboard entry data for a given player. The response will contain one key for every leaderboard in the result. Example response: {"HS": [{"userId":"537f08e1e4b01fdedfa52c49","SCORE": 123,"city":"York","country":"GB","userName":"","when":"2014-07-17T12:18Z","rank": 1  }]}<br/>',
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        LeaveTeamResponse: {
          "!doc": "A response to a player leaving a team<br/>",
          members: {
            "!doc": "The team members<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          owner: {
            "!doc": "A summary of the owner<br/>",
            "!type": "RTSession.newRequest.Player"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          teamId: {
            "!doc": "The Id of the team<br/>",
            "!type": "string"
          },
          teamName: {
            "!doc": "The team name<br/>",
            "!type": "string"
          },
          teamType: {
            "!doc": "The team type<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListAchievementsResponse: {
          "!doc": "A reponse containing the game's achievments and an indication of whether the player has earned it<br/>",
          achievements: {
            "!doc": "A list of JSON achievment objects<br/>",
            "!type": "[RTSession.newRequest.Achievement]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListBulkJobsAdminResponse: {
          "!doc": "A response listing existing bulk jobs<br/>",
          bulkJobs: {
            "!doc": "A list of JSON objects containing bulk jobs<br/>",
            "!type": "[RTSession.newRequest.BulkJob]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListChallengeResponse: {
          "!doc": "A response containing challenges that are in the state that was specified in the request<br/>",
          challengeInstances: {
            "!doc": "A list of JSON objects representing the challenges.<br/>",
            "!type": "[RTSession.newRequest.Challenge]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListChallengeTypeResponse: {
          "!doc": "A response containing the list of configured challenge types in the game<br/>",
          challengeTemplates: {
            "!doc": "A list of JSON objects containing the challenge templates for the game<br/>",
            "!type": "[RTSession.newRequest.ChallengeType]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListGameFriendsResponse: {
          "!doc": "A response containing the list of the current players game friends.<br/>",
          friends: {
            "!doc": "A list of JSON objects containing game friend data<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListInviteFriendsResponse: {
          "!doc": "A response containing a list of non game friends.<br/>",
          friends: {
            "!doc": "A list of JSON objects containing game friend data<br/>",
            "!type": "[RTSession.newRequest.InvitableFriend]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListLeaderboardsResponse: {
          "!doc": "A response containing a list of all leaderboards configured in the game.<br/>",
          leaderboards: {
            "!doc": "A list of JSON object containing leaderboard meta data<br/>",
            "!type": "[RTSession.newRequest.Leaderboard]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListMessageDetailResponse: {
          "!doc": "A response containing the list of the current players messages / notifications.<br/>",
          messageList: {
            "!doc": "A list of JSON objects containing player messages<br/>",
            "!type": "[RTSession.newRequest.PlayerMessage]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListMessageResponse: {
          "!doc": "A response containing the list of the current players messages / notifications.<br/>",
          messageList: {
            "!doc": "A list of JSON objects containing player messages<br/>",
            "!type": "[?]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListMessageSummaryResponse: {
          "!doc": "A response containing a summary of the list of the current players messages / notifications.<br/>",
          messageList: {
            "!doc": "A list of JSON objects containing player message summaries<br/>",
            "!type": "[?]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListTeamChatResponse: {
          "!doc": "A response to a list team messages request.<br/>",
          messages: {
            "!doc": "The collection of team chat messages<br/>",
            "!type": "[RTSession.newRequest.ChatMessage]"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListTeamsResponse: {
          "!doc": "A response containing the list of teams for a game.<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          teams: {
            "!doc": "A list of JSON objects containing team information<br/>",
            "!type": "[RTSession.newRequest.Team]"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListTransactionsResponse: {
          "!doc": "A response listing transactions for the player<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          transactionList: {
            "!doc": "A list of JSON objects containing player transactions<br/>",
            "!type": "[RTSession.newRequest.PlayerTransaction]"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ListVirtualGoodsResponse: {
          "!doc": "A response containing the list of configured virtual goods.<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          virtualGoods: {
            "!doc": "A list of JSON objects containing virtual goods data<br/>",
            "!type": "[RTSession.newRequest.VirtualGood]"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        LogChallengeEventResponse: {
          "!doc": "A response to a log challenge event request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        LogEventResponse: {
          "!doc": "A response to a log event request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        MatchDetailsResponse: {
          "!doc": "A response to a match details request<br/>",
          accessToken: {
            "!doc": "The accessToken used to authenticate this player for this match<br/>",
            "!type": "string"
          },
          host: {
            "!doc": "The host to connect to for this match<br/>",
            "!type": "string"
          },
          matchData: {
            "!doc": "MatchData is arbitrary data that can be stored in a Match instance by a Cloud Code script.<br/>",
            "!type": "?"
          },
          matchId: {
            "!doc": "The id for this match instance<br/>",
            "!type": "string"
          },
          opponents: {
            "!doc": "The opponents this player has been matched against<br/>",
            "!type": "[RTSession.newRequest.Player]"
          },
          peerId: {
            "!doc": "The peerId of this player within the match<br/>",
            "!type": "number"
          },
          playerId: {
            "!doc": "The id of the current player<br/>",
            "!type": "string"
          },
          port: {
            "!doc": "The port to connect to for this match<br/>",
            "!type": "number"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        MatchmakingResponse: {
          "!doc": "A response to a matchmaking request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        PushRegistrationResponse: {
          "!doc": "A response to a push registration request<br/>",
          registrationId: {
            "!doc": "An identifier for the successful registration.  Clients should store this value to be used in the event the player no longer wants to receive push notifications to this device.<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        RegistrationResponse: {
          "!doc": "A response to a registration request<br/>",
          authToken: {
            "!doc": "44b297a8-162a-4220-8c14-dad9a1946ad2<br/>",
            "!type": "string"
          },
          displayName: {
            "!doc": "The player's display name<br/>",
            "!type": "string"
          },
          newPlayer: {
            "!doc": "Indicates whether the player was created as part of this request<br/>",
            "!type": "bool"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          switchSummary: {
            "!doc": "A summary of the player that would be switched to.  Only returned as part of an error response for a request where automatic switching is disabled.<br/>",
            "!type": "RTSession.newRequest.Player"
          },
          userId: {
            "!doc": "The player's id<br/>",
            "!type": "string"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        RevokePurchaseGoodsResponse: {
          "!doc": "A response containing details of the revoked items<br/>",
          revokedGoods: {
            "!doc": "The map of revoked goods<br/>",
            "!type": "?"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        ScheduleBulkJobAdminResponse: {
          "!doc": "A response acknowledging the scheduling of a bulk job<br/>",
          estimatedCount: {
            "!doc": "The count of players who would be affected by this job if it ran at the time it was submitted<br/>",
            "!type": "number"
          },
          jobId: {
            "!doc": "The unique job ID, used to identify this job in future requests<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        SendFriendMessageResponse: {
          "!doc": "A response to a send friend message request.<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        SendTeamChatMessageResponse: {
          "!doc": "A response to a send team message request.<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        SocialDisconnectResponse: {
          "!doc": "A response to a SocialDisconnectRequest<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        SocialStatusResponse: {
          "!doc": "A response containing the details of a the players social connections<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          statuses: {
            "!doc": "A list of social statuses.<br/>",
            "!type": "[RTSession.newRequest.SocialStatus]"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        UpdateMessageResponse: {
          "!doc": "A response to an update message request<br/>",
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        },
        WithdrawChallengeResponse: {
          "!doc": "A response containing the challenge instance id that was withdrawn by a player<br/>",
          challengeInstanceId: {
            "!doc": "A challenge instance id<br/>",
            "!type": "string"
          },
          scriptData: {
            "!doc": "A JSON Map of any data added either to the Request or the Response by your Cloud Code<br/>",
            "!type": "?"
          },
          error: {
            "!doc": "The errors returned from the API",
            "!type": "JSON"
          }
        }
      },
      RTData: {
        "!doc": "The javascript representation of an RTData object<br/>This object allows you to inpect the RTData objects sent from a client<br/>This object is immutable, to create a new one you should use RTSession.getRTDataBuilder()<br/>",
        getData: {
          "!doc": "Gets an RTData object using the given index key, if the key contains a different type, or is empty a null will be returned<br/>",
          "!type": "fn(index: number) -> RTSession.RTData"
        },
        getDouble: {
          "!doc": "Gets a double using the given index key, if the key contains a different type, or is empty a null will be returned<br/>",
          "!type": "fn(index: number) -> number"
        },
        getFloat: {
          "!doc": "Gets a float using the given index key, if the key contains a different type, or is empty a null will be returned<br/>",
          "!type": "fn(index: number) -> number"
        },
        getFloatArray: {
          "!doc": "Gets a float array using the given index key, if the key contains a different type, or is empty a null will be returned<br/>",
          "!type": "fn(index: number) -> [number]"
        },
        getNumber: {
          "!doc": "Gets a number using the given index key, if the key contains a different type, or is empty a null will be returned<br/>",
          "!type": "fn(index: number) -> number"
        },
        getString: {
          "!doc": "Gets a string using the given index key, if the key contains a different type, or is empty a null will be returned<br/>",
          "!type": "fn(index: number) -> string"
        }
      },
      RTDataBuilder: {
        "!doc": "A builder object to construct RTData objects<br/>",
        setData: {
          "!doc": "Adds a nested RTData object at the given index key<br/>",
          "!type": "fn(index: number, value: RTSession.RTDataBuilder) -> RTSession.RTDataBuilder"
        },
        setDouble: {
          "!doc": "Adds a double at the given index key, the number will be added as a protobuf fixed64<br/>",
          "!type": "fn(index: number, value: number) -> RTSession.RTDataBuilder"
        },
        setFloat: {
          "!doc": "Adds a float at the given index key, the number will be added as a protobuf fixed32<br/>",
          "!type": "fn(index: number, value: number) -> RTSession.RTDataBuilder"
        },
        setFloatArray: {
          "!doc": "Adds a an array of floats at the given index key<br/>",
          "!type": "fn(index: number, values: [number]) -> RTSession.RTDataBuilder"
        },
        setNumber: {
          "!doc": "Adds a number at the given index key, the number will be added as a protobuf varint<br/>",
          "!type": "fn(index: number, value: number) -> RTSession.RTDataBuilder"
        },
        setString: {
          "!doc": "Adds a string at the given index key<br/>",
          "!type": "fn(index: number, value: string) -> RTSession.RTDataBuilder"
        }
      },
      RTLogger: {
        "!doc": "Allows log records to be written to the realtime.log collection<br/>",
        debug: {
          "!doc": "Logs a message at DEBUG level<br/>",
          "!type": "fn(msg: ?)"
        },
        error: {
          "!doc": "Logs a message at ERROR level<br/>",
          "!type": "fn(msg: ?)"
        },
        info: {
          "!doc": "Logs a message at INFO level<br/>",
          "!type": "fn(msg: ?)"
        },
        warn: {
          "!doc": "Logs a message at WARN level<br/>",
          "!type": "fn(msg: ?)"
        }
      },
      RTPacket: {
        "!doc": "An object representing a packet sent by a client<br/>",
        getData: {
          "!doc": "Gets the RTData sent with the packet (if available)<br/>",
          "!type": "fn() -> RTSession.RTData"
        },
        getSender: {
          "!doc": "Gets the player who sent the packet<br/>",
          "!type": "fn() -> RTSession.RTPlayer"
        },
        getTargetPlayers: {
          "!doc": "Gets the list of peerIds that this packet is being sent to. If this is empty the packet is targetting everyone except the sender <br/>",
          "!type": "fn() -> [number]"
        }
      },
      RTPacketBuilder: {
        "!doc": "A builder object to construct RTPacket objects<br/>",
        send: {
          "!doc": "Sends this packet to the current session with the given parameters<br/>",
          "!type": "fn()"
        },
        setData: {
          "!doc": "Sets the RTData of the packet<br/>",
          "!type": "fn(rtData: RTSession.RTDataBuilder) -> RTSession.RTPacketBuilder"
        },
        setOpCode: {
          "!doc": "Sets the opCode of the sent packet. Server sent packets will be send with opCode 0 if this is not set<br/>",
          "!type": "fn(opCode: number) -> RTSession.RTPacketBuilder"
        },
        setReliable: {
          "!doc": "Sets the packet to be sent as reliable. By default, server sent packets are sent as unreliable<br/>",
          "!type": "fn(reliable: bool) -> RTSession.RTPacketBuilder"
        },
        setSender: {
          "!doc": "Sets the peerId of the sent packet. Server sent packets will be send with peerId 0 if this is not set<br/>",
          "!type": "fn(peerId: number) -> RTSession.RTPacketBuilder"
        },
        setTargetPeers: {
          "!doc": "Sets the peer id's to send the packet to<br/>",
          "!type": "fn(peerIds: [number]) -> RTSession.RTPacketBuilder"
        }
      },
      RTPlayer: {
        "!doc": "An object representing a player<br/>",
        getPeerId: {
          "!doc": "Gets the realtime peerId of this player<br/>",
          "!type": "fn() -> number"
        },
        getPlayerId: {
          "!doc": "Gets the GameSparks playerId of this player<br/>",
          "!type": "fn() -> string"
        }
      }
    }
  }
]